{"posts":[{"title":"Gitlet Design Document","content":"This is the design document of my implementation of Gitlet, a version-control system that mimics some of the basic features of the popular system Git. It passed all tests on the gradescope autograder provided by University of California Berkeley, CS 61B. Source code is available upon request. Classes and Data Structures Main Driver class for Gitlet, a subset of the Git version-control system. Account for validating the number of arguments and invoking package-private methods according to received commands. The cache write back method Cache.writeBack() which enabling the persistence of Gitlet is also invoked in this class. Fields This class contains only static methods since Main should not be instantiated. static final File localCWD = new File(System.getProperty(&quot;user.dir&quot;)) The current working directory File object. static String currCommand A static variable that holds the current command. Used during pull command. public static void main(String[] args) The main method of Gitlet. private static void assertArgsNum(String[] args, int n) Throw a GitletException if args don't have exactly n elements. private static void assertNotArgsNum(String[] args, int n) Throw a GitletException if args have exactly n elements. private static String[] getOperands(String[] args) Strip the first element of the input array and return the rest. private static void assertString(String expected, String actual) Assert two String are equal. Cache This class is used to house static methods that facilitate lazy loading and caching of persistence. This file will set up data structures for caching, load necessary objects, and write back the cache at the very end of execution. This class will never be instantiated. This class defers all HashObject and its subclasses' logic to them. For example, instead of deserialize and serialize objects directly, Cache class will invoke methods from the corresponding class to do that. On the other hand, the Cache class will do all the getxxx() methods which retrieving desired objects lazily from the cache. Fields Caching HashObject static final Map&lt;String, HashObject&gt; cachedHashObjects A Map that stores cached ID and HashObject pairs. static Map&lt;String, HashObject&gt; cachedRemoteHashObjects The cache for the remote repository. private static HashObject getHashObject(String id) Lazy loading and caching of HashObjects. Being private because a HashObject will never be requested as HashObject (as Commit or Tree or Blob instead). Special case: return null if requesting a commit with null or &quot;&quot;. static Commit getCommit(String id) A method that lazy-load a Commit with id utilizing getHashObject(String id). static Tree getTree(String id) A method that lazy-load a Tree with id utilizing getHashObject(String id). static Blob getBlob(String id) A method that lazy-load a Blob with id utilizing getHashObject(String id). static Commit getLatestCommit() Get the Commit object of the latest commit utilizing getCommit(String id). static final Set&lt;String&gt; queuedForWriteHashObjects New HashObjects' IDs that are queued for writing to filesystem. static String cacheAndQueueForWriteHashObject(HashObject object) Manually cache a HashObject by put a HashObject into the cache, and queue it for writing to filesystem. Return its ID. static void writeBackAllQueuedHashObject() Write back all queued-for-writing HashObjects to filesystem. Invoked upon exit. static final Set&lt;String&gt; queuedForDeleteHashObject Deprecated HashObjects' IDs that are queued for deletion from filesystem. static void queueForDeleteHashObject(String id) Given Qa HashObject's ID, queue it for deletion. static void deleteAllQueuedHashObject() Delete all queued-for-deletion HashObjects. Invoked upon exit. Caching Branches static final Map&lt;String, String&gt; cachedBranches A Map that stores cached branch name and commit ID pairs. static Map&lt;String, String&gt; cachedRemoteBranches The cache for the remote repository. static String getBranch(String branchName) Lazy loading and caching of branches. static String getLatestCommitID() A method that lazy-load the ID of the latest commit by getBranch(getHEAD()). static void cacheBranch(String branchName, String commitID) Manually cache a Branch by putting a branchName - commitID pair into the cache. static void wipeBranch(String branchName) Manually wipe the pointer of a designated branch. static void writeBackAllBranches() Write back (update) all branches to filesystem. Invoked upon exit. If a branch's pointer is wiped out, delete the branch file in the filesystem. Special case: ignore branch with empty name. Caching HEAD static String cachedHEAD A String that stores cached HEAD, the current branch's name. static String cachedRemoteHEAD The cache for the remote repository. static String getHEAD() Lazy loading and caching of HEAD. static void cacheHEAD(String branchName) Manually cache the HEAD by assigning the cachedHEAD to a given branchName. static void writeBackHEAD() Write back (update) the HEAD file. Invoked upon exit. Caching STAGE (Stage ID) static String cachedStageID A String that stores cached STAGE, the ID of the current staging area. static String cachedRemoteStageID The cache for the remote repository. static String getStageID() Lazy loading and caching of STAGE (the ID of the saved staging area). Notice: this DOES NOT point to the current staging area after the staging area is modified and before write back. static void cacheStageID(String newStageID) Manually cache the STAGE by assigning the cachedStageID to a given stageID. static void writeBackStageID() Write back STAGE file. Invoked upon exit. Caching the Stage Area static Tree cachedStage A Tree that stores cached staging area. static Tree cachedRemoteStage The cache for the remote repository. static Tree getStage() Get the Tree object representing the staging area utilizing getTree(getStageID()). static void cacheStage(Tree stage) Queue the previous staging area for deletion and manually cache the passed-in Stage. Special case: queue the previous staging area for deletion only if there is a commit, and the previous staging area is different from the Tree of the latest commit, and the previous staging area is not empty. MISC static void writeBack() Write back all caches. Invoked upon exit. static void cleanCache() Reset all caches. Used for testing proposes. private static boolean inRemoteRepo() Return true if currently operating on the remote repository. Repository A class houses static methods related to the whole repository. This class will handle all actual Gitlet commands by invoking methods in other classes correctly. It also sets up persistence and do additional error checking. Fields Static Variables static File CWD The Current Working Directory. A package-private static variable. static File GITLET_DIR The .gitlet directory, where all the state of the repository will be stored. Package-private. static File HEAD The .gitlet/HEAD file. This file stores the name of the active branch. static File STAGE The .gitlet/STAGE file, where the ID of the current staging area is stored. static File ALL_COMMITS_ID The .gitlet/allCommitsID file, which is a serialized Tree that holds all the IDs of existing commits. static File OBJECTS_DIR The .gilet/objects directory. This is the object database where all HashObject live. static File BRANCHES_DIR The .gitlet/branches directory. Each branch is stored as a file under this directory. static void assignStaticVariables(File cwd) Assign the above static variables according to the given CWD. This is useful dealing with local and remote repositories. The current working directory is passed in as CWD for default, but the remote repository directory will be passed in when manipulating it. init command public static void init() The method which handles the init command. Implementation details in the Algorithms section. static void setUpPersistence() A helper method of init command, set up the persistence directories. Implementation details in the Algorithms section. This method also checks if there is an existing .gitlet directory and abort the execution if so. add command public static void add(String fileName) Execute the add command by adding a copy of the file as it currently exists to the staging area. commit command public static void commit(String message) Execute the commit command. rm command public static void rm(String fileName) Execute the rm command. Implementation details in the Algorithms section. log command public static void log() Execute the log command. Implementation details in the Algorithms section. private static void log(String CommitID) Print log information recursively. Starting from the commit with the given commit ID, to the initial commit. global-log command public static void globalLog() Print log information about all commits ever made. Implementation details in the Algorithms section. find command private static final List&lt;String&gt; foundCommitID A list of commit IDs that have the designated commit message. public static void find(String commitMessage) Execute the find command. Implementation details in the Algorithms section. private static void findCheck(String CommitID, String commitMessage) Check if the designated commit has the designated commit message. status command public static void status() Execute the status command. Implementation details in the Algorithms section. &quot;Modifications Not Staged For Commit&quot; private static void modificationStatus() Print the &quot;Modifications Not Staged For Commit&quot; status. private static List&lt;String&gt; modifiedNotStagedFiles() A private helper method that construct a list of &quot;modified but not staged&quot; files. Implementation details in the Algorithms section. private static Set&lt;String&gt; modifiedStatusFocusFiles() Return a string Set that contains all file names that should be checked (file names in the CWD or the Stage or tracked by the head Commit). private static boolean modifiedNotStagedFiles1(String fileName) Return true if a file is tracked in the current commit, changed in the working directory, but not staged (modified). private static boolean modifiedNotStagedFiles2(String fileName) Return true if a file is staged for addition, but with different contents than in the working directory (modified). private static boolean modifiedNotStagedFiles3(String fileName) Return true if a file is staged for addition, but deleted in the working directory (deleted). private static boolean modifiedNotStagedFiles4(String fileName) Return true if a file is not staged for removal, but tracked in the current commit and deleted from the working directory (deleted). static boolean trackedInHeadCommit(String fileName) Return true if a file is tracked in the head commit. static boolean changedInCWD(String fileName) Return true if a file is changed in the CWD (different from its version in the head commit). static boolean addDiffContent(String fileName) Return true if a file's version in the stage is different from the working one. static boolean notInCWD(String fileName) Return true if a file is not in the CWD. &quot;Untracked Files&quot; private static void untrackedStatus() Print the &quot;Untracked Files&quot; status. private static List&lt;String&gt; untrackedFiles() Return a list of files that is untracked (neither staged for addition nor tracked by the head commit). checkout command public static void checkout1(String fileName) Execute checkout command usage 1 (checkout a file to the latest commit). Implementation details in the Algorithms section. public static void checkout2(String commitID, String fileName) Execute checkout command usage 2 (checkout a file to the given commit). Implementation details in the Algorithms section. public static void checkout3(String branchName) Execute checkout command usage 3 (checkout all files to the designated branch). Implementation details in the Algorithms section. static void checkoutToCommit(String commitID) A helper method that checkout to a Commit (with designated ID). private static void checkoutAllCommitFile(String commitID) A private helper method that checkout all files that a Commit (with designated ID) tracked. private static void checkoutCommitFile(Commit commit, String fileName) A private helper method that checkout a file with fileName from a given Commit. branch command public static void branch(String branchName) Execute the branch command. Implementation details in the Algorithms section. rm-branch command public static void rmBranch(String branchName) Execute the rm-branch command. Implementation details in the Algorithms section. reset command public static void reset(String commitID) Execute the reset command. Implementation details in the Algorithms section. Abbreviated commit ID will be handled, and branches will always point to full IDs. merge command public static void merge(String branchName) Execute the merge command (merge files from the given branch into the current branch). Implementation details in the Algorithms section. private static void mergeModifyCWD(Commit curr, Commit other, Map&lt;String, Set&lt;String&gt;&gt; mergeModifications) Modify files in the CWD (either use the version in the other branch, or make a conflict file) accordingly. private static void makeConflict(Set&lt;String&gt; files, Commit curr, Commit other) Modify all conflict files and add them to the stage. private static String makeConflictContent(String fileName, Commit curr, Commit other) Return the right content for a conflict file after merging. private static void useOther(Set&lt;String&gt; files, Commit other) Modify files in CWD to their versions in the other commit, and stage the change (add or rm). private static Map&lt;String, Set&lt;String&gt;&gt; mergeWillModify(Commit split, Commit curr, Commit other) Perform the checks for the merge command and return a Map of necessary modifications. private static Map&lt;String, Set&lt;String&gt;&gt; mergeLogic(Set&lt;String&gt; focusFiles, Commit split, Commit curr, Commit other) A private helper method that captures the logic of the merge command. private static void mergeChecks1(Commit curr, Commit other) Perform checks for the merge command. private static void fastForward(Commit other) Fast-forward the current branch to the designated commit and print information. Only called when the split commit is the same as the current commit. Special case: do not print fast-forward info when pulling. private static void mergeChecks2(Set&lt;String&gt; changingFiles) Perform checks for the merge command. misc private static void assertGITLET() Assert the CWD contains a .gitlet directory. private static void overwriteCWDFile(String fileName, Blob overwriteSrc) Overwrite the file in CWD of designated file name with the content in the given Blob object. static void sortLexico(List&lt;String&gt; list) Sort a string List in lexicographical order in place. static void deleteCWDFiles() Delete all files in the CWD. private static Set&lt;String&gt; CWDFilesSet() Return a Set of all files' names in the CWD. private static&lt;T&gt; Set&lt;T&gt; combineSets(Set&lt;T&gt;... sets) Generic method to merge (union) multiple sets in Java. static void printAndExit(String msg) Print a message and exit the execution with status 0. Branch This class houses static methods that related to branch and HEAD. It contains methods for loading and writing branch files and the HEAD file. This class will never be instantiated since there are only static methods. Fields static String loadBranch(String branchName) Load a branch file from filesystem with designated name. Return null if the branch name is &quot;&quot; (nothing) or there is no branch. Invoked by the Cache class. static boolean existBranch(String branchName) Return true if a branch exists. static List&lt;String&gt; loadAllBranches() Load all branch files from the filesystem. Return a List contains all commit IDs that are pointed by a branch. static void branchStatus() Print the &quot;Branches&quot; status. Implementation details in the Algorithms section. static void writeBranch(String branchName) Get a branch's information from cache and write it back to filesystem. Invoked by the Cache class. static void deleteBranch(String branchName) Delete the designated branch in the filesystem. Invoked by the Cache class. static void mkNewBranch(String branchName, String commitID) Make a new branch with designated name at the latest commit by caching it manually. static void moveCurrBranch(String commitID) Make the current branch pointing to a designated commit. static void moveBranch(String branchName, String commitID) Move the designated branch to point to a commit with designated ID. static String loadHEAD() Load the HEAD file and return the current branch's name. Invoked by the Cache class. static void writeHEAD() Get the HEAD from cache and write it back to filesystem. Invoked by the Cache class. static void moveHEAD(String branchName) Make the HEAD pointing to a designated branch. private static File branchFile(String branchName) Get the File object of a branch with designated name. private static List&lt;String&gt; allBranches() Return a List of all branches' names. Support fetched remote branches. Stage This class houses static methods that related to Stage (the staging area). It contains methods for loading and writing the STAGE file, as well as making a new staging area. This class will never be instantiated since there are only static methods. Fields static String loadStageID() Return the ID of the current staging area (a Tree object). Invoked by the Cache class. static void putInStage(String fileName, String BlobID) Copy the staging area and add a fileName - BlobID pair. Mark the previous staging area Tree for deletion. This function should only be invoked once per run. static void removeFromStage(String fileName) Copy the staging area and remove the entry with a specific fileName (if exists) from it. Mark the previous staging area Tree for deletion. This function should only be invoked once per run. static void writeStageID() Write the stage ID in cache back to filesystem. Invoked by the Cache class. static void mkNewStage() Make a new stage (a Tree object) and cache its ID. static void addToStage(String fileName) Add a file to the current staging area. Implementation details in the Algorithms section. static void stageStatus() Print the status information related with the staging area. private static List&lt;String&gt; stagedFiles() Return a sorted List of file names in the current staging area. private static void stagedFilesStatus() Print the &quot;Staged Files&quot; status. Implementation details in the Algorithms section. private static void removedFilesStatus() Print the &quot;Removed Files&quot; status. Implementation details in the Algorithms section. static boolean isStagedForAdd(String fileName) Return true if a designated file is staged for addition. static boolean isStagedForRemoval(String fileName) Return true if a designated file is staged for removal. HashObject This class represents a HashObject that will be serialized within .gitlet/objects, named after its SHA-1. HashObject is an implementation of Serializable and Dumpable. This file has helper methods that will return the SHA-1 (ID) of a HashObject. As well as static methods that returning the HashObject object corresponding to its ID (SHA-1), and write to or delete from the object database a HashObject. Fields private static final Boolean OPTIMIZATION Allow you to switch between flat objects directory (easy to debug) and HashTable objects directory (better performance). Notice: this should be consistence for a single Gitlet repository. String id() Get the SHA-1 of THIS. public void dump() Print the type of this object on System.out. static HashObject loadHashObject(String id) Load a type object with its ID. Special case: return null if told to load an object that does not exist. static void writeCachedHashObject(String id) Write a cached HashObject with ID in cachedObjects to filesystem. static void deleteHashObject(String id) Delete a HashObject from filesystem. static private File optimizedObjectIDFolder(String id) Helper method that returns the housing directory of a HashObject with the given ID. Used in the optimized object database. static private File optimizedObjectIDFile(String id) Helper method that returns the file of a HashObject with the given ID. Used in the optimized object database. static private File optimizedObjectAbbrevIDFile(String id) Helper method that return the file of a HashObject with the given abbreviated ID. Used in the optimized object database. Despite HashObject should be instantiated very often, it has no constructor method(s). Any HashObject is designed to be instantiated as a more specific subclass, namely Commit, Tree, or Blob. Commit This class represents a Commit in Gitlet, it extends the HashObject class. Each instance of Commit have several instance variables such as commit message and time stamp. This file also has helper methods that unlocks instance variable as well as static method that carry out the procedure to make a new commit. Fields private final String _message The commit message. private final String _parentCommitID The ID of the parent commit. private final String _parentMergeCommitID The ID of the second parent (if any). private final Date _timeStamp A time stamp of the commit been made. private final String _treeID The ID of the associated Tree object. private Commit(String parentCommitID, String message, String treeRef) The constructor of Commit class. This method is private because no &quot;naked&quot; instantiation of Commit is allowed outside the Commit class. Additionally, the time stamp is set to 1970.01.01 00:00:00 for initial commit. private Commit(String firstCommitID, String secondCommitID, String message, String treeRef) Constructor for merge commits. public String toString() Content-addressable overriding toString() method. String logString() Return the log information of this Commit. public void dump() Print information of this Commit on System.out. String getMessage() Get the message of this Commit. String getParentCommitID() Get the ID of the parent commit. String getParentMergeCommitID() Get the ID of the second parent commit. Commit getParentCommit() Get the Commit object of the parent commit. Commit getParentMergeCommit() Get the Commit object ot the second parent commit. String getCommitTreeID() Get the ID of the associating Tree of this commit. Tree getCommitTree() Get the associating Tree of this commit. String getBlobID(String fileName) Get the ID of the Blob of a designated file name in this commit. String getFileContent(String fileName) Return the content of a designated file name in this commit. Special case: return an empty String if there is no corresponding Blob. Boolean trackedFile(String fileName) Return whether this Commit contains a file with fileName. Set&lt;String&gt; trackedFiles() Return a string Set of tracked files of this commit. static void mkCommit(String message) Factory method. Make a new Commit. Implementation details in the Algorithm section. static void mkMergeCommit(String givenBranchName, Boolean conflicted) Factory method. Make a new merge Commit. static Commit lca(Commit commit1, Commit commit2) Return the latest common ancestor (LCA) of two Commits. static Set&lt;String&gt; ancestors(Commit commit) Recursively collect and return a Set of all ancestors' ID of the given Commit object, including merge parents. Special case: return an empty Set if the given Commit is null. static void recordCommitID(String commitID) Record a new commit's ID to the .gitlet/allCommitsID file. static Tree getAllCommitsID() Return a Tree object that captures all IDs of commits ever made. Tree Represent a Gitlet Tree, corresponding to UNIX directory entries. Implements Iterable&lt;String&gt;, extends HashObject. An instance of Tree object contains a TreeMap as instance variable, which has zero or more entries. Each of these entries is a fileName - BlobID pair. This class also contains Tree related static methods. Fields private final Map&lt;String, String&gt; _structure The TreeMap that stores fileName - blobID pairs. Tree() The constructor of Tree class. Tree(Tree another) A constructor that deep-copy the passed-in Tree. public String toString() Content-addressable overriding toString() method. public void dump() Print information of this Tree on System.out. boolean isEmpty() Return whether this Tree is empty. boolean containsFile(String fileName) Return true if a Tree contains a file with fileName. List&lt;String&gt; trackedFiles() Return the sorted list of file names in this Tree following a Java string-comparison order. void putBlobID(String fileName, String blobRef) Record a fileName - blobID pairs. void removeBlobID(String fileName) Remove an entry with fileName as the key from this Tree. String getBlobID(String fileName) Return the ID of a Blob according to a given fileName (if exists). Blob getBlob(String fileName) Return a Blob according to a given fileName (if exist). public Iterator&lt;String&gt; iterator() Returns an Iterator of this Tree, namely the keySet() of its TreeMap. void updateWith(Tree updater) Update this Tree with the entries in the given Tree. Special case: remove the corresponding pair from this if the value to a key in the updater is null. static String mkNewEmptyTree() Factory method. Creates an empty Tree, cache it and return its ID. static Tree getLatestCommitTree() Factory method. Return the copy of the Tree of the latest commit if exists. Special case: return null if there is no latest commit. static String mkCommitTree() Factory method. Return a Tree that capture the Tree from the latest commit as well as current addition and removal status. Implementation details in the Algorithm section. Special cases: make a new empty tree if there is no Tree in the latest commit. private static Tree copyLatestCommitTree() Factory method. Return a deep-copy of the Tree in the latest commit. static Teww CWDFiles() Return a temporary Tree that capture information of files in CWD. Blob Represent a Gitlet Blob, corresponding to UNIX files. Extends HashObject. Blob has one instance variable _content, which holding the content of a file. This variable enables a Blob to represent a version of such file. This class also has Blob related static methods. Fields private final String _content The instance variable that hold the content of a version of a file. Blob(String content) The private constructor of Blob. No &quot;naked&quot; instantiation of Blob is allowed. String getContent() Unlocks the content of a Blob. public String toString() Content-addressable overriding toString() method. public void dump() Print information of this Tree on System.out. static String mkBlob(String fileName) Factory method. Make a new Blob with a designated file. Cache it and queue it for writing to filesystem. Special case: adding a file that not exists in the CWD means adding it for removal. static String currFileID(String fileName) Return the ID of a designated file's Blob without cache or saving a Blob. Remote Represent a remote Gitlet repository and accommodating remote commands related methods. Fields Non-static methods File _remoteWD Stores the working directory of this remote repository as a File object. private Remote(File remoteGitlet) Construct a remote repository representation. private void remoteRunner() Change the CWD in the Gitlet running environment to the remote repository's working directory. Must call before commanding the remote repository. private void localRunner() Change the CWD in Gitlet running environment to the local repository's working directory. Methods that simply calling remoteRunner() and localRunner() before and after calling the method with the same signature from other classes. private String getHEAD() private Commit getLatestCommit() private String getBranch(String branchName) private Commit getCommit(String id) private String cacheAndQueueForWriteHashObject(HashObject object) private void writeBack() private Set&lt;String&gt; commitAncestors(Commit commit) private void moveHEAD(String branchName) private void moveCurrBranch(String commitID) private void checkoutToCommit(String commitID) private boolean existBranch(String branchName) private void mkNewBranch(String branchName) private void mkNewStage() private Tree getCommitTree(Commit commit) private Blob getBlob(String blobID) private void recordCommitID(String commitID) Static methods add-remote command public static void addRemote(String remoteName, String path) Execute the add-remote command by creating a reference to the remote repository. private static void writeRemote(File remoteFile, String path) Write a remote repository reference. static File readRemote(String remoteName) Get the File referencing the remote (in the local repository). rm-remote command static File getRemoteGitlet(String remoteName) Get the File of the remote .gitlet directory. push command public static void push(String remoteName, String remoteBranchName) Executing the push command. private static void pushReset(Remote remote, String commitID, String remoteBranchName) Fast-forward the remote repository. private static Set&lt;String&gt; commitsToPush(Commit localC, Commit remoteC, Remote remote) Return a Set of String containing the IDs of commits that should be pushed to the remote repo. private static void pushCommits(Set&lt;String&gt; commitIDs, Remote remote) Push all Commit with the designated ID in the Set, and its associating Tree and Blob to the remote repository. private static void pushCommit(Commit commit, Remote remote) Push a single Commit and its associating Tree and Blob to the remote repository. fetch command public static void fetch(String remoteName, String remoteBranchName) Execute the fetch command. Implementation details in the Algorithms section. private static Set&lt;String&gt; commitsToFetch(Commit localC, Commit remoteC, Remote remote) Return a Set of String containing the IDs of commits that should be fetched from the remote repo. private static void fetchCommits(Remote remote, Set&lt;String&gt; commitIDs) Fetch commits that their IDs in the Set to the local repo. private static void fetchCommit(Remote remote, String commitID) Fetch a commit to the local repo. pull command public static void pull(String remoteName, String remoteBranchName) Execute the pull command. Implementation details in the Algorithms section. GitletTest This class contains JUnit tests and some helper methods for Gitlet. Fields init command public void initCommandSanityTest() Sanity test for init command. add command public void addCommandSanityTest() Sanity test for add command. public void addCommandTwiceTest() Test using add command twice. commit command public void commitSanityTest() Sanity test for commit command. public void dummyCommitTest() Dummy commit test (commit without adding anything). public void commitAndAddTest() Add a file, make a commit, and add another file. public void addAndRestoreTest() Make a commit, change the file and add, then change back and add. The staging area should be empty. rm command public void rmUnstageTest() The rm command should unstage the added file. public void rmCommitTest() Add a file, commit, and rm it, commit again. The latest commit should have an empty commit tree. The file in the CWD should be deleted. log command public void logSanityTest() Sanity test for log command. Init and log. public void simpleLogTest() Simple test for log command. Init, commit, and log. public void normalLogTest() Normal test for log command. Init, commit, commit, and log. global-log command public void globalLogSanityTest() Sanity test for global-log command. public void globalLogBranchTest() Test for global-log command with branching. Need implementation. find command public void findSanityTest() Sanity test for find command. public void findBranchTest() Test for find command with branching. Need implementation. status command public void statusBasicTest() Basic test for status command. public void statusModification3Test() Test extra functions (&quot;Modification Not Staged For Commit&quot;) condition 3 of status command. public void statusModification4Test() Test extra functions (&quot;Modification Not Staged For Commit&quot;) condition 4 of status command. public void statusUntrackedTest() Test extra functions (&quot;Untracked Files&quot;) of status command. checkout command public void checkoutHeadFileSanityTest() Sanity test for checkout usage 1 (checkout a file to the latest commit). public void checkoutCommitFileSanityTest() Sanity test for checkout usage 2 (checkout a file to the given commit). public void checkoutBranchSanityTest() Sanity test for checkout usage 3 (checkout to a branch). branch command public void branchSanityTest() Sanity test for branch command. rm-branch command public void rmBranchSanityTest() Sanity test for rm-branch command. reset command public void resetSanityTest() Sanity test for reset command. merge command public void lcaTest() Test the lca method. public void mergeSanityTest() A sanity test for the merge command. public void mergeConflictTest() Test merging two branches with conflict. public void mergeTest() A hard (and comprehensive) test for the merge command. add-remote command public void addRemoteTest()A sanity test for add-remote. push command public void pushTest() A sanity test for add-remote command. fetch command public void fetchTest() A sanity test for fetch command. pull command public void pullTest() A sanity test for pull command. Auto grader debug tests public void test20_status_after_commit() public void test24_global_log_prev() public void test29_bad_checkouts_err() public void test35_merge_rm_conflicts() public void test36a_merge_parent2() misc static final File CWD The local repository's working directory. private static void GitletExecute(String... command) Execute commands with Gitlet and clean the cache after execution. Special case: make sure there is no .gitlet directory before the init command. Implemented for testing purposes. private static void writeTestFile(String fileName, String content) Write content into a designated file name. Overwriting or creating file as needed. private static void deleteTestFile(String fileName) Delete the file with the designated name. private static String readTestFile(String fileName) Read the designated file as String and return it. private static void deleteDirectory(File directoryToBeDeleted) Delete a directory recursively. private static void writeAndAdd(String fileName, String content) Write a test file with the designated file name and content, then add it to the stage. private static void assertFile(String fileName, String content) Assert a designated file has the designated content. Algorithms Lazy Loading and Caching Lazy Loading: Only retrieve information from your file system when you need it, not all at once in the beginning. Caching: Once you load something from your file system, save it in your Java program, so you donâ€™t need to load it again. (E.g. as an attribute or an entry in a Map.) Writing back: If you cached something and then modified it, make sure at the end of your Java program, you write the changes to your file system. Reference: Gitlet Persistence In this implementation of Gitlet, I used a standalone java Class Cache.java to accommodate code for lazy-loading and caching. During lazy loading, the load****() method for specific Class is invoked to retrieve an instance of that Class by specifying the object's ID. Additionally, Commit, Tree, and Blob don't have standalone load****() methods because they are subclasses of HashObject. After loading, the cached object is saved into the corresponding static variable. Namely, a TreeMap cachedHashObjects will store ID to HashObject pairs, another TreeMap cachedBranches will store branchName to commitID pairs, a String cachedHEAD will store the content of .gitlet/HEAD (the current branch's name), and a String cachedStageID will store the content of .gitlet/STAGE (the ID of the staging area Tree). Additionally, there is List queuedForWriteHashObjects and queuedForDeleteHashObject that hold IDs that should be (re)write to or delete from the filesystem. These Lists are updated along the course of execution by cacheAndQueueForWriteHashObject(HashObject object) and queueForDeleteHashObject(String id). Note that a HashObject will never be modified after its creation. Therefore, no modification of existing HashObjects will be carried out thus there is no such queuedForModifyHashObjects data structure. At the very end of execution, caches will be written back to filesystem. Entries in cachedHashObjects, will be written to or delete from filesystem based on the IDs contained in queuedForWriteHashObjects and queuedForDeleteHashObject. Additionally, cachedBranches, cachedHEAD, cachedStageID will be rewritten anyway since the size of related persistence are trivial for the most time. Get the ID of a HashObject Every HashObject need to be serialized and saved in filesystem, thus a unique file name (ID) is indispensable. We use SHA-1 (Secure Hashcode Algorithm 1) hashcode as a content-addressable ID of every HashOject. In order to achieve content-addressability, the following two characteristics is necessary: Different HashObjects with identical contents should have the same ID. A HashObject's ID should change after it is modified in terms of its contents. To accomplish such requirements, ID of a HashObject is generated from applying SHA-1 on its string representation. And subclasses of the HashObject class overrides the default toString() method to make it content-addressable. Saving, loading, or deleting a HashObject If the static variable OPTIMIZATION in HashObject class is set to true, Gitlet will construct a HashTable-liked structure in the .gitlet/objects directory. That is, all HashObject (with a 40-character ID) will be stored under the .gitlet/objects/xx directory and named after xxx, where xx is the leading two characters of its ID and xxx is the left 38 characters. The point of this optimization is speeding up retrieving Commit when the user abbreviate commit ID with a unique prefix. The real Git is also utilizing this technique. When the user provide an abbreviated commit ID, Gitlet will go to the corresponding .gitlet/objects/xx directory and iterate through a list of file names in that directory in order to figure out the comprehensive commit ID. On the other hand, if OPTIMIZATION is set to false, all HashObject will be stored flatly under the .gitlet/objects directory and named after the corresponding ID. This set up is might be more convenient when digging into the object database for debugging purposes. Due to performance concerns, referring commits with abbreviated IDs is not allowed when OPTIMIZATION is set to false. Initialize the repository Set up the repository Create an initial commit Set up the repository Set up persistence directories Make the default branch &quot;master&quot; which is pointing null for now (no pun intended) Make the HEAD pointing to the master branch Make a new staging area Initialize and serialize a Tree to .gitlet/allCommitsID Make a Commit Get the ID of the latest commit Make a commit Tree by copying from the latest commit, and update it with the staging area Construct a new Commit object with the private constructor Cache the new Commit and queue it for write back Move the current branch pointing the new commit Make a new staging area Record the new commit's ID Make a commit Tree A commit Tree is a Tree that every commit uses to record the associated file names and file versions (Blob). Get a copy of the Tree of the latest commit Get the staging area Tree Update that copy with the staging area (Special case: remove the corresponding pair from that copy if the value to a key in the staging area is null, i.e., staged for removal) Cache it and queue it for writing Stage a file for addition Get the file as its current version, cache it as a Blob (don't queue for write back yet) Get the version of the designated file from the latest commit Special case: If the current version of the file is identical to the version in the latest commit (by comparing IDs), do not stage it, and remove it from the staging area if it is already there. End the execution. Modify cached staging area Stage a file for removal Abort if the file is neither staged nor tracked by the head commit. If the file is currently staged for addition, unstage it. If the file is tracked in the current commit, stage it for removal and remove it from the CWD. When it comes to the design decision of representing &quot;staged for removal&quot;, the chosen solution is to treat pairs in the staging tree with &quot;&quot; (an empty String) value as staged for removal. That is, when a file is staged for removal: It is deleted from the CWD if the user haven't done that. It is &quot;added&quot; to the staging area. Given the fact that there is no such file in the CWD, a {fileName - &quot;&quot;} pair will be written into the staging area. When making a commit Tree, staged for removal file will be handled and the new commit Tree will not include the staged-for-removal files. In this manner, problems with naive approaches (such as introduce a &quot;staging area for removal&quot; Tree) is avoided, and the amount of codes to implement the rm command is trivial. Print log Get the ID of the latest commit Print log information starting from that commit to the initial commit recursively Get the Commit object with the given CommitID Print its log information Recursively print its ascendants' log information Print global log Get the allCommitsID Tree which holds all commits' IDs. Print log information for each of the IDs. The find command This command has similar algorithm with the global-log command. Both of these commands cover all commits ever made by the same manner. Get the allCommitsID Tree which holds all commits' IDs. Check each commit whether it has the designated commit message. Print repository status The status information is consist of the following five parts. &quot;Branches&quot; Get a list of all branches by reading the filenames in the .gitlet/branches directory. Sort the list in lexicographical order. Print the header and all branches, print an asterisk before printing the current branch. &quot;Staged Files&quot; and &quot;Removed Files&quot; Get the current staging area, and get a lexicographical sorted list of filenames it currently holds. If a filename has an empty corresponding BlobID in the staging area, print it under &quot;Removed Files&quot;; if a filename has a valid corresponding BlobID in the staging area, print it under &quot;Staged Files&quot;. &quot;Modifications Not Staged For Commit&quot; Get a Set of all file names that should be checked (file names in the CWD, the staging area, and the head commit). Check each file name and fill a List for &quot;modified but not staged files&quot;. Conditions are described below. Record the file name concatenates (modified) if it satisfies condition 1 or 2. Record the file name concatenates (deleted) if it satisfies condition 3 or 4. A file name is either marked as modified or marked as deleted or not marked. Print the List. &quot;Untracked Files&quot; Get a list of all untracked files. A file is untracked if it is neither staged for addition nor tracked by the head commit. Print the file names. Conditions for &quot;Modifications Not Staged For Commit&quot;: Tracked in the current commit, changed in the working directory, but not staged. Staged for addition, but with different contents than in the working directory. Staged for addition, but deleted in the working directory. Not staged for removal, but tracked in the current commit and deleted from the working directory. Get a list of untracked files Get the information of files in the CWD as a Tree object. Get the head Commit object. Iterate through the file names in the CWD, add it to a list of untracked files if it: is not staged for addition (not contained in the staging area or its corresponding Blob ID is empty) is not tracked by the head commit Sort the untracked files list in lexicographical order The checkout command Checkout a file to HEAD commit Get the ID of the latest commit Invoke checkout2(String commitID, String fileName) method with the ID of the latest commit. Checkout a file to the commit with the designated ID Get the Commit object with the designated commit ID Get the designated file's Blob object form that commit Overwrite the file with that name in the CWD Checkout to a designated branch Perform checks: Gitlet will abort if no branch with the given name exists, or that branch is the current branch, or a working file is untracked. Move the HEAD to that branch. Checkout to the commit that the branch is pointing to. Checkout to a designated commit Delete all files in the CWD. Checkout all files tracked by that commit. Clean the staging area. Create a new branch Creating new branches is carried out when branch or init command is given. When creating new branches, the operation under the hood is no more than writing a branchName - CommitID pair into the cachedBranches which is then written back to the filesystem upon exit. The CommitID assigned to the new branch is always the latest commit (head commit) if there is one. For the default &quot;master&quot; branch which is created right before the initial commit, its corresponding is null at the very first (but pointed to the initial commit after the initial commit is created). Remove a branch This command delete the branch with the given name. It does not delete any commits under that branch. Abort if the designated branch does not exist Abort if the designated branch is the current branch Wipe the branch's pointer in the cache and delete the branch file upon exit Reset to a designated commit Perform the checks: the commit with the designated ID exists, and there is no working untracked file. Checkout to the designated commit. Move the current branch to that commit (The biggest difference between reset and checkout [branch name] command). Merge files from the given branch into the current branch The merge command is one of the most complicated commands in Gitlet. Therefore, the execution of this command is divided to multiple helper methods. Generally, the following procedure is followed to execute this command. Get the latest Commit object of the current branch, the given branch, and the common ancestors (split commit). Perform checks. Calculate which files will be changed in what manners, and perform checks. Modify the CWD following the result from step 2, staging for addition or removal as we go. Make a merge commit. Get the latest common ancestor (split commit) of two commits Get a Set of all ancestors' ID of a commit. This is accomplished by recursively collect all parent commit(s)' ID(s) and their parent(s)' ID(s), like breadth-first-search. Note that a merge commit has two parents, both will be collected as its ancestor. Starting from the other commit, breadth-first-search the first commit that its ID is in the Set. Determine which files will be changed in what manners Get a Set of file names that should be checked by combining sets of file names tracked by the split, current, and the other branch's head commits. Construct a Map of String to Set of String Map&lt;String, Set&lt;String&gt;&gt;, where &quot;other&quot; is mapped to a Set of files' file names that should use the version in the other (given) branch's head commit, and &quot;conflict&quot; is mapped to a Set of files' file names that conflict after merging. For file names in the Set need to be checked, Add to &quot;other&quot;'s value Set if the version of such file in the split commit is the same of it in the current commit (has the same content or both not exists). Add to &quot;conflictt&quot;'s value Set if the version in the split commit, the current commit, and the other branch's head commit is all different from each other. Perform checks for the merge command Abort merging if a branch with the given name does not exist. Abort merging if there are staged additions or removals present. Abort merging if attempting to merge a branch with itself. Exit if the split point is the same commit as the given branch's head commit. The merge is complete. Fast-forward and exit if the split point is the same commit as the current branch. Abort merging if an untracked file in the current commit would be overwritten or deleted by the merge. This is checked after which files will be changed is determined. Abort merging if there are unstaged changes to file that would be changed by the merge. This is checked after which files will be changed is determined. Modify the CWD for merging, make merge Commit The Map recoding necessary modification is disassembled into two Sets (one holding file names that should be changed to their version in the given branch's head commit, and one holding file names that resulting in conflicts). Two helper methods are utilized to carry out the modifications. The changes will be staged immediately. Making a merge Commit is not so different from making a normal commit, despite the new commit will have two parent commit IDs, the first is the current commit ID and the second is the ID of the given branch's head commit. Lastly, Gitlet will print a message to the console if any conflict is made. Remote commands Commands related with remote repository requires reuse of existing code for the local repository. To fulfill this demand, static variables (such as CWD, or GITLET_DIR) in the Repository class are no longer final and will be assigned each time. That is, when executing commands on the local repository, static variables will be assigned normally; while executing commands on the remote repository, these static variables will be assigned according to the remote working directory, thus reuse the existing code to manipulating the remote repository. add and remove a remote This command only involved manipulation to the local repository (creating path reference to the remote repository). push command Get the Commit object of the local repository's head commit and the front commit of the remote repository's given branch. Create a new branch at the remote repository if such branch does not exist. Calculate the commits need to be pushed by contracting the ancestors of the two commits. Push the Commits (and their associating Tree and Blob) to the remote repository. Specifically, using the caching and writing back mechanisms developed for the local repository. Commit's IDs are added to the remote allCommitsID file upon pushing. Reset the remote repository (change it to the given branch and fast-forward that branch). fetch command Get the Commit object of the local repository's fetched branch's head commit and the head commit of the remote repository's designated branch. Calculate the commits need to be fetched by contracting the ancestors of the two commits. Fetch the Commits (and their associating Tree and Blob) to the local repository. Specifically, using the caching and writing back mechanisms of the local repository. Commit's IDs are added to the local allCommitsID file upon fetching. pull command This command is executed simply fetch the designated remote branch using the fetch command, and then merge the fetched branch into the current branch using the merge command. Persistence The directory structure looks like this: CWD &lt;==== Whatever the current working directory is â””â”€â”€ .gitlet &lt;==== All persistant data is stored within here â”œâ”€â”€ HEAD &lt;==== The name of the current branch â”œâ”€â”€ STAGE &lt;==== A hash pointer to the serialized staging area Tree â”œâ”€â”€ allCommitsID &lt;==== A serialized Tree that contains all commits' IDs â”œâ”€â”€ objects &lt;==== The object database (all HashObject lives here) â”‚ â”œâ”€â”€ d9 &lt;==== Saves all HashObject with ID stating with &quot;d9&quot; â”‚ â”‚ â”œâ”€â”€ 91f6cad12cc1bfb64791e893fa01ac5bf8358e &lt;==== A saved HashObject, named after its ID without the first two letters â”‚ â”‚ â””â”€â”€ ... â”‚ â””â”€â”€ ... â”œâ”€â”€ branches &lt;==== Store all the branch references â”‚ â”œâ”€â”€ R1 &lt;==== Directory of branches fetched from a remote repository â”‚ â”‚ â”œâ”€â”€ master &lt;==== A branch fetched from a remote, will be displayed as &quot;R1/master&quot; â”‚ â”‚ â””â”€â”€ ... â”‚ â”œâ”€â”€ master &lt;==== The default branch. Contains a hash pointer to a commit â”‚ â””â”€â”€ ... â””â”€â”€ remotes &lt;==== Store all the remote references â”œâ”€â”€ R1 &lt;==== A remote references in String, e.g. [remote directory]/.gitlet â””â”€â”€ ... Commands init command The Repository.setUpPersistence() method will set up all persistence. It will: Abort if there is already a Gitlet version-control system in the current directory Create .gitlet/branches and .gitlet/objects folders Create .gitlet/HEAD, .gitlet/STAGE, and .gitlet/allCommitsID After setting up all persistence, the init command will do its jobs. Finally, all changes that should be persistent (including branching, HEAD, new commit, and Tree for that commit) will be written to filesystem automatically by the Cache.writeBack method invoked in Main.main(String[] args). add command This command will modify persistence in the following two cases: If the current version of the added file is identical to the version in the latest commit, that file will be removed from the staging area if it is already there. (as can happen when a file is changed, added, and then changed back to its original version) If case 1 isn't happening and the added file is different from the version that is already in the staging area (if it exists), a new staging area containing the added file is saved to filesystem. commit command The commit command will modify persistence following the following rules (no pun intended): Save a serialized Commit object in the object database Overwrite the current branch's file, make it contains the new commit's ID Make a new staging area and overwrite the STAGE file Record the new commits' ID to .gitlet/allCommitsID Delete the previous staging area if it is not empty, and there is a commit already (subtle bug may exist) rm command The rm command will change the current staging area Tree if the designated file is added (removing from the staging area) or exists in the head commit (staging for removal). checkout command This command will write the current working directory, but only read persistence. An exception is that when checking out to a branch, the staging area will be cleared. branch command When a branch is created, a branchName - CommitID pair will be written into the cachedBranches data structure. Upon exit, the cachedBranches will be written back to the filesystem, i.e. the persistence will be modified according to cached information. rm-branch command When a branch is removed, the corresponding file under the .gitlet/branches directory will be deleted. reset command This command will write the current working directory and clear the staging area. merge command If the merging is carried out successfully, this command will change the persistence just like the commit command. add-remote and rm-remote command These two commands will create/delete files in .gitlet/remotes/ directory. push, fetch, and pull command These two commands will add serialized HashObject to the object database, as well as the branch files, the .gitlet/HEAD file, and the .gitlet/allCommitsID file. ","link":"https://311zzb.github.io/post/gitlet-design-document/"},{"title":"Subtype polymorphism in Java: Overriding vs. Overloading","content":"Subtype polymorphism (providing a single interface to entities of different types) and dynamic type selection (DMS) might be one of the most obscure part for Java beginners like me. Here I am trying to write an article on this topic gathering my solutions and approaches to problems in such topic. Disclaimer: Most materials and examples are collected from University of California Berkeley CS61b Spring 2021. Copyright belongs to the original author. What are overriding and overloading Overriding: if a â€œsubclassâ€ has a method with the exact same signatures as in the â€œsuperclassâ€, we say the subclass overrides the method. Overloading: methods with the same name but different signatures are overloaded. The signature of a method is composed of a name and the number, type, and order of its parameters. However, return types, thrown exceptions, and names of parameters are not included in signature. A subtle point is that there is no â€œone method overloads another methodâ€. Methods in an overloading situation are like siblings instead of parent and children for an overriding scenario. /* abs is overloaded */ public class Math { public int abs(int a) { } public double abs(double a) { } public interface Animal { public void makeNoise(); } /* makeNoise is overloaded */ public class Dog implements Animal { public void makeNoise(Dog x) { System.out.print(&quot;Woof&quot;); } } /* Pig overrides makeNoise() */ public class Pig implements Animal { @Override public void makeNoise() { System.out.print(â€œoinkâ€); } } Static and dynamic type An variableâ€™s static type is specified when the variable is declared, and is determined at compile time. On the other hand, dynamic type is specified when the variable is instantiated, and is determined at runtime. The static type of an variable can never change along the course of running the program, but its dynamic type could be modified by assigning. Thing a; a = new Fox(); Animal b = (Animal) a; Fox c = (Fox) b; a = new Squid(); The static and dynamic types of variables after running the above code would be: Static type Dynamic type a Thing Squid b Animal Fox c Fox Fox As a reminder, what equal assignment does in Java is just â€œcopying bitsâ€. And any reference type objects is stored in the variable as a pointer to its actual address. This is to say, when assigning primitive type objects, such as Integer, Java copy the actual â€œthingâ€. On the other hand, Java only copy the address of the referential object to what is on the left side of the equal sign. Therefore, variable b is holding the address of a after we assign a to b on line 3. This is originally invalid consider (static type of) a is a Thing but b is an Animal, but the casting (Animal) is making the compiler considering a as an Animal type, thus avoiding a compile error. At runtime, the casting is smoothly carried out given the fact that Fox is an Animal, and the variable b is now holding the address of the same Fox object as a. Dynamic method selection The rule of DMS is straight forward: if we have a static type X, and a dynamic type Y, then if Y overrides the method from X, then on runtime, we use the method in Y instead. We can also think about DMS as a 2 step process, where step 1 happens at compile time, and step 2 happens at runtime. At compile time: We determine the signature S of the method to be called. S is decided using ONLY static types. At runtime: The dynamic type of the invoking object uses its method with this exact signature S. By â€œinvoking objectâ€, we mean the object whose method is invoked. Letâ€™s try it out. public interface Animal { default void greet(Animal a) { print(&quot;hello animal&quot;); } default void sniff(Animal a) { print(&quot;sniff animal&quot;); } default void praise(Animal a) { print(&quot;u r cool animal&quot;); } } public class Dog implements Animal { @Override void sniff(Animal a) { print(&quot;dog sniff animal&quot;); } void praise(Dog a) { print(&quot;u r cool dog&quot;); } public static void main(String[] args) { Animal a = new Dog(); Dog d = new Dog(); a.greet(d); a.sniff(d); d.praise(d); a.praise(d); } } The first step to figure out what is going to be displayed is to write down the types. Static type Dynamic type a Animal Dog d Dog Dog After that, let's write down the signature of each call at compile time based on the invoking objectsâ€™ static types. a.greet(d); // greet(Animal a) a.sniff(d); // sniff(Animal a) d.praise(d); // praise(Dog a) a.praise(d); // praise(Animal a) Lasty, we call the invoking objectsâ€™ dynamic typeâ€™s method with the same signature we write down previously. a.greet(d); // greet(Animal a) -&gt; â€œhello animalâ€ a.sniff(d); // sniff(Animal a) -&gt; â€œdog sniff animalâ€ d.praise(d); // praise(Dog a) -&gt; â€œu r cool dogâ€ a.praise(d); // praise(Animal a) -&gt; â€œu r cool animalâ€ The tricky part here is that praise(Animal a) in Animal interface and praise(Dog a) in Dog class are overloading, instead of the latter one overrides the other one. In such case, no DMS is happening. Note that in this example, the type of parameter is trivial, as d has the same static type and dynamic type Dog, and Dog is a â€œSubclassâ€ of Animal so it can be feed into a Animal type variable. Just for fun Bird and Falcon What gets printed after running the following code? public class Bird { public void gulgate(Bird b) { System.out.println(&quot;BiGulBi&quot;); } } public class Falcon extends Bird { public void gulgate(Falcon f) { System.out.println(&quot;FaGulFa&quot;); } } Bird bird = new Falcon(); Falcon falcon = (Falcon) bird; bird.gulgate(falcon); falcon.gulgate(falcon); Static type Dynamic type bird Bird Falcon falcon Falcon Falcon Note that casting wonâ€™t change an objectâ€™s type, all it do is making the compiler believe the type of whatever after the casting is as stated inside the brackets. Bird bird = new Falcon(); Falcon falcon = (Falcon) bird; bird.gulgate(falcon); // gulgate(Bird b) -&gt; &quot;BiGulBi&quot; falcon.gulgate(falcon); // gulgate(Falcon f) -&gt; &quot;FaGulFa&quot; No DMS happens in this example. Dog and ShowDog For each assignment, decide if it causes a compile error. For each call to bark, decide what is printed or Java throw a syntax error. public class Dog { public String name; public int height; public Dog(String name, int height) { name = name; height = height; } public static void bark() { System.out.println(&quot;Woof!&quot;); } } public class ShowDog extends Dog { @Override public static void bark() { System.out.println(&quot;Yo! What's up!&quot;); } } Static type Dynamic type o2 Object ShowDog sdx ShowDog ShowDog dx Dog ShowDog ((Dog) o2) Dog ShowDog o3 Object ShowDog Object o2 = new ShowDog(&quot;Mortimer&quot;, 25); ShowDog sdx = ((ShowDog) o2); sdx.bark(); // bark() -&gt; &quot;Yo! What's up!&quot; Dog dx = ((Dog) o2); dx.bark(); // bark() -&gt; &quot;Yo! What's up!&quot; ((Dog) o2).bark(); // bark() -&gt; &quot;Yo! What's up!&quot; Object o3 = (Dog) o2; o3.bark(); // compile error In fact, every time when bark() is invoked, the overriding method in the ShowDog class is used. By the way, o3.bark() wonâ€™t compile because the compiler think there is no bark() method for an Object (o3â€™s static type), despite both you and I know o3 is actually a ShowDog with a bark() method. That is how the compiler works. One way to debug this is to cast o3 to types that have bark() method. For example, we can write ((ShowDog) o3).bark(). Even more fun Raining cats and dogs Below, four classes are defined. What would Java do after executing the main method in the TestAnimal class? Next to each blank, if something is printed write it down. If there is an error, write whether it is a runtime error or compile time error, and then proceed through the rest of the code as if the erroneous line were not there. public class Animal { public String name, noise; public int age; public Animal(String name, int age) { this.name = name; this.age = age; this.noise = &quot;Huh?&quot;; } public void greet() {System.out.println(&quot;Animal &quot; + name + &quot; says: &quot; + this.noise);} public void play() {System.out.println(&quot;Woo it is so much fun being an animal!&quot;)} } public class Cat extends Animal { public Cat(String name, int age) { super(name, age); this.noise = &quot;Meow!&quot;; } @Override public void greet() {System.out.println(&quot;Cat &quot; + name + &quot; says: &quot; + this.noise);} public void play(String expr) {System.out.println(&quot;Woo it is so much fun being a cat!&quot; + expr)} } public class Dog extends Animal { public Dog(String name, int age) { super(name, age); noise = &quot;Woof!&quot;; } @Override public void greet() {System.out.println(&quot;Dog &quot; + name + &quot; says: &quot; + this.noise);} public void play(int happiness) { if (happiness &gt; 10) { System.out.println(&quot;Woo it is so much fun being a dog!&quot;) } } } public class TestAnimal { public static void main(String[] args) { Animal a = new Animal(&quot;Pluto&quot;, 10); Cat c = new Cat(&quot;Garfield&quot;, 6); Dog d = new Dog(&quot;Fido&quot;, 4); a.greet(); // ______________________ c.greet(); // ______________________ d.greet(); // ______________________ c.play(); // ______________________ c.play(&quot;:)&quot;) // ______________________ a = c; ((Cat) a).greet(); // ______________________ ((Cat) a).play(&quot;:D&quot;); // ______________________ a.play(14); // ______________________ ((Dog) a).play(12); // ______________________ a.greet(); // ______________________ c = a; // ______________________ } } After executing the first 3 lines in TestAnimal.main, variables has static types and dynamic types as below: Static type Dynamic type a Animal Animal c Cat Cat d Dog Dog After all execution, their types are (assuming the last line is fixed): Static type Dynamic type a Animal Cat c Cat Cat d Dog Dog a.greet(); // greet() -&gt; &quot;Animal Pluto says: Huh?&quot; c.greet(); // greet() -&gt; &quot;Cat Garfield says: Meow!&quot; d.greet(); // greet() -&gt; &quot;Dog Fido says: Woof!&quot; c.play(); // play() -&gt; &quot;Woo it is so much fun being an animal!&quot; c.play(&quot;:)&quot;) // play(String expr) -&gt; &quot;Woo it is so much fun being a cat!:)&quot; a = c; ((Cat) a).greet(); // greet() -&gt; &quot;Cat Garfield says: Meow!&quot; ((Cat) a).play(&quot;:D&quot;); // play(String expr) -&gt; &quot;Woo it is so much fun being a cat!:D&quot; a.play(14); // Compile Error ((Dog) a).play(12); // play(int happiness) -&gt; Runtime Error a.greet(); // greet() -&gt; &quot;Cat Garfield says: Meow!&quot; c = a; // Compile Error One possible fix for the last line c = a; is to perform a cast c = (Cat) a. This line triggers a compile error due to the fact that Animal is a â€œSuperclassâ€ of Cat, and assigning an object from the â€œSuperclassâ€ to its â€œSubclassâ€ wonâ€™t compile, even if we all know that a is actually a Cat, rather than other Animal that canâ€™t fit in a Cat variable. By casting, we tell the compiler just trust that a is a Cat, and everything goes fine. An exercise in inheritance misery Cross out any lines that result in compiler errors, as well as subsequent lines that would fail because of the compiler error. Put an X through runtime errors (if any). Donâ€™t just limit your search to main, there could be errors in classes A,B,C. What does D.main output after removing these lines? public class A { public int x = 5; public void m1() { System.out.println(&quot;Am1-&gt; &quot; + x); } public void m2() { System.out.println(&quot;Am2-&gt; &quot; + this.x); } public void update() { x = 99; } } public class B extends A { public void m2() { System.out.println(&quot;Bm2-&gt; &quot; + x); } public void m2(int y) { System.out.println(&quot;Bm2y-&gt; &quot; + y); } public void m3() { System.out.println(&quot;Bm3-&gt; &quot; + &quot;called&quot;); } } public class C extends B { public int y = x + 1; public void m2() { System.out.println(&quot;Cm2-&gt; &quot; + super.x); } public void m4() { System.out.println(&quot;Cm4-&gt; &quot; + super.super.x); } // super.super is not allowed in java public void m5() { System.out.println(&quot;Cm5-&gt; &quot; + y); } } public class D { public static void main (String[] args) { B a0 = new A(); a0.m1(); a0.m2(16); A b0 = new B(); System.out.println(b0.x); b0.m1(); b0.m2(); b0.m2(61); B b1 = new B(); b1.m2(61); b1.m3(); A c0 = new C(); c0.m2(); C c1 = (A) new C(); A a1 = (A) c0; C c2 = (C) a1; c2.m3(); c2.m4(); c2.m5(); ((C) c0).m3(); (C) c0.m2(); b0.update(); b0.m1(); } } Static type Dynamic type b0 A B b1 B B c0 A C a1 A C c2 C C ((C) c0) C C // B a0 = new A(); Compile Error, can't assign an A object to a B variable // a0.m1(); // a0.m2(16); A b0 = new B(); System.out.println(b0.x); // 5 b0.m1(); // m1() -&gt; &quot;Am1-&gt; 5&quot; b0.m2(); // m2() -&gt; &quot;Bm2-&gt; 5&quot; // b0.m2(61); Compile Error, m2(int y) is not defined in class A B b1 = new B(); b1.m2(61); // m2(int y) -&gt; &quot;Bm2y-&gt; 61&quot; b1.m3(); // m3() -&gt; &quot;Bm3-&gt; called&quot; A c0 = new C(); c0.m2(); // m2() -&gt; &quot;Cm2-&gt; 5&quot; // C c1 = (A) new C(); Compile Error, can't assign an A object to a C variable A a1 = (A) c0; C c2 = (C) a1; c2.m3(); // m3() -&gt; &quot;Bm3-&gt; called&quot; // c2.m4(); C.m4() is invalid c2.m5(); // m5() -&gt; &quot;Cm5-&gt; 6&quot; ((C) c0).m3(); // m3() -&gt; &quot;Bm3-&gt; called&quot; // (C) c0.m2(); Compile Error, can't cast a void to C class b0.update(); // update() -&gt; b0.m1(); // m1() -&gt; &quot;Am1-&gt; 99&quot; Ecstasy Athletes Suppose we have the Person, Athlete, and SoccerPlayer classes defined below. class Person { void speakTo(Person other) { System.out.println(&quot;kudos&quot;); } void watch(SoccerPlayer other) { System.out.println(&quot;wow&quot;); } } class Athlete extends Person { void speakTo(Athlete other) { System.out.println(&quot;take notes&quot;); } void watch(Athlete other) { System.out.println(&quot;game on&quot;); } } class SoccerPlayer extends Athlete { void speakTo(Athlete other) { System.out.println(&quot;respect&quot;); } void speakTo(Person other) { System.out.println(&quot;hmph&quot;); } } For each line below, write what, if anything, is printed after its execution. Write CE if there is a compiler error and RE if there is a runtime error. If a line errors, continue executing the rest of the lines. Person itai = new Person(); // SoccerPlayer shivani = new Person(); // Athlete sohum = new SoccerPlayer(); // Person jack = new Athlete(); // Athlete anjali = new Athlete(); // SoccerPlayer chirasree = new SoccerPlayer(); // itai.watch(chirasree); // jack.watch(sohum); // itai.speakTo(sohum); // jack.speakTo(anjali); // anjali.speakTo(chirasree); // sohum.speakTo(itai); // chirasree.speakTo((SoccerPlayer) sohum); // sohum.watch(itai); // sohum.watch((Athlete) itai); // ((Athlete) jack).speakTo(anjali); // ((SoccerPlayer) jack).speakTo(chirasree); // ((Person) chirasree).speakTo(itai); // Static type Dynamic type itai Person Person sohum Athlete SoccerPlayer jack Person Athlete anjali Athlete Athlete chirasree SoccerPlayer SoccerPlayer Person itai = new Person(); // SoccerPlayer shivani = new Person(); // CE Athlete sohum = new SoccerPlayer(); // Person jack = new Athlete(); // Athlete anjali = new Athlete(); // SoccerPlayer chirasree = new SoccerPlayer(); // itai.watch(chirasree); // watch(SoccerPlayer other) -&gt; &quot;wow&quot; jack.watch(sohum); // CE itai.speakTo(sohum); // speakTo(Person other) -&gt; &quot;kudos&quot; jack.speakTo(anjali); // speakTo(Person other) -&gt; &quot;kudos&quot; anjali.speakTo(chirasree); // speakTo(Athlete other) -&gt; &quot;take notes&quot; sohum.speakTo(itai); // speakTo(Person other) -&gt; &quot;hmph&quot; chirasree.speakTo((SoccerPlayer) sohum); // speakTo(Athlete other) -&gt; &quot;respect&quot; sohum.watch(itai); // CE sohum.watch((Athlete) itai); // RE ((Athlete) jack).speakTo(anjali); // speakTo(Athlete other) -&gt; &quot;take notes&quot; ((SoccerPlayer) jack).speakTo(chirasree); // RE ((Person) chirasree).speakTo(itai); // speakTo(Person other) -&gt; &quot;hmph&quot; Note that, when a method is invoked, the number of actual arguments and the compile-time types of the arguments are used, at compile time, to determine the signature of the method that will be invoked. Challenge: a puzzle Consider the partially filled classes for A and B as defined below: public class A { public static void main(String[] args) { ___ y = new ___(); ___ z = new ___(); } int fish(A other) { return 1; } int fish(B other) { return 2; } } class B extends A { @Override int fish(B other) { return 3; } } Note that the only missing pieces of the classes above are static/dynamic types! Fill in the four blanks with the appropriate static/dynamic type â€” A or B â€” such that the following are true: y.fish(z) equals z.fish(z) z.fish(y) equals y.fish(y) z.fish(z) does not equal y.fish(y) To approach this puzzle, we can firstly enumerate all possible combinations of types y and z, in terms of the value returned when calling the fish method. Static A Static B Static A Dynamic B 1 3 Static A Dynamic B 1 2 Static B Dynamic B 1 3 Where the head column referring to the invoking object types, and the head row referring to the parameter static type. Because static type B dynamic type A will cause a compile error, so there are only three rows. Further, as signature of method to be invoked considers parameterâ€™s static type rather than both static and dynamic type, there are only two columns. Given the three statements, z and y should have types shown as follow: Static Dynamic y A B z B B Therefore, the answer for this puzzle should be: public static void main(String[] args) { A y = new B(); B z = new B(); } ","link":"https://311zzb.github.io/post/subtype-polymorphism/"},{"title":"Personal Finance","content":"æ¦‚è¿° åœ¨è¿™ç¯‡æ–‡ç« ä¸­æˆ‘é˜è¿°äº†è‡ªå·±çš„è´¢åŠ¡ç®¡ç†ï¼ˆåŒ…æ‹¬è®°è´¦å’Œè´¢åŠ¡åˆ†æžï¼‰ç³»ç»Ÿã€‚æˆ‘ä¸æ˜¯ä¼šè®¡ä¸“ä¸šçš„ï¼Œä¹Ÿæ²¡ä»€ä¹ˆç»æµŽçŸ¥è¯†ï¼Œåªæ˜¯è¢«æƒ³è¦è´¢å¯Œè‡ªç”±çš„æ¬²æœ›é©±åŠ¨ç€éšä¾¿æžç€è¯•è¯•çš„ã€‚ä¸è¿‡æˆ‘æ„Ÿè§‰ç¡®å®žå¾—åœ¨è¿™æ–¹é¢å¤šå­¦ä¹ ï¼Œå°¤å…¶æ˜¯å†™ä¸å‡ºæ¥å’Œçœ‹ä¸æ‡‚åˆ«äººæ–‡ç« çš„æ—¶å€™ã€‚ ç‰ˆæœ¬è®°å½•ï¼š 2022.01.13 ç¬¬ä¸€ä¸ªç‰ˆæœ¬å‘å¸ƒï¼šåˆæ­¥å†™å®Œäº†è®°è´¦éƒ¨åˆ† ä»€ä¹ˆæ˜¯ä¸ªäººä¼šè®¡ ä¼šè®¡å­¦ï¼ˆAccountingï¼‰æ˜¯ä»¥ç ”ç©¶äººç±»çš„è´¢åŠ¡æ´»åŠ¨å’Œæˆæœ¬èµ„æ–™çš„æ”¶é›†ã€åˆ†ç±»ã€ç»¼åˆã€åˆ†æžå’Œè§£é‡Šçš„åŸºç¡€ä¸Šå½¢æˆååŠ©å†³ç­–çš„èµ„è®¯ç³»ç»Ÿï¼Œä»¥æœ‰æ•ˆåœ°ç®¡ç†ç»æµŽçš„ä¸€é—¨åº”ç”¨å­¦ç§‘ï¼Œå¯ä»¥è¯´å®ƒæ˜¯ç¤¾ä¼šå­¦ç§‘çš„ç»„æˆéƒ¨åˆ†ï¼Œä¹Ÿæ˜¯ä¸€é—¨é‡è¦çš„ç®¡ç†å­¦ç§‘ã€‚ å¾ˆæ˜Žæ˜¾ï¼Œä¸ªäººä¼šè®¡æŒ‡ä»£åœ¨ä¸ªäººçš„å±‚é¢ä¸Šè¿›è¡Œä¼šè®¡æ´»åŠ¨ã€‚è¿™ä¸ªè¯æœ‰æ—¶ä¼šæŒ‡ä»£ä»¥ä¸ªäººåä¹‰è¿›è¡Œæ´»åŠ¨çš„ä¼šè®¡å¸ˆï¼Œä½†åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æŠŠâ€œä¸ªäººä¼šè®¡â€å®šä¹‰ä¸ºå¯¹è‡ªå·±çš„è´¢åŠ¡æ´»åŠ¨çš„ç ”ç©¶ï¼Œä»¥åŠå¯¹æˆæœ¬èµ„æ–™çš„æ”¶é›†ã€åˆ†ç±»ã€ç»¼åˆã€åˆ†æžå’Œè§£é‡Šï¼Œå¹¶å½¢æˆååŠ©å†³ç­–çš„èµ„è®¯ç³»ç»Ÿï¼Œä»¥æœ‰æ•ˆåœ°ç®¡ç†ä¸ªäººè´¢åŠ¡ã€‚ ä»€ä¹ˆæ˜¯è´¢åŠ¡ è´¢åŠ¡ï¼ˆFinanceï¼‰æ˜¯æŒ‡å›½æ°‘ç»æµŽå„éƒ¨é—¨ã€å„å•ä½åœ¨ç‰©è´¨èµ„æ–™å†ç”Ÿäº§è¿‡ç¨‹ä¸­å®¢è§‚å­˜åœ¨çš„èµ„é‡‘è¿åŠ¨åŠèµ„é‡‘è¿åŠ¨è¿‡ç¨‹ä¸­æ‰€ä½“çŽ°çš„ç»æµŽå…³ç³»ã€‚ åœ¨ä¸ªäººå±‚é¢ï¼Œè´¢åŠ¡åˆ™æŒ‡ä»£ä¸Žå…¶ç›¸å…³çš„ç»æµŽæ´»åŠ¨ä¸­çš„èµ„é‡‘è¿åŠ¨ä¸ŽçŠ¶å†µã€‚åœ¨ä¼ä¸šä¸­ï¼Œå¯èƒ½ä¼šè®¡ã€è´¢åŠ¡åˆ†æžã€è´¢åŠ¡ç®¡ç†æ˜¯å¤šä¸ªå›¢é˜Ÿåˆ†åˆ«è´Ÿè´£ï¼Œä½†ç»å¤§å¤šæ•°ä¸ªäººçš„è´¢åŠ¡åªæœ‰å…¶æœ¬äººè´Ÿè´£ã€‚é€šè¿‡è´¢åŠ¡åˆ†æžï¼Œå¯ä»¥æ›´æœ‰æ•ˆåœ°è¿›è¡Œè´¢åŠ¡ç®¡ç†ã€‚ ä¸ºä»€ä¹ˆéœ€è¦ä¸ªäººä¼šè®¡å’Œè´¢åŠ¡åˆ†æž ä½œä¸ºä¸ªäººï¼Œæˆ‘ä»¬åº”è¯¥åˆ©ç”¨ä¼šè®¡å’Œè´¢åŠ¡çš„æ–¹æ³•è®ºæ¥è¿›è¡Œè‡ªæˆ‘ç®¡ç†ï¼Œè¿™ä¸éœ€è¦é›‡ä½£ä¸“é—¨çš„ä¼šè®¡ä¸Žè´¢åŠ¡åˆ†æžã€ç®¡ç†äººå‘˜ï¼Œè€Œä¸”ä¹Ÿæ˜¯æˆ‘ä»¬åœ¨è´¢å¯Œè‡ªç”±çš„è·¯ä¸Šå¿…éœ€çš„æŠ€èƒ½ã€‚ç»å¤§éƒ¨åˆ†å…¬å¸éƒ½æœ‰ä¸“é—¨çš„ä¼šè®¡ä¸Žè´¢åŠ¡ç®¡ç†ï¼Œæ˜¯å› ä¸ºå…¬å¸éœ€è¦å¯¹å®ƒä»¬çš„åˆ©ç›Šç›¸å…³è€…è´Ÿè´£ï¼›ä½†è¯´åˆ°ä¸ªäººï¼Œå°±è¿žè®¤çœŸè®°è´¦çš„äººä¹Ÿåªå å°‘æ•°ï¼ˆå°¤å…¶åœ¨å¹´è½»ç¾¤ä½“ä¸­ï¼‰ï¼Œè¿™æ˜¯å› ä¸ºå¤§å®¶å¹¶ä¸æƒ³é¢å¯¹æ›´å¤šåŽ‹åŠ›â€”â€”å¦‚æžœç”Ÿæ´»è´¨é‡æ²¡æœ‰è¢«æ˜Žæ˜¾å½±å“ï¼Œä½ ä¼šç ”ç©¶è‡ªå·±è¿™ä¸ªæœˆæ˜¯ä¸æ˜¯åˆå¤šèŠ±é’±äº†å—ï¼Ÿ ä½†ä¹Ÿæœ‰ä¸å°‘äººåœ¨æ„Ÿåˆ°ç»æµŽåŽ‹åŠ›çš„æ—¶å€™å¼€å§‹è®°è´¦äº†ï¼Œä½†å¾ˆå¯æƒœï¼Œä¸€æ˜¯ä»–ä»¬ä¸­çš„ä¸å°‘äººæ—©å·²è¿›å…¥äº†æ”¯å‡ºçº¦ç­‰äºŽæ”¶å…¥çš„â€œè€é¼ èµ›è·‘â€å¾ªçŽ¯ï¼ŒäºŒæ˜¯å¾ˆå¤šäººæ°¸è¿œåœç•™åœ¨â€œæµé‡è®°è´¦â€ï¼ˆä¹Ÿå°±æ˜¯æµæ°´è´¦ï¼‰ï¼Œè¿™è®©ä»–ä»¬çš„è®°è´¦å˜æˆäº†ä»…ä»…æ˜¯å®‰æ…°è‡ªå·±çš„åŠ³åŠ¨ï¼Œå…¶æ•°æ®éš¾ä»¥è¿›è¡Œåˆ†æžå’Œè§£é‡Šï¼Œæ›´ä¸ç”¨è¯´åœ¨è®°è´¦çš„åŸºç¡€ä¸Šå½¢æˆèµ„è®¯ç³»ç»Ÿä»Žè€Œæ”¹å–„è´¢åŠ¡çŠ¶å†µäº†ã€‚ è´¢åŠ¡è‡ªç”± è´¢åŠ¡è‡ªç”±æ˜¯æŒ‡ä½ å·¥ä½œå¹¶ä¸ä¸ºäº†é’±ï¼Œè€Œé’±å®Œå…¨å¤Ÿç”¨çš„çŠ¶æ€ã€‚åªè¦ä½ çš„èµ„äº§äº§ç”Ÿçš„è¢«åŠ¨æ”¶å…¥ç­‰äºŽæˆ–è¶…è¿‡ä½ çš„æ—¥å¸¸å¼€æ”¯ã€‚å¦‚æžœè¿›å…¥è¿™ç§çŠ¶æ€ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç§°ä¹‹ä¸ºé€€ä¼‘æˆ–å…¶ä»–å„ç§åç§°ã€‚åªè¦ä¸å‘ç”Ÿä»€ä¹ˆé‡å¤§çš„ç¾éš¾ï¼Œä½ å°±å¯ä»¥ç”Ÿæ´»ä¸‹åŽ»ï¼Œå½“ç„¶å¦‚æžœä½ å–œæ¬¢ä½ çš„å·¥ä½œä¹Ÿå¯ä»¥ç»§ç»­å¹²ä¸‹åŽ»ï¼Œæˆ–è€…ä½ å¯ä»¥é€‰æ‹©ä½ è‡ªå·±çœŸæ­£å–œæ¬¢åšçš„äº‹ï¼Œè€Œä¸æ˜¯ä¸ºç”Ÿæ´»æ‰€è¿«åœ°åšé‚£äº›ä½ ä¸ä¹æ„å´åˆæ— å¯å¥ˆä½•è¦åšçš„äº‹ã€‚ ä¸‹é¢å„é¡¹æ˜¯å®žçŽ°è´¢åŠ¡è‡ªç”±çš„æ ‡å‡†åŽŸåˆ™ï¼š åˆ›é€ èµ„äº§ å‡å°‘è´Ÿå€º ç®¡ç†æ—¥å¸¸å¼€æ”¯ è´¢åŠ¡è‡ªç”±è·Ÿä½ æ˜¯å¦å¹´è½»æˆ–æœ‰å¤šå°‘é’±æ— å…³ã€‚å¦‚æžœä½ èƒ½ä»Žæœ¬èŒå·¥ä½œä»¥å¤–çš„é€”å¾„èµšåˆ°è¶³å¤Ÿä½ æ—¥å¸¸å¼€é”€çš„é’±ï¼Œä½ å°±å·²ç»è´¢åŠ¡è‡ªç”±äº†ã€‚å¹´é¾„å¯èƒ½è·Ÿè´¢åŠ¡è‡ªç”±æ— å…³ï¼Œå‡è®¾ä½ çŽ°å¹´25å²ï¼Œæ¯æœˆå¼€æ”¯1000å—é’±ï¼Œä½ çš„èµ„äº§æ¯æœˆäº§ç”Ÿ1001å—é’±çš„è¢«åŠ¨æ”¶å…¥ï¼Œä½ å°±è´¢åŠ¡è‡ªç”±äº†ï¼Œä½ å¯ä»¥é€‰æ‹©ä½ æƒ³åšçš„äº‹æƒ…ï¼Œè€Œä¸å¿…æ‹…å¿ƒä¸‹ä¸€é¡¿åƒä»€ä¹ˆæˆ–è€…ä½å“ªé‡Œã€‚å‡è®¾ä½ çŽ°å¹´50å²ï¼Œæœˆå…¥ç™¾ä¸‡ï¼Œä½†æ¯æœˆå¼€é”€è¶…è¿‡ç™¾ä¸‡ï¼Œé‚£ä½ ä»ç„¶æ²¡èƒ½è¾¾åˆ°è´¢åŠ¡è‡ªç”±ï¼Œä½ ä»ç„¶ä¸å¾—ä¸ç»§ç»­æœˆå…¥ç™¾ä¸‡åœ°è¿™ä¹ˆç»´æŒä¸‹åŽ»ã€‚ ä¼ä¸šçš„ç›®çš„æ˜¯ä¸ºä¼ä¸šçš„æŽ§åˆ¶äººç‰Ÿå–åˆ©æ¶¦ï¼Œä½†æ¯ä¸ªäººæ´»åœ¨ä¸–ç•Œä¸Šçš„ç›®çš„éƒ½ä¸åŒã€‚ä½†æ˜Žæ˜¾çš„æ˜¯ï¼Œä¸å°‘ç›®çš„éƒ½æ˜¯éœ€è¦é’±ã€éœ€è¦æ—¶é—´æ‰æœ‰å¯èƒ½å®žçŽ°çš„ï¼Œå¦‚æžœä¸ºäº†èŽ·å¾—è¶³å¤Ÿçš„é‡‘é’±è€ŒåŽ»æŠ•å…¥ä¸€ç”Ÿçš„æ—¶é—´ï¼Œæ˜¯å¦ä¸Žä½ çš„ç»ˆæžç›®çš„ç›¸æ‚–å‘¢ï¼Ÿæˆ‘è§‰å¾—è´¢åŠ¡è‡ªç”±åº”è¯¥æ˜¯æ¯ä¸ªäººéƒ½å¯ä»¥è¿½æ±‚çš„ï¼Œä¸ªäººç»ˆæžç›®æ ‡ä¸­çš„ç¬¬ä¸€é¡¹â€”â€”å°†è‡ªå·±ä»Žé‡‘é’±ä¸Žæ—¶é—´çš„æ‚²æƒ¨äº¤æ˜“ä¸­è§£æ”¾å‡ºæ¥ï¼ŒæŠŠé‡‘é’±å’Œæ—¶é—´ä¸€èµ·æŠ•å…¥æ›´é‡è¦çš„äº‹æƒ…ä¸­åŽ»ã€‚ ä¸¾ä¸€ä¸ªç†æƒ³çš„ä¾‹å­ã€‚æƒ³è±¡ä¸€ä¸ªç‚¹å‡»æ¸¸æˆï¼šçŽ©å®¶æ¯ç‚¹å‡»ä¸€æ¬¡å±å¹•å°±å¯ä»¥èŽ·å¾—1é‡‘å¸ï¼Œé‡‘å¸åˆå¯ä»¥ç”¨æ¥åˆ¶é€ å’Œå‡çº§åˆ¶é€ é‡‘å¸çš„æœºå™¨ã€‚åœ¨ä¸€å¼€å§‹ï¼Œä½ ä¸€åˆ†é’Ÿå°±å¯ä»¥ç‚¹å‡ºæœºå™¨ä¸€ä¸ªæœˆæ‰èƒ½åˆ¶é€ çš„æ•°é‡ï¼Œä½†éšç€å‡çº§æœºå™¨çš„æ¬¡æ•°è¶Šæ¥è¶Šå¤šï¼Œä½ è‡ªå·±ç‚¹å±å¹•èµšçš„é‚£ç‚¹å„¿é‡‘å¸åœ¨æœºå™¨é¢å‰ä¸è¶³ä¸€æçš„é‚£å¤©ä¸€å®šä¼šåˆ°æ¥ã€‚ è¯è¯´å›žæ¥ã€‚ä¸ªäººä¼šè®¡å¯ä»¥å¸®æˆ‘ä»¬äº†è§£æ—¥å¸¸å¼€æ”¯ã€èµ„äº§å’Œè´Ÿå€ºçš„æƒ…å†µï¼Œè´¢åŠ¡åˆ†æžå¯ä»¥å¸®åŠ©æˆ‘ä»¬å¯»æ‰¾å’Œç†è§£å¦‚ä½•æ›´å¥½åœ°ç§‘å­¦ç®¡ç†æ—¥å¸¸å¼€æ”¯ã€åˆ›é€ èµ„äº§ã€å‡å°‘è´Ÿå€ºã€‚é€€ä¸€æ­¥è¯´ï¼Œæˆ‘ä»¬è‡³å°‘å¾—åœ¨è¢«åŠ¨æ”¶å…¥è¶…è¿‡å¼€æ”¯çš„æ—¶å€™çŸ¥é“å·²ç»è´¢å¯Œè‡ªç”±äº†ã€‚æˆ‘æƒ³è¿™å°±æ˜¯è¿›è¡Œä¸ªäººä¼šè®¡å’Œè´¢åŠ¡åˆ†æžçš„ç†ç”±ã€‚ ä¸ªäººä¼šè®¡ä¸Žåˆ†æžæµç¨‹ åœ¨å®žé™…æ“ä½œä¸­ï¼Œæˆ‘ä»¬åˆ©ç”¨ç§»åŠ¨ç«¯appï¼ˆæœ¬æ–‡ä½¿ç”¨My Budget Bookï¼‰è¿›è¡Œä¼šè®¡æ•°æ®çš„æ”¶é›†ä¸Žåˆæ­¥åˆ†ç±»æ•´ç†ï¼Œåœ¨å•ä½æ—¶é—´å‘¨æœŸï¼ˆæ¯”å¦‚ä¸€å­£åº¦æˆ–æ˜¯ä¸€å¹´ï¼‰çš„æœ«å°¾ç”¨Excelåˆ¶ä½œè´¢æŠ¥ã€è¿›è¡Œåˆ†æžã€å½¢æˆèµ„è®¯ï¼Œä¼˜åŒ–ä¸‹ä¸€ä¸ªå‘¨æœŸçš„è´¢åŠ¡è¡Œä¸ºå’Œä¼šè®¡ç³»ç»Ÿã€‚ æŒ‡æ ‡ ä¸ºäº†é¿å…èŠ±è´¹æ—¶é—´è®°å½•æ— æ³•ä¸ºå†³ç­–æä¾›å‚è€ƒçš„â€œæµæ°´è´¦â€ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ä¼šè®¡å‘¨æœŸå¼€å§‹å‰ç¡®å®šéœ€è¦ä»Žä¸‹ä¸€ä¸ªå‘¨æœŸèŽ·å–å“ªäº›æŒ‡æ ‡ï¼Œä»Žè€ŒæŒ‡å¯¼è´¢æŠ¥çš„é¡¹ç›®è®¾ç½®ï¼Œè¿›è€ŒæŒ‡å¯¼æ—¥å¸¸è®°è´¦çš„è´¦æˆ·ã€åˆ†ç»„ç­‰ç­‰å…·ä½“è®¾ç½®ã€‚æƒ³èŽ·å–å“ªäº›æŒ‡æ ‡ä¾æ®çš„æ˜¯æƒ³çŸ¥é“å“ªäº›ä¿¡æ¯ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œæˆ‘çŽ°åœ¨æ¯”è¾ƒæƒ³çŸ¥é“æˆ‘çš„ï¼š æ€»æ”¶å…¥å’Œæ”¯å‡ºã€å‡€æ”¶å…¥ æ€»èµ„äº§å’Œè´Ÿå€ºã€å‡€èµ„äº§ èµšé’±é€Ÿåº¦ã€èµšé’±åŠ é€Ÿåº¦ èŠ±é’±é€Ÿåº¦ã€èŠ±é’±åŠ é€Ÿåº¦ å‡€èµ„äº§æ”¶ç›ŠçŽ‡ èººç€èµšé’±ç¨‹åº¦ çŽ°åœ¨åœæ­¢ä¸€åˆ‡å·¥ä½œçš„è¯èƒ½ç»´æŒçŽ°æœ‰ç”Ÿæ´»å¤šä¹… é¢„è®¡å¤šä¹…ä¹‹åŽå¯ä»¥è´¢å¯Œè‡ªç”± æ€»ä½“é£Žé™© çŸ­æœŸèµ„é‡‘åŽ‹åŠ› æ”¶å…¥çš„æµå‘ (energy flow chart) å„ä¸ªæ–¹é¢æ”¯å‡ºçš„æ¯”çŽ‡ å¿…éœ€ã€å¯é€‰ã€éžå¿…éœ€æ”¯å‡ºçš„æ¯”çŽ‡ ... å®ƒä»¬åˆ†åˆ«å¯¹åº”äº†ï¼š æ€»æ”¶å…¥å’Œæ”¯å‡ºã€æ€»æ”¶å…¥ - æ”¯å‡º æ€»èµ„äº§å’Œè´Ÿå€ºã€æ€»èµ„äº§ - è´Ÿå€º å‡€æ”¶å…¥ / å‡€èµ„äº§ã€å‡€æ”¶å…¥çŽ¯æ¯”å˜åŒ–çŽ‡ æ”¯å‡º / å‡€èµ„äº§ã€æ”¯å‡ºçŽ¯æ¯”å˜åŒ–çŽ‡ è¢«åŠ¨æ”¶å…¥ / å‡€èµ„äº§ è¢«åŠ¨æ”¶å…¥ / ä¸»åŠ¨æ”¶å…¥ å‡€èµ„äº§ / max (æ”¯å‡º - è¢«åŠ¨æ”¶å…¥, 0) log (æ”¯å‡º / å‡€èµ„äº§*å‡€èµ„äº§æ”¶ç›ŠçŽ‡) / log ((1+ èµšé’±é€Ÿåº¦) / (1 + èŠ±é’±åŠ é€Ÿåº¦)) è´Ÿå€º / æ€»èµ„äº§ æ”¯å‡º / é«˜æµåŠ¨æ€§èµ„äº§ æ”¯å‡º / æ”¶å…¥ã€å‚¨è“„ / æ”¶å…¥ã€æŠ•èµ„ / æ”¶å…¥ æ”¯å‡ºä¸€çº§åˆ†ç±» / æ”¯å‡º æ”¯å‡ºäºŒçº§åˆ†ç±» / æ”¯å‡º ... ä¼šè®¡ åœ¨è¿™ä¸€å°èŠ‚ä¸­ï¼Œæˆ‘ä»¬è®¨è®ºåœ¨ç”Ÿæ´»ä¸­å¦‚ä½•å…·ä½“åœ°å¯¹è‡ªå·±çš„è´¢åŠ¡æ´»åŠ¨è¿›è¡Œä¼šè®¡ã€‚ç”±äºŽäººä¸Žäººä¹‹é—´çš„æƒ…å†µå¤§ç›¸å¾„åº­ï¼Œæ‰€ä»¥æ”¶å…¥ã€æ”¯å‡ºæ¨¡å¼çš„çŽ°é‡‘æµåˆ†ç±»è§ä»è§æ™ºã€‚åœ¨ä»‹ç»æˆ‘çš„åˆ†ç±»ä¹‹å‰ï¼Œæˆ‘ä»¬æœ‰å¿…è¦ç†è§£èµ„äº§ä¸Žè´Ÿå€ºçš„ä¸»è¦ç±»åˆ«ã€‚ èµ„äº§ èµ„äº§æ˜¯é’±æˆ–æ˜¯èƒ½ä¸æ–­æŠŠé’±æ”¾è¿›ä½ å£è¢‹é‡Œçš„ä¸œè¥¿ã€‚è™½ç„¶è¿™ä¸Žä¸¥è°¨çš„å®šä¹‰ä¸å°½ç›¸åŒï¼Œä½†æ—¢ç„¶æ˜¯ä»¥è´¢å¯Œè‡ªç”±ä¸ºç›®æ ‡çš„è®°è´¦ï¼Œé‚£ä¹ˆè´­ä¹°æ›´å¤šçš„èµ„äº§ä»Žè€Œç´¯ç§¯è¢«åŠ¨æ”¶å…¥å°±å˜å¾—æžå…¶é‡è¦ï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘ä»¬æŠŠèµ„äº§ä»…å®šä¹‰ä¸ºèƒ½æœ‰æ•ˆåœ°å˜çŽ°æˆ–æ˜¯èƒ½ç›ˆåˆ©çš„ä¸œè¥¿ã€‚ è´§å¸èµ„äº§ è´§å¸èµ„äº§æŒ‡éšæ—¶å¯ä»¥ç”¨äºŽæ”¯å‡ºæˆ–ç­‰å¾…æ”¯å‡ºçš„çŽ°é‡‘åŠå…¶ç­‰ä»·ç‰©ï¼Œæ˜¯æµåŠ¨æ€§æœ€å¼ºçš„èµ„äº§ã€‚è´§å¸ã€æ´»æœŸå‚¨è“„ã€è´§å¸åŸºé‡‘éƒ½å±žäºŽè¿™ç§èµ„äº§ã€‚è´§å¸èµ„äº§å¯ä»¥éšæ—¶è°ƒç”¨ï¼Œä»£è¡¨äº†çŸ­æœŸçš„æ”¯ä»˜èƒ½åŠ›ï¼Œæ—¥å¸¸çš„æ”¯å‡ºä¹Ÿæ˜¯ä»Žè´§å¸èµ„äº§ä¸­æµå‡ºçš„ï¼Œæ‰€ä»¥é€‚åˆä½œä¸ºè®°è´¦çš„ä¸»è´¦æˆ·ã€‚ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå‚¨å€¼å¡ã€é¥­å¡ã€å…¬äº¤å¡å’Œæ¸¸æˆç‚¹å¡ç­‰è´¦æˆ·ï¼Œç”±äºŽéš¾ä»¥å˜çŽ°ï¼Œæ‰€ä»¥ä¸åº”è¯¥ç®—ä½œä»»ä½•èµ„äº§ã€‚åº”è¯¥åœ¨å……å€¼æ—¶ä¸€æ¬¡æ€§è®°ä¸ºæ”¯å‡ºã€‚å¦å¤–ï¼Œä½¿ç”¨æ”¯ä»˜æ—¥å¸¸å¼€é”€çš„ä¿¡ç”¨å¡è¿›è¡Œæ”¯ä»˜çš„æ—¶å€™ä¹Ÿåº”è¯¥è®°åœ¨è´§å¸èµ„äº§çš„è´¦æˆ·ä¸­ï¼ˆæ‹–åˆ°æœ€åŽä¸€å¤©å…¨æ¬¾è¿˜ä¿¡ç”¨å¡ï¼Œèµšè¿˜æ¬¾çš„æ—¶é—´æˆæœ¬ï¼‰ï¼Œæ­¤æ—¶ä½ çš„è´¦æœ¬ä¼šæ¯”é“¶è¡Œappæˆ–æ˜¯æ”¯ä»˜å®æ˜¾ç¤ºçš„ä½™é¢æ›´åŠ å¯ä¿¡ï¼šå®ƒè¡¨ç¤ºä½ çš„å‡€è´§å¸èµ„äº§ã€‚è¿˜ä¿¡ç”¨å¡æ—¶æ— éœ€å†æ¬¡è®°å½•ã€‚ æˆ‘ä»¬å°†ä¸åŒå¹³å°ä¸Šçš„åŒè´¨èµ„äº§è®°åœ¨ä¸€èµ·ï¼Œè¿™åœ¨ç®€åŒ–è®°è´¦çš„å¤æ‚åº¦ï¼ˆä¸éœ€è¦æ¯ç¬”äº¤æ˜“éƒ½æ ‡è®°æ˜¯ä»Žä»€ä¹ˆå¡åˆ’èµ°çš„äº†ï¼‰çš„åŒæ—¶ï¼Œä¿è¯äº†åŽæœŸçš„è´¢åŠ¡åˆ†æžä¸å—å½±å“ã€‚ é‡‘èžèµ„äº§ é‡‘èžèµ„äº§æŒ‡ç”¨äºŽæˆ–å‡†å¤‡ç”¨äºŽèŽ·å–è¢«åŠ¨æ”¶å…¥çš„èµ„äº§ï¼Œæ˜¯è¾¾åˆ°è´¢åŠ¡è‡ªç”±çš„å…³é”®ã€‚è™½ç„¶æœ‰äº›é‡‘èžèµ„äº§çš„æµåŠ¨æ€§ç”šè‡³æ¯”è´§å¸èµ„äº§è¿˜å¥½ï¼ˆç”šè‡³å°±æ˜¯è´§å¸ï¼Œå¦‚åŠ å¯†è´§å¸ï¼‰ï¼Œä½†åªè¦ç›®çš„æ˜¯èŽ·å–è¢«åŠ¨æ”¶å…¥ï¼Œå°±åº”å½“åˆ’åˆ†ä¸ºé‡‘èžèµ„äº§ã€‚åè¿‡æ¥è¯´ï¼Œæœ‰çš„èµ„äº§å¯èƒ½ä¸Žé‡‘èžæ²¡ä»€ä¹ˆå…³ç³»ï¼Œä½†åªè¦å¯ä»¥å¸®ä½ èŽ·å–è¢«åŠ¨æ”¶å…¥ï¼Œå°±åº”è¯¥è§†ä¸ºé‡‘èžèµ„äº§ï¼ˆæ¯”å¦‚ç”¨äºŽå‡ºç§Ÿæˆ–æ˜¯ç­‰å¾…å‡å€¼çš„æˆ¿åœ°äº§ï¼‰ã€‚é‡‘èžèµ„äº§çš„æ€»å’Œä»£è¡¨äº†ä½ æœ‰å¤šå°‘èµ„äº§åœ¨å¸®ä½ èµšé’±ã€‚ æƒç›Šèµ„äº§ æƒç›Šèµ„äº§åœ¨ä¸ªäººå±‚é¢å¯ä»¥æŒ‡åˆ«äººæ¬ çš„é’±ã€å…»è€é‡‘è´¦æˆ·é‡Œçš„é’±ã€ä¿é™©é‡Œçš„é’±ã€ä½ å¦ˆå¸®ä½ å­˜ç€çš„åŽ‹å²é’±ç­‰ç­‰ã€‚è¿™äº›èµ„äº§æ— æ³•ç”¨äºŽæ”¯å‡ºã€æ”¶å›žçš„å¯èƒ½æ€§ä¸ä¸€ï¼Œä¹Ÿä¸ä¸€å®šäº§ç”ŸçŽ°é‡‘è¢«åŠ¨æ”¶å…¥ï¼Œå¾ˆå¤šæ—¶å€™ä¸ç®—åšèµ„äº§ã€‚ å›ºå®šèµ„äº§ åœ¨ä½ ç ´äº§æ—¶å¯ä»¥è¢«æ‹å–çš„èµ„äº§ï¼ŒåŒ…æ‹¬è½¦ã€æˆ¿ã€è´µé‡ç‰©å“ç­‰ç­‰ã€‚è¿™ç±»ç‰©å“ä¸€èˆ¬éš¾ä»¥å‡†ç¡®ä¼°å€¼è€Œä¸”ä¸ä¼šä¸»åŠ¨å–å‡ºï¼Œæ‰€ä»¥å…¶å®žå¹¶ä¸é€‚åˆç®—ä½œèµ„äº§ã€‚ è´Ÿå€º è´Ÿå€ºæŒ‡çš„æ˜¯èƒ½ä¸æ–­åœ°ä»Žä½ å£è¢‹é‡Œæ‹¿èµ°é’±çš„ä¸œè¥¿ã€‚ ç”Ÿæ´»å¼€é”€å¦‚æžœä½¿ç”¨ä¿¡ç”¨å¡æˆ–æ˜¯ç”µå­ä¿¡ç”¨å¡ï¼Œå‡ºäºŽç®€åŒ–è®°è´¦çš„è€ƒè™‘ï¼Œè‹¥å…æ¯æˆ–æ˜¯èƒ½åœ¨è®¡æ¯æ—¥å¼€å§‹ä¹‹å‰è¿˜æ¸…ä¾¿ä¸ç®—ä½œæ˜¯è´Ÿå€ºï¼ˆæ¶ˆè´¹æ—¶ç›´æŽ¥ä»Žè´§å¸èµ„äº§ä¸­æ‰£é™¤ï¼‰ã€‚åä¹‹ï¼Œå¦‚æžœè´Ÿå€ºä¼šäº§ç”Ÿåˆ©æ¯ï¼Œåˆ™éœ€è¦è®°å½•ä¸ºè´Ÿå€ºï¼Œæ­¤æ—¶åº”å½“å°½å¿«è¿˜æ¸…ï¼Œå‡å°‘åˆ©æ¯çš„äº§ç”Ÿï¼ˆå¦‚æžœå¯ä»¥å‡å°‘çš„è¯ï¼‰ã€‚å¦‚æžœæ˜¯è¯¸å¦‚æˆ¿è´·æˆ–è½¦è´·ä¹‹ç±»çš„é•¿æœŸè´Ÿå€ºï¼Œä¹Ÿåº”è¯¥è®°å½•ã€‚ä½†è¯´åˆ°åº•ï¼Œåœ¨è´Ÿå€ºå¼€å§‹å‰å°±åº”è¯¥éƒ‘é‡è€ƒè™‘ï¼Œå¹¶ä¸”åˆç†å®‰æŽ’å€Ÿæ¬¾é‡å’Œè¿˜æ¬¾çš„å‘¨æœŸï¼Œé˜²æ­¢è´Ÿå€ºä¾µèš€èµ„äº§ï¼Œæ‹–æ…¢è´¢å¯Œè‡ªç”±çš„è¿›åº¦ã€‚ è®°è´¦ è®°è´¦æ–¹å¼ä¹‹é—´çš„åŒºåˆ« ä½¿ç”¨ä¸åŒçš„æ–¹å¼åŽ»è®°è´¦å¯ä»¥åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šå½±å“æ˜¯å¦èƒ½è¿›è¡Œè´¢åŠ¡åˆ†æžä»¥åŠè´¢åŠ¡åˆ†æžå¸®åŠ©å†³ç­–çš„èƒ½åŠ›ã€‚æœ€æœ´ç´ çš„è®°è´¦æ–¹æ³•æ˜¯æµæ°´è´¦ï¼Œæˆ–è€…è¯´æµé‡è®°è´¦ï¼ˆæ”¶ä»˜å®žçŽ°åˆ¶ï¼‰ã€‚è¿™ç§æ–¹æ³•æ˜¯åœ¨é’±åˆ°æ‰‹å’Œå‡ºæ‰‹çš„æ—¶å€™è®°å½•é‡‘é¢ä¸Žæ–¹å‘ï¼Œç»†è‡´ä¸€ç‚¹çš„ä¼šæ ¹æ®ç›®çš„/æ¥æºè¿›è¡Œåˆ†ç±»ï¼Œä½†è‡³äºŽæµå…¥å’Œæµå‡ºé‡‘é¢çš„æ€§è´¨å¹¶ä¸åšåŒºåˆ†ã€‚è¿™ç§æ–¹æ³•çš„ä¼˜ç‚¹æ˜¯æ˜“äºŽç†è§£å’Œæ‰§è¡Œï¼ŒåŒæ—¶å¯ä»¥ç”¨äºŽç›‘æŽ§æœ€ä¸»è¦çš„è´¢åŠ¡æ•°æ®ï¼šçŽ°é‡‘æµã€‚ ç„¶è€Œï¼Œæœ‰ä¸€ç§æ›´å¥½çš„è®°è´¦æ–¹æ³•åˆ™å«æƒç›Šè®°è´¦ï¼ˆæƒè´£å‘ç”Ÿåˆ¶ï¼‰ï¼Œç›¸æ¯”äºŽæµé‡è®°è´¦ï¼Œæ›´æ³¨é‡äºŽèµ„é‡‘çš„æ¶ˆäº¡å’Œè½¬ç§»ä¸­çš„é€»è¾‘ï¼Œä»¥åŠæƒåŠ›è´£ä»»å‘¨æœŸåŒ¹é…ã€‚è¿™æ˜¯ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿä¸¾ä¸ªä¾‹å­ï¼Œåœ¨ä½¿ç”¨ä¿¡ç”¨å¡è¿›è¡Œå¤šæ¬¡æ—¥å¸¸æ¶ˆè´¹ä¹‹åŽï¼Œåœ¨è¿˜æ¬¾æ—¥ä¹‹å‰ä¸€æ¬¡æ€§è¿˜æ¬¾ã€‚è¿™ä¸€ç³»åˆ—è¡Œä¸ºä½¿ç”¨æ”¶ä»˜å®žçŽ°åˆ¶è®°å½•çš„è¯ï¼Œåªéœ€è¦åœ¨è¿˜æ¬¾çš„æ—¶å€™è®°å½•ä¸€æ¬¡å³å¯ï¼Œå› ä¸ºè¿˜æ¬¾ä¹‹åŽæ¬¾é¡¹æ‰å®žé™…åœ°è¿›è¡Œäº†è½¬ç§»ï¼›è€Œæƒè´£å‘ç”Ÿåˆ¶åˆ™éœ€è¦æ¯ä¸€æ¬¡å®žé™…æ¶ˆè´¹æ—¶éƒ½è¿›è¡Œè®°å½•ï¼Œå› ä¸ºåœ¨æ¶ˆè´¹æ—¶ï¼ˆä»˜æ¬¾çš„ï¼‰è´£ä»»å°±å·²ç»äº§ç”Ÿï¼Œå®žé™…çš„æ¬¾é¡¹æˆä¸ºäº†åº”ä»˜è´¦æ¬¾ï¼Œå®žé™…çš„è¿˜æ¬¾è¡Œä¸ºæ²¡æœ‰å¢žåŠ æ–°çš„æƒç›Šæˆ–è€…è´£ä»»æ‰€ä»¥ä¸è¿›è¡Œè®°å½•ã€‚ ç”±äºŽæˆ‘ä»¬çš„æ¶ˆè´¹ä¸æ˜¯ä¸€æ¬¡è€Œæ˜¯å¤šæ¬¡è¿›è¡Œï¼Œæ¯æ¬¡åˆ†å¼€è®°å½•æœ‰åŠ©äºŽååº”çœŸå®žçš„æ¶ˆè´¹æ¨¡å¼ï¼Œæ˜Žæ˜¾æ”¶ä»˜å®žçŽ°åˆ¶ä¸èƒ½å®Œå…¨åšåˆ°è¿™ä¸€ç‚¹ï¼Œå› æ­¤æƒè´£å‘ç”Ÿåˆ¶æ˜¯çŽ°ä»£ä¼šè®¡å‡†åˆ™çš„è¦æ±‚ã€‚ä¸ªäººè®°è´¦é€šå¸¸ä¸èƒ½å®Œå…¨ç†è§£ä¸¤ç§æ–¹å¼çš„å¼‚åŒï¼Œå¯¼è‡´ä¸ç»æ„é—´çš„æ··ç”¨ï¼Œè€Œæ··ç”¨ä¸åŒé€»è¾‘çš„è®°è´¦æ–¹æ³•å¾ˆå®¹æ˜“è¿›ä¸€æ­¥å¯¼è‡´é€»è¾‘çŸ›ç›¾ï¼Œå¸å°±è®°ä¸æ¸…æ¥šäº†ã€‚æˆ‘ä»¬ä½¿åªç”¨æƒè´£å‘ç”Ÿåˆ¶çš„æƒç›Šè®°è´¦ã€‚ æ”¶å…¥çš„åˆ†ç±» æ”¶å…¥å¯ä»¥åˆ†ä¸ºä¸»åŠ¨æ”¶å…¥ã€è¢«åŠ¨æ”¶å…¥ã€ä»¥åŠæ„å¤–æ”¶å…¥ã€‚ç”±äºŽæ”¶å…¥äº§ç”Ÿçš„é¢‘çŽ‡å¯èƒ½å¹¶ä¸åƒæ”¯å‡ºé‚£ä¹ˆé¢‘ç¹ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸åœ¨ç§»åŠ¨ç«¯çš„è®°è´¦appå†…è®°å½•æ”¶å…¥ï¼Œè€Œæ˜¯æ¯æ¬¡äº§ç”Ÿæ”¶å…¥æ—¶ç”¨Excelè®°å½•ã€‚æˆ‘ä»¬åœ¨è®°è´¦appå†…åªè®¾ç«‹ä¸€ä¸ªæ—¥å¸¸å¼€é”€è´¦æˆ·åŠçŸ­æœŸåº”æ€¥è´¦æˆ·ï¼Œåˆ†åˆ«åœ¨æ¯ä¸ªå‘¨æœŸå¼€å§‹æ—¶æˆ–æ˜¯å¾—åˆ°æ”¶å…¥æ—¶åˆ†åˆ«è¡¥å……/å‰Šå‡è‡³ä¸€ä¸ªå‘¨æœŸçš„å¹³å‡å¼€é”€å’Œä¸‰è‡³å…­ä¸ªå‘¨æœŸçš„å¹³å‡å¼€é”€ï¼Œåœ¨å‘¨æœŸç»“æŸæ—¶æŠŠå‰©æ—¥å¸¸å¼€é”€è´¦æˆ·ä¸­å‰©ä½™çš„èµ„é‡‘åˆ’è½¬åˆ°çŸ­æœŸåº”æ€¥è´¦æˆ·ã€‚è¿™ä¸¤ç§èµ„äº§éƒ½æ˜¯ä¸ç”¨äºŽæŠ•èµ„çš„è´§å¸èµ„äº§ã€‚ éœ€è¦è´­ä¹°æ˜‚è´µç‰©å“æ—¶åªä»ŽçŸ­æœŸåº”æ€¥è´¦æˆ·æ‰£æ¬¾ï¼Œå¹¶åœ¨ä¸‹ä¸ªå‘¨æœŸè¡¥å……çŸ­æœŸåº”æ€¥è´¦æˆ·ã€‚å¦‚æžœé‡‘é¢å¤§äºŽçŸ­æœŸåº”æ€¥è´¦æˆ·çš„èµ„äº§ï¼Œåˆ™åˆ†å¤šæœŸå°†çŸ­æœŸåº”æ€¥è´¦æˆ·å……å€¼åˆ°ç›®æ ‡é‡‘é¢å†è¿›è¡Œæ¶ˆè´¹ã€‚åœ¨è¢«åŠ¨æ”¶å…¥å˜å¾—å¯è§‚ä¹‹å‰ï¼Œä¸å…è®¸å°†é‡‘èžèµ„äº§è½¬å›žè´§å¸èµ„äº§è´¦æˆ·ã€‚ æ”¯å‡ºçš„åˆ†ç±» ä¸ºäº†è®©æ”¯å‡ºçš„ä¸€çº§å’ŒäºŒçº§åˆ†ç±»ä¸è¿‡äºŽå…·ä½“åˆä¸è¿‡äºŽæŠ½è±¡å¹¶ä¸”èƒ½å¤Ÿæœ‰æ•ˆæä¾›å†³ç­–ä¾æ®ï¼Œæˆ‘ä»¬æŠŠä¸€çº§åˆ†ä¸ºè¿™å‡ ä¸ªæ¶µç›–ç”Ÿæ´»æ–¹æ–¹é¢é¢çš„å¤§ç±»ï¼š å±…å®¶ï¼šç§Ÿé‡‘ã€æˆ¿è´·ã€å®¶ç”¨ç”µå™¨ã€å®¶åº­ç»´ä¿®ã€è£…ä¿®ã€æ°´ç”µè´¹ã€ç‡ƒæ°”è´¹ã€ç‰©ä¸šè´¹ äº¤é€šï¼šæ±½æ²¹ã€è½¦è´·ã€è½¦ç¥¨ã€æœˆå¡ã€è½¦è¾†ç»´ä¿®ä¿å…» é£Ÿç‰©ï¼šé£Ÿæã€å¤–å–ã€é¤é¥® å¥åº·ï¼šæŒ‚å·ã€è¯ç‰©ã€ç‰™åˆ·ç‰™è† ç”Ÿæ´»ï¼šæ´—å‘æ°´ã€è¡£ç‰©ã€éž‹ã€æ´—è¡£ç²‰ã€æ¯›å·¾ã€è¯è´¹ã€çœ¼é•œã€æ°´æ¯ã€æ‰‹æœºã€ç†å‘ æˆé•¿ï¼šä¹¦ã€ç½‘è¯¾ã€ä»˜è´¹é—®ç­”ã€å­¦è´¹ã€ç”µè„‘ å¨±ä¹ï¼šä¹¦ã€æ¼”å”±ä¼šé—¨ç¥¨ã€èšé¤ã€å‡æœŸã€ç”µå½±ã€Netflixè®¢é˜…ã€æ¸¸æˆã€é›¶é£Ÿé¥®æ–™ å…³ç³»ï¼šçˆ±äººï¼ˆæˆ‘æ²¡æœ‰ï¼‰ã€çˆ¶æ¯ã€æœ‹å‹ æ¯ä¸ªä¸€çº§åˆ†ç±»ä¸‹ï¼Œéƒ½æœ‰è¿™ä¸‰ä¸ªäºŒçº§åˆ†ç±»ï¼š å¿…éœ€ Â· åŸºç¡€ ä¼˜åŒ– Â· æ”¹è‰¯ éžéœ€ Â· å¥¢ä¾ˆ åº”è¯¥æ ¹æ®é€»è¾‘å¯¹æ”¯å‡ºè¿›è¡Œåˆ†ç±»ã€‚ä¸¾ä¸ªä¾‹å­æ¥è¯´ï¼Œå’Œæœ‹å‹ä¸€èµ·å‡ºåŽ»çœ‹ç”µå½±æ‰€é€ æˆçš„æ”¯å‡ºï¼Œæ ¹æ®é€»è¾‘å¯ä»¥åˆ†ç±»ä¸ºå¨±ä¹ä¹Ÿå¯ä»¥åˆ†ç±»ä¸ºå…³ç³»ï¼šå¦‚æžœå¾ˆäº«å—å°±åˆ†ä¸ºå¨±ä¹-éžéœ€ï¼Œåä¹‹å¦‚æžœæ˜¯è¢«é‚€è¯·æˆ–ç¢äºŽé¢å­å°±åˆ†ä¸ºå…³ç³»-ä¼˜åŒ–ã€‚åˆæˆ–è€…ï¼Œé£Ÿç‰©åˆ†ç±»ä¸‹çš„å¿…éœ€ã€ä¼˜åŒ–ã€éžéœ€åˆ†åˆ«å¯¹åº”äº†åŸºç¡€é£Ÿç‰©ã€ä¸ºäº†å¥åº·æˆ–çŠ’åŠ³è‡ªå·±çš„é£Ÿç‰©ã€é›¶é£Ÿé¥®æ–™ï¼›å¥åº·ä¸‹çš„ä¸‰ä¸ªå­ç±»å¯¹åº”æ²»ç–—ã€é¢„é˜²ä¿å¥ã€åŒ»ç¾Žã€‚é€šè¿‡æ ¹æ®é€»è¾‘å°†ä¸åŒå¤§ç±»ä¸‹çš„æ”¯å‡ºæ€§è´¨åˆ’åˆ†ä¸ºå¿…éœ€ã€ä¼˜åŒ–ã€éžéœ€ä¸‰ä¸ªå­ç±»ï¼Œå¯ä»¥è¿›è¡Œè·¨å¤§ç±»çš„åˆ†æžã€‚ æµé‡çš„ç›‘æŽ§ çŸ­æœŸæ”¯ä»˜èƒ½åŠ› æ—¥å¸¸å¼€é”€è´¦æˆ·çš„ä½™é¢ç›‘æŽ§å½“å‰å‘¨æœŸè¿˜æœ‰å¤šå°‘é¢„ç®—ï¼Œä¸ŽçŸ­æœŸåº”æ€¥è´¦æˆ·çš„ä½™é¢çš„æ€»å’Œå³ä¸ºçŸ­æœŸçš„æ”¯ä»˜èƒ½åŠ›ã€‚é¡ºä¾¿ä¸€æï¼Œæ”¿åºœçš„è´¢æ”¿é¢„ç®—åœ¨è´¢æ”¿å¹´æ²¡æœ‰èŠ±å®Œçš„è¯ï¼Œä¸ä»…è¦ä¸Šç¼´å‰©ä½™çš„é’±ï¼Œæ¬¡å¹´çš„é¢„ç®—è¿˜ä¼šè¢«å‰Šå‡ï¼Œå¯ä»¥è¯´æ”¿åºœæ˜¯è¢«é¼“åŠ±æ‰©å¤§æ”¯å‡ºçš„ã€‚ä½†ä¸ªäººæŠŠæ¡äº†è‡ªå·±çš„é¢„ç®—åˆ¶å®šæƒï¼Œå‡å°‘çš„æ”¯å‡ºåˆå¯ä»¥ç”¨äºŽåŠ å¿«è´¢å¯Œè‡ªç”±çš„è¿›åº¦ã€‚æ‰€ä»¥è®°è´¦ä¼šè®©ä½ å¯¹ä¸ªäººèµ„äº§çŠ¶å†µæœ‰æ›´æ¸…æ¥šçš„è®¤çŸ¥ï¼Œä»Žè€Œå¯¹çŽ°é‡‘æµè¿›è¡Œåˆç†è°ƒæ•´ã€‚ æ•´ä½“ï¼ˆå‘¨æœŸï¼‰çš„æµé‡ é€šè¿‡å¯¹ä¸€ä¸ªå‘¨æœŸå†…æ€»æ”¯å‡ºã€æ”¶å…¥çš„æ±‡æ€»ï¼Œå¯ä»¥ç›‘æŽ§æ•´ä½“çš„æµé‡ã€‚è€ƒè™‘ä½¿ç”¨ç±»ä¼¼èƒ½é‡æµåŠ¨å›¾çš„å›¾è¡¨è¿›è¡Œå¯è§†åŒ–ã€‚ æƒç›Šå˜åŠ¨çš„è®°å½• æœ‰äº›æ”¶å…¥ï¼ˆåŒ…æ‹¬ä¸»åŠ¨ã€è¢«åŠ¨æ”¶å…¥ï¼‰æœ‰æ—¶å¹¶ä¸ç›´æŽ¥è¡¨çŽ°ä¸ºè´§å¸èµ„é‡‘çš„æµå…¥ï¼ˆæ¯”å¦‚å…»è€é‡‘ã€ä¿é™©ã€èµ„æœ¬å¢žå€¼ç­‰ï¼‰ï¼Œä½†æƒç›Šè®°è´¦æ³•è¦æ±‚æˆ‘ä»¬éœ€è¦åœ¨æƒç›Šå‘ç”Ÿæ—¶å°±è¿›è¡Œè®°å½•ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æ¯ä¸ªå‘¨æœŸåœ¨Excelå†…è®°å½•ä¸€æ¬¡æ‰€æœ‰æƒç›Šå’Œå¯¹åº”çš„é‡‘é¢ï¼ˆå•ä½ä¸ºæ³•å¸ï¼‰ã€‚è¿™æ ·åšä¸å½±å“æ”¶å…¥æ”¯å‡ºçš„ç»Ÿè®¡ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥ä¿è¯è´¢åŠ¡åˆ†æžæ—¶å¯ä»¥æŽŒæ¡æƒç›Šæ”¶å…¥ã€‚ åˆ†æž æœªå®Œå¾…ç»­ å‚è€ƒèµ„æ–™ å¦‚ä½•åˆ©ç”¨excelåˆ¶ä½œä¸ªäººè´¢åŠ¡æŠ¥è¡¨ï¼Ÿ - å¶ç§‹çš„å›žç­” - çŸ¥ä¹Ž æœ‰ç®€å•å¥½ç”¨çš„è®°è´¦ app å—ï¼Ÿ - å¶ç§‹çš„å›žç­” - çŸ¥ä¹Ž è´¢åŠ¡åˆ†æžå…¥é—¨ä¹‹èµ„äº§çš„åˆ†ç±» - ä½°äº®åŒå­¦çš„æ–‡ç«  - çŸ¥ä¹Ž è´¢åŠ¡å’Œä¼šè®¡çš„åŒºåˆ«ï¼Ÿä»€ä¹ˆæ˜¯è´¢åŠ¡ï¼Ÿä»€ä¹ˆæ˜¯ä¼šè®¡ï¼Ÿ - å¤œæµ£çž³çš„å›žç­” - çŸ¥ä¹Ž MBAæ™ºåº“ ","link":"https://311zzb.github.io/post/personal-finance/"},{"title":"æœ€å¥½çš„CSå…¥é—¨è¯¾ï¼šCS61aå­¦åŽæ„Ÿ","content":"ä¹‹å‰çœ‹åˆ°åˆ«äººçš„CS61aå­¦åŽæ„Ÿæ—¶ï¼Œåªè§‰å¾—å­¦ä¸ªç½‘è¯¾éƒ½è¦å†™ç¯‡æ–‡ç« æ˜¯ä¸æ˜¯æœ‰ç‚¹è¡¨æ¼”åž‹äººæ ¼äº†ï¼Œä½†æˆ‘å­¦äº†å‡ èŠ‚ä¹‹åŽå°±è§‰å¾—CS61aç®€ç›´æ˜¯æ–‡æ˜Žçš„ç¦éŸ³è½¬ç çš„åœ£ç»ï¼Œä¸ºä»€ä¹ˆæ²¡æœ‰æ—©ç‚¹çŸ¥é“æœ‰è¿™é—¨è¯¾å­˜åœ¨ï¼Ÿå¹¶ä¸”é™·å…¥äº†å¯¹ä¼¯å…‹åˆ©çš„å­¦ç”Ÿçš„ç¾¡æ…•ä¸­ï¼ˆä»–ä»¬å¤§ä¸€å°±å­¦CS61aï¼‰ã€‚çŽ°åœ¨æˆ‘å­¦å®Œäº†CS61açš„ï¼ˆå‡ ä¹Žï¼‰æ‰€æœ‰å†…å®¹ï¼Œç‰¹æ­¤å†™ä¸€ç¯‡æ–‡ç« è®°å½•ä¸€ä¸‹ï¼Œé¡ºä¾¿å®‰åˆ©ç»™æœ‰ç¼˜äººã€‚ ä¸ºä»€ä¹ˆå­¦CS61a æœ¬æ¥æˆ‘æ˜¯çœ‹äº†ä¸€äº©ä¸‰åˆ†åœ°ä¸Šçš„è½¬ç å¸–å­ï¼Œå­¦äº†æ–¯å¦ä½›çš„Databasesè¯¾ä¹‹åŽæ‰“ç®—å­¦CS61bçš„ï¼Œä½†å‘çŽ°CS61aæ˜¯CS61bçš„prerequisiteã€‚ä¸ºäº†æ»¡è¶³å¿ƒç†æ´ç™–ï¼ˆä¹Ÿå› ä¸ºæˆ‘æ—¶é—´æ¯”è¾ƒå……è£•ï¼‰ï¼Œæˆ‘å†³å®šä»ŽCS61aå­¦èµ·ã€‚ ç”±äºŽå½“æ—¶æœ€æ–°çš„fa21è¿˜æ²¡æ›´æ–°å®Œï¼Œæ¬¡æ–°çš„su21çš„æœ€åŽä¸€äº›å½•å±çœ‹ä¸äº†ï¼Œæ¬¡æ¬¡æ–°çš„sp21æ²¡ä¸€ä¸ªå½•å±çœ‹å¾—åˆ°ï¼ŒäºŽæ˜¯æˆ‘å°±å­¦äº†fa20ã€‚éžå¸¸æ„Ÿè°¢UCBæŠŠCS61a fa20ææ–™ä¸­èƒ½å…¬å¼€çš„éƒ½å…¬å¼€äº†ã€‚ CS61aæ•™äº†ä»€ä¹ˆ è¿™é—¨è¯¾æ˜¯SICPçš„å˜ç§ï¼Œä½¿ç”¨Python 3æ¥å±•ç¤ºæŠ½è±¡æ–¹æ³•ã€ç¼–ç¨‹èŒƒå¼å’Œç®¡ç†å¤§åž‹ç¨‹åºçš„æŠ€æœ¯ã€‚ç”±äºŽ2012å¹´ä¹‹åŽçš„æ–°ç‰ˆCS61aä½¿ç”¨Pythonæ•™å­¦ï¼Œæ‰€ä»¥è¾ƒæ—§ç‰ˆï¼ˆä½¿ç”¨Schemeæ•™å­¦ï¼‰æ›´å®¹æ˜“å…¥é—¨ï¼Œä¹Ÿæ›´è´´è¿‘å®žé™…ã€‚åˆ†ç« èŠ‚æ¥è¯´ï¼ŒCS61aä¸»è¦æ•™äº†ä»¥ä¸‹è¿™äº›å†…å®¹ï¼š ç”¨å‡½æ•°æž„å»ºæŠ½è±¡å…³ç³» å‡½æ•°ä¸Žå‡½æ•°è®¾è®¡ æŽ§åˆ¶ é«˜çº§å‡½æ•° é€’å½’å‡½æ•° ç”¨æ•°æ®æž„å»ºæŠ½è±¡å…³ç³» æ•°æ®æŠ½è±¡ å¯å˜æ•°æ® é¢å‘å¯¹è±¡ç¼–ç¨‹ è§£é‡Š(interpreting)è®¡ç®—æœºç¨‹åº å‡½æ•°å¼ç¼–ç¨‹ å¼‚å¸¸ è§£é‡Šå™¨çš„å¼€å‘ æ•°æ®å¤„ç† å£°æ˜Žå¼ç¼–ç¨‹ æˆ‘å­¦åˆ°äº†ä»€ä¹ˆ å…¶å®žåœ¨å­¦CS61aä¹‹å‰æˆ‘ä¹Ÿå­¦è¿‡ç®—æ³•ä¸Žæ•°æ®ç»“æž„ï¼Œåšè¿‡Cè¯­è¨€çš„ç®—æ³•é¢˜ã€ç”¨pythonå’Œjavaåˆ·è¿‡ä¸€ç‚¹leetcodeã€‚ä½†ä¸€ç›´è‹¦äºŽæ²¡æœ‰ç³»ç»Ÿæ€§åœ°å…¥é—¨CSï¼ŒçŸ¥è¯†ç‚¹è¾ƒä¸ºé›¶æ•£ï¼Œæ²¡æœ‰æž„å»º&quot;Computational Thinking&quot;ã€‚é€šè¿‡å­¦ä¹ CS61aï¼Œæˆ‘æ„Ÿè§‰å¤šå°‘ç¼“è§£äº†è¿™ç§ç„¦è™‘ã€‚åœ¨è¯¾ç¨‹çš„ä¸»è¦çŸ¥è¯†ç‚¹å†…å¤–ï¼Œæˆ‘å°è±¡æœ€æ·±åˆ»çš„å†…å®¹æ˜¯è¿™äº›ï¼š ä»£ç å¦‚ä½•è¢«è§£é‡Šå™¨æ‰§è¡Œ è°ƒç”¨ä¸€ä¸ªå‡½æ•°æ—¶operatorå’Œoperandsçš„è®¡ç®—é¡ºåºã€ç¨‹åºæ‰§è¡Œçš„frameå’Œenvironmentã€å¯å˜ä¸Žä¸å¯å˜æ•°æ®ã€å¤šé‡èµ‹å€¼ã€nonlocalèµ‹å€¼ã€å¼‚å¸¸å¤„ç†ç­‰ Recursive Leap of Faith (é€’å½’çš„ä¿¡ä»°ä¹‹è·ƒ) é€’å½’ä¸Žæ•°å­¦å½’çº³æ³•å¾ˆåƒã€‚ç¼–å†™é€’å½’ç¨‹åºæ—¶ï¼Œä¸€ä¸ªbase caseè§„å®šè¾¹ç•Œæ¡ä»¶ã€ä¸€ä¸ªrecursive caseè§„å®šé€’å½’æ“ä½œã€‚åœ¨recursive caseä¸­ï¼Œæˆ‘ä»¬ä¿¡ä»»è¿™ä¸ªå‡½æ•°ä¼šç»™å‡ºæ­£ç¡®çš„nè¿”å›žå€¼ï¼Œå†åˆ©ç”¨è¿”å›žå€¼åŽ»æž„å»ºn+1çš„è¿”å›žå€¼ã€‚è¿™ç§ä¿¡ä»»è¢«ç§°ä¸º&quot;Recursive Leap of Faith&quot;ã€‚åŒæ ·å½“æˆ‘ä»¬ç†è§£ã€ä¿®æ”¹é€’å½’ç¨‹åºæ—¶ï¼Œä¸åº”è¯¥è¯•å›¾æŽ¨æ¼”é€’å½’è°ƒç”¨ï¼Œè€Œæ˜¯ç›´æŽ¥ä¿¡ä»»å®ƒï¼Œå¹¶åœ¨å…¶åŸºç¡€ä¸Šä¿®æ”¹ä»Žnåˆ°n+1çš„æ“ä½œï¼Œleave the hard work to the computerã€‚ å½“ç„¶ï¼Œä¸€å®šè¦æŽ¨æ¼”çš„è¯å¯ä»¥æŽ¨æ¼”ä¸€ä¸ªé€’å½’æ·±åº¦æµ…çš„ä¾‹å­ã€‚ ä»€ä¹ˆæ˜¯abstraction (æŠ½è±¡) èµ‹å€¼ã€å‡½æ•°ã€å¯¹è±¡ç­‰ç­‰éƒ½æ˜¯æŠ½è±¡ï¼Œæ²¡æœ‰æŠ½è±¡çš„è¯­è¨€æ˜¯ä½Žçº§è¯­è¨€ã€‚é€šè¿‡æŠ½è±¡ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠé—®é¢˜å˜ä¸ºè®¡ç®—ã€å˜ä¸ºå¯¹è±¡ã€‚è¿™ä¹Ÿæ˜¯é¢å¯¹å¯¹è±¡ç¼–ç¨‹çš„ä¸€å¤§ä¼˜åŠ¿ï¼šé—®é¢˜çš„åœºæ™¯ä¼šè‡ªåŠ¨è§£å†³ä¸€éƒ¨åˆ†é—®é¢˜ï¼Œit is what it is. ä¸ºä»€ä¹ˆè¯´LISPæ˜¯ç¥žçš„ç¼–ç¨‹è¯­è¨€ CS61aæ•™äº†LISPçš„ä¸€é—¨æ–¹è¨€ï¼šSchemeã€‚è¿™æ˜¯ä¸€é—¨å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ï¼ˆæ‰€æœ‰å‡½æ•°éƒ½æ²¡æœ‰å‰¯ä½œç”¨ï¼Œçº¯ç²¹ä¾é è¿”å›žå€¼ï¼‰ï¼Œåªæœ‰call expressionå’Œspecial formä¸¤ç§è¯­å¥ã€‚ä½†å®ƒç¥žå¥‡åœ¨äºŽå‡ ä¹Žæ— é™çš„å¯æ‹“å±•æ€§ï¼šå®šä¹‰å‡½æ•°å°±ä¸è¯´äº†ï¼›Schemeè¿˜å¯ä»¥é€šè¿‡å®šä¹‰å®æ¥å®šä¹‰special formï¼ˆåŽŸç†æ˜¯å®çš„å‚æ•°ä¸ä¼šåœ¨è°ƒç”¨ä¹‹å‰è¢«evaluateï¼Œè¿›è€Œå¯ä»¥æŽ§åˆ¶evaluationçš„æ­¥éª¤ï¼‰ï¼›è€Œä¸”ï¼ŒSchemeä¸­çš„æ•°æ®ä¸Žç¨‹åºéƒ½æ˜¯é“¾è¡¨ï¼Œè¿™è®©ç¼–å†™ç¼–å†™ç¨‹åºçš„ç¨‹åºå˜å¾—éžå¸¸ç®€å•ï¼Œäº‹å®žä¸Šï¼Œè®¡ç®—æœºæŽ¨å¯¼å…¬å¼ä¸Žç¬¦å·è®¡ç®—æ­£æ˜¯å¦‚ä»Šlispçš„ä¸»è¦åº”ç”¨ä¹‹ä¸€ã€‚ è§£å†³é—®é¢˜çš„ä¸€èˆ¬æ€è·¯ (æ¥è‡ªHow To Design Programs) ä»Žåˆ†æžé—®é¢˜åˆ°å®šä¹‰æ•°æ® é˜…è¯»é—®é¢˜ï¼Œå¯»æ‰¾å¿…é¡»è¦è¢«æŠ½è±¡åŒ–ï¼ˆè¡¨ç¤ºï¼‰çš„ä¿¡æ¯ï¼Œå¹¶æ€è€ƒç”¨ä½•ç§æ•°æ®ç»“æž„è¡¨ç¤ºã€‚å¯»æ‰¾å®žé™…ä¾‹å­ã€‚ å‡½æ•°ç­¾åã€ç›®çš„æè¿°ã€ä»¥åŠdocstring æ€è€ƒè§£å†³é—®é¢˜çš„å‡½æ•°çš„è¾“å…¥ä¸Žè¾“å‡ºï¼Œå‡†ç¡®æè¿°è¿™ä¸ªå‡½æ•°åœ¨è®¡ç®—ä»€ä¹ˆå¹¶æ’°å†™docstringã€‚ ä¾‹å­æŽ¨æ¼” é€šè¿‡ä¾‹å­æŽ¨æ¼”è®¡ç®—çš„æ­¥éª¤ï¼Œç¼–å†™æ ¸å¿ƒçš„æ­¥éª¤ï¼Œè®¾è®¡å‡½æ•°çš„éª¨æž¶ã€‚ å‡½æ•°å®šä¹‰ ç¼–å†™å‰©ä¸‹çš„å‡½æ•°ä½¿å…¶èƒ½å¤Ÿæ”¯æ’‘æ ¸å¿ƒæ­¥éª¤ï¼Œé€šè¿‡ä¾‹å­æ„è¯†å˜é‡ä¸Žè¡¨è¾¾å¼çš„å®žé™…æ„ä¹‰ã€‚ æµ‹è¯• ä½¿ç”¨ä¾‹å­æŽ¨æ¼”å‡½æ•°ã€å¹¶ä½¿ç”¨doctestæµ‹è¯•ã€ä¿®æ”¹é”™è¯¯ã€æŠŠç¨‹åºä¿®æ”¹å¾—æ›´ä¸ºæ˜“è¯»ã€‚ CS61aå¥½åœ¨å“ªé‡Œ èƒ½å­¦åˆ°çŸ¥è¯†å½“ç„¶å¥½ï¼Œä½†å®ƒæ˜¯å¦å€¼å¾—æˆ‘èŠ±æ—¶é—´åŽ»å­¦å‘¢ï¼Ÿæˆ‘æƒ³ä¸å°‘äººå¯èƒ½æœ‰è¿™æ ·çš„ç–‘æƒ‘ã€‚æˆ‘çš„å›žç­”æ˜¯YESï¼Œè¿™é—¨è¯¾åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šå¢žåŠ äº†æˆ‘å¯¹ç¼–å†™ç¨‹åºçš„çƒ­æƒ…ï¼Œå¦‚æžœæ²¡æœ‰labã€homeworkã€discussionã€projectä»¥åŠå…¶ä»–è¯¾ç¨‹å·¥å…·çš„ç²¾å·§è®¾è®¡ï¼Œè¿™æ˜¯ä¸å¯èƒ½çš„ï¼šï¼ˆå‡ ä¹Žï¼‰æ‰€æœ‰é¢˜ç›®éƒ½æœ‰å®Œå–„çš„è¯´æ˜Žã€ä¾‹å­ã€åŠè‡ªåŠ¨çš„æµ‹è¯•å’Œæ‰¹æ”¹ï¼Œpython tutorå¯ä»¥å¸®ä½ æŠŠpythonç¨‹åºçš„frameå¯è§†åŒ–ï¼Œåœ¨çº¿interpreterè®©ä½ å¯ä»¥éšæ—¶éšåœ°äº’åŠ¨æµ‹è¯•ã€‚ æœ€é‡è¦çš„æ˜¯ï¼ŒCS61açš„å››ä¸ªé¡¹ç›®é‡Œé¢æœ‰ä¸‰ä¸ªéƒ½æ˜¯åšæ¸¸æˆï¼Œè¿™çœŸçš„å¾ˆè®©äººå…´å¥‹ã€‚æˆ‘è¿˜è®°å¾—æˆ‘æ‰å­¦å®ŒæŽ§åˆ¶å’Œé«˜ç­‰å‡½æ•°çš„æ—¶å€™ï¼Œå°±é‡åˆ°äº†ç¬¬ä¸€ä¸ªé¡¹ç›®ã€‚æ²¡æƒ³åˆ°å…‰æ˜¯ç”¨è¿™ä¹ˆåŸºç¡€çš„çŸ¥è¯†å°±å¯ä»¥ç¼–å†™ä¸€ä¸ªæŽ·éª°å­æ¸¸æˆhogçš„æ ¸å¿ƒé€»è¾‘ã€ç­–ç•¥ã€‚å…¶ä»–å‡ ä¸ªæ¸¸æˆåœ¨è¿™é‡Œå°±ä¸å‰§é€äº†ï¼Œå®ƒä»¬éƒ½å¾ˆæœ‰æ„æ€ã€‚å¦å¤–ï¼ŒCS61aä¸­æœ‰å¥½å‡ å¤„è°éŸ³æ¢—å’Œå¯¹pop cultureçš„è‡´æ•¬ï¼Œå…¶å®žè¿™äº›æ‰æ˜¯æˆ‘è®°å¾—æœ€ç‰¢çš„å“ˆå“ˆå“ˆã€‚é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€äº›èŠ‚ç›®æ•ˆæžœæ‹‰æ»¡çš„lectureï¼Œæ¯”å¦‚Johnè¡¨æ¼”æ‰‹æ“æŸæ¸¸æˆéŸ³ä¹ã€è®²è§£å¯¹è±¡çš„å¤šé‡ç»§æ‰¿æ—¶çš„æŠ½è±¡ä¸€å®¶äººä¼¦ç†å°å‰§åœº...æ€»ä¹‹çœŸçš„å¾ˆæ¬¢ä¹ã€‚ æ•°æ® CS61aæ€»å…±4ä¸ªprojectï¼Œ10ä¸ªhomeworkï¼Œ14ä¸ªdiscussionï¼Œ14ä¸ªlabï¼Œ38ä¸ªlectureï¼Œ261ä¸ªè§†é¢‘ã€‚ æˆ‘ä»Ž10æœˆ31æ—¥åˆ°1æœˆ11æ—¥ï¼Œæ€»å…±ç”¨äº†72å¤©å­¦å®Œï¼ˆå‡ ä¹Žï¼‰æ‰€æœ‰å¯ä»¥å¾—åˆ°çš„ææ–™ï¼ˆåˆšå¼€å§‹çš„ä¸€ä¸ªæœˆåªå­¦äº†65å°æ—¶ï¼‰ã€‚å­¦äº†æœ€é•¿æ—¶é—´çš„é‚£å¤©æ˜¯2021å¹´12æœˆ31å·...åœ¨CS61aä¸Šç”¨äº†6å°æ—¶å››åäº”åˆ†é’Ÿã€‚æœ‰è®°å½•çš„å­¦ä¹ æ—¶é—´å…±è®¡229.08å°æ—¶ï¼Œè¯¦ç»†æ•°æ®(Google Spreadsheet)ä¾›è€ƒè™‘å­¦CS61açš„åŒå­¦å‚è€ƒã€‚ æœ€åŽ åƒè¨€ä¸‡è¯­éš¾ä»¥è¡¨è¾¾æˆ‘å¯¹è¿™é—¨è¯¾çš„å–œçˆ±å’Œå¯¹UCB, Dr. John Denero, Dr. Hany Fairdçš„æ„Ÿè°¢ã€‚å°±ä»¥ä»–ä»¬çš„äººç”Ÿå»ºè®®ç»“æŸå§ã€‚ When I was getting married, I was a PhD student at the time. My mom pulled me aside on my wedding day and said &quot;John I want to give you some advice&quot;. I was like oh she's going to like tell me to listen to my wife or whatever. But she didn't. She said only two words that have stuck with me for a long time. She said &quot;don't compare&quot;. That's all. And then she was like okay you can go back to do whatever you're doing. At the time this was very hard for me to process because I was in a university which is all about comparing people based on like what their exam score was. It turns out that out there in the world, there are no exams that everybody takes that are standardized anymore. All that matter is what you go and get done on your own particular path. So, comparing yourselves to other people becomes meaningless rapidly as what really matter is what you could do yourself, like what you're capable of and what you bother to do and how you choose to spend your time. It took years of this two-word phrase &quot;don't compare&quot; to marinate inside of me and for me to realize that my self-worth really has noting to do with what other people can do or whether I can do it better than them or worse than them. It has everything to do with what i've done and what i'm gonna do next and how I spend my time and better myself. I should just focus on improving myself and forget about what everybody else is doing. (John Denero) It is something that took me a long time in life to understand not to compare. And there's a trap too that we do. We compare for example how big our house is to that one friend and how much money we make to another friend, and the kind of clothes we have to this friend and how smart we are to that friend. We pick and choose these things and that's first of all, even doing that individually is meaningless right? But it's also a trap and this is the problem with social media, you see these sore of curated worlds of other people and it's a trap. One of the great things of getting older is you will get there, I promise, you will realize it's a trap and comparing means absolutely noting. It really is a very internal thing of what are you doing, who do you want to be, how do you want to go through this world, how do you want to treat other people. At the end of the day, that, and almost noting else, is going to matter. And you got to just trust that it's going to be there. (Hany Faird) å¦‚æžœè¿™ç¯‡æ–‡ç« å¯¹ä½ æœ‰å¸®åŠ©ï¼Œè€ƒè™‘ç»™æˆ‘çš„CS61a fall 2020 repositoryç‚¹ä¸ªstarï¼Œè°¢è°¢ã€‚ ","link":"https://311zzb.github.io/post/zui-hao-de-cs-ru-men-ke-cs61a-xue-hou-gan/"},{"title":"åŒéžè½¬ç 6ä¸ªæœˆè€ƒå–åå¤å±‹å¤§å­¦æƒ…æŠ¥å­¦çŸ¥èƒ½ã‚·ã‚¹ãƒ†ãƒ +æ±äº¬å¤§å­¦æ–°é ˜åŸŸäººé–“ç’°å¢ƒç»éªŒåˆ†äº«","content":"æœ¬æ–‡å…±7122å­—ï¼Œé¢„è®¡é˜…è¯»è€—æ—¶14-24åˆ†é’Ÿ æ›´æ–°è®°å½•ï¼š 2021.08.29 æ›´æ–° 5.4 å…³äºŽè€ƒå“ªäº›ä¸“ä¸šçš„é€‰æ‹© 1. å†™åœ¨å‰é¢ ç¬”è€…è™½ç„¶å°æ—¶å€™å°±å¾ˆæƒ³ç•™å­¦äº†ï¼Œä½†ç”±äºŽä¸ªäººè§è¯†çš„é™åˆ¶ï¼Œä¹Ÿä¸ºå®¶é‡Œçš„ç»æµŽçŠ¶å†µå’Œæ€æƒ³è§‚å¿µæ‹…å¿ƒï¼Œæ²¡æœ‰ç›´æŽ¥è¦æ±‚çˆ¶æ¯æŠŠæˆ‘é€å‡ºåŽ»ã€‚åˆé«˜ä¸­çœ‹äº†æŒºå¤šäºŒæ¬¡å…ƒï¼Œè¿˜åœ¨æŸæ¸¸æˆç¾¤æœ‰å¹¸è®¤è¯†äº† @å°–é”‹CF ï¼Œä¸å±•å¼€è¯´äº†ã€‚é«˜ä¸‰æ—¶è·Ÿå®¶é‡Œä¸€å•†é‡ï¼Œç›´æŽ¥è®©æˆ‘ä¸Šå›½å†…çš„æŸä¸­å¤–åˆä½œå¤§å­¦ï¼ˆç¬”è€…é«˜è€ƒåˆ†æ•°çº¦ç­‰äºŽä¸­æµ211æ°´å¹³ï¼‰ï¼Œå‡†å¤‡ç¡•å£«å†ç•™å­¦ï¼ˆæ‰€ä»¥å…¶å®žæ ‡é¢˜çš„â€œåŒéžâ€è¿˜æ˜¯æœ‰ç‚¹æ ‡é¢˜å…šçš„ï¼Œä¸å¥½æ„æ€ï¼‰ã€‚ç”±äºŽä¸Šçš„å¤§å­¦æ˜¯è‹±åˆ¶ï¼Œæ‰€ä»¥æˆ‘å¤§ä¸€æ—¶ä¹Ÿæ‰“ç®—æ¯•ä¸šäº†åŽ»è‹±å›½æ°ä¸ªä¸€å¹´ç¡•ï¼Œä½†åŽæ¥ @å°–é”‹CF å”çªè€ƒä¸Šä¸œå¤§ï¼Œæˆäº†ç¾¤å‹æ¥·æ¨¡ï¼Œç›´æŽ¥å°±åœ¨æˆ‘å¿ƒä¸­ç§ä¸‹äº†ä¸€é¢—åŽ»æ—¥æœ¬ç•™å­¦çš„ç§å­ã€‚å¤§äºŒæš‘å‡çš„æ—¶å€™ï¼Œç¬”è€…å‡ºäºŽç§ç§è€ƒè™‘ï¼Œä¸‹å®šå†³å¿ƒè¦è€ƒæ—¥æœ¬çš„ä¿®å£«ï¼Œæ•…äº‹å°±è¿™ä¹ˆå¼€å§‹äº†ã€‚ æ—¶å…‰èè‹’ï¼Œç™½é©¹è¿‡éš™ã€‚2021å¹´8æœˆï¼Œåœ¨ç»åŽ†äº†ä¸€è¿žä¸²é¢„æ–™åˆ°ä¸Žæ²¡é¢„æ–™åˆ°çš„é…¸ç”œè‹¦è¾£ä¹‹åŽï¼Œè¿™ä¸€ä»¥å‰æ ¹æœ¬ä¸æ•¢å¥¢æœ›çš„ç›®æ ‡ç»ˆäºŽå®žçŽ°ã€‚è°¨ä»¥æ­¤æ–‡æ„Ÿè°¢å‰äººçš„å¸®åŠ©ï¼Œå¹¶å¸Œæœ›èƒ½å¤šå°‘å¸®ä¸Šç›®å‰æ­£åœ¨ä¸ºäº†è‡ªå·±çš„ç›®æ ‡è€ŒåŠªåŠ›çš„æœ‹å‹ã€‚ ç¬”è€…ä»Šå¹´å…±å‡ºæ„¿äº†ä¸œäº¬å¤§å­¦æ–°é¢†åŸŸäººé—´çŽ¯å¢ƒã€ä¸œäº¬å¤§å­¦å·¥å­¦ç³»ç³»åˆ›ï¼ˆç”±äºŽæ²¡æ€Žä¹ˆå¤ä¹ &amp;æ–°é¢†åŸŸå·²ç»åˆäº†æ‰€ä»¥å¼ƒè€ƒï¼‰ã€åå¤å±‹å¤§å­¦çŸ¥èƒ½ç³»ç»Ÿã€ä¸œäº¬å¤§å­¦ç»¼æ–‡å¹¿åŸŸç§‘å­¦ï¼ˆå‡ºæ„¿å¤±è´¥ï¼‰ã€‚è€ƒäº†çš„ä¸¤ä¸ªä¸“æ”»éƒ½åˆæ ¼äº†ï¼Œæœ€åŽå†³å®šåŽ»ä¸œäº¬å¤§å­¦æ–°é¢†åŸŸã€‚ 2. ä¸ªäººèƒŒæ™¯ æœ¬ç§‘é™¢æ ¡ï¼šä¸­å¤–åˆä½œå¤§å­¦ï¼ˆåˆä½œæ–¹çš„QSæŽ’ååœ¨ä¸€ç™¾å·¦å³ï¼‰ æœ¬ç§‘ä¸“ä¸šï¼šæœºæ¢°å­¦é™¢çš„Product Design and Manufactureï¼ˆå·¥ä¸šè®¾è®¡ï¼‰ ç»©ç‚¹ï¼š4.0/4.0ï¼ˆè‹±åˆ¶æ»¡ç»©ä¸éš¾ï¼‰ è‹±è¯­æ°´å¹³ï¼šæ‰˜ç¦89ã€GRE 150|167|3.5ï¼ˆå¹¶æ²¡æœ‰ç”¨ä¸Šï¼‰ã€æœ¬ç§‘å…¨è‹±è¯­æŽˆè¯¾ æ—¥è¯­æ°´å¹³ï¼šN1 161ç‚¹ 3. ç»åŽ† 3.1 æ‘¸ç´¢é˜¶æ®µ 2018.04ï¼šå¤§ä¸€çš„æ—¶å€™æˆ‘ä»Žå­¦æ ¡çš„æ•°å­¦ç³»è½¬åˆ°å·¥ä¸šè®¾è®¡äº†ï¼Œè¿™ä¸ªå†³å®šè™½ç„¶æŒºè ¢çš„ï¼Œä½†ä¸ºäº†è½¬ä¸“ä¸šè€ŒåŠªåŠ›çš„ç»åŽ†è®©æˆ‘æœ‰äº†ä¸€ä¸ªè®¤çœŸå­¦ä¹ çš„æƒ¯æ€§ã€‚å½“æ—¶è¦ä¸æ˜¯ä¸ºäº†è½¬ä¸“ä¸šï¼Œæœ¬æ¥æ˜¯æ‰“ç®—å¤§å­¦å››å¹´éšä¾¿å­¦å­¦å¾—äº†ã€‚ 2018.09ï¼šå¤§äºŒå¼€å§‹çš„æ—¶å€™å› ä¸ºå…´è¶£æƒ³å­¦ZBrushï¼Œä¹°äº†æœ¬æ—¥è¯­ä¹¦å‘çŽ°å®Œå…¨çœ‹ä¸æ‡‚ï¼ŒäºŽæ˜¯åœ¨æ²ªæ±Ÿä¸Šä¸‹è¡€æœ¬ä¹°äº†0-N2çš„è¯¾ï¼Œå¼€å§‹å­¦æ—¥è¯­ã€‚ 2019.08ï¼šå¤§äºŒæš‘å‡çš„æ—¶å€™ï¼Œç¬”è€…åŽ»ä¸Šæµ·æ‰¾äº†ä¸ªå°å…¬å¸åšå·¥ä¸šè®¾è®¡çš„å®žä¹ ã€‚ä¸¤ä¸ªæœˆä¸‹æ¥ï¼Œæ„è¯†åˆ°ä¸Šæµ·ç”Ÿæ´»æœ‰å¤šä¹ˆè´µã€‚é—µè¡Œçš„è€ç ´å°æˆ¿å­ç«Ÿç„¶ä¸€å¹³ç±³äº”ä¸‡ï¼Œä¸æ‡‚ä¸ºä»€ä¹ˆæœ‰äººä¹°ã€‚å¦å¤–æˆ‘å¯¹è®¾è®¡çš„å…´è¶£å¼€å§‹ä¸‹é™ï¼Œè¿™ä¸ªäº‹æƒ…çš„æ™ºåŠ›æ´»åŠ¨å¯†åº¦å¤ªä½Žï¼Œè€Œä¸”åšå‡ºæ¥çš„æˆæžœå¾ˆéš¾è¯´æœ‰ä»€ä¹ˆæ„ä¹‰ã€‚å®žä¹ çš„æ—¶å€™é¡ºä¾¿è€ƒäº†ä¸ªN2ï¼ŒåŽæ¥å¾ˆé¡ºåˆ©é€šè¿‡äº†ï¼Œæ„Ÿè§‰å­¦æ—¥è¯­è¿˜æ˜¯æŒºæœ‰æ„æ€çš„ï¼Œæ‰€ä»¥åˆåœ¨æ²ªæ±Ÿä¹°äº†ä¸ªN2-N1çš„è¯¾å­¦ç€ã€‚ 2019.09ï¼šå¤§ä¸‰å¼€å§‹åšäº†å¾ˆå¤šä¿®è€ƒç›¸å…³çš„æƒ…æŠ¥æ”¶é›†ï¼Œä½†å…¶å®žè¿˜æ˜¯é’ˆå¯¹è®¾è®¡æ–¹å‘çš„ã€‚ä¹Ÿæ˜¯è¿™æ®µæ—¶é—´åœ¨ä¿®è€ƒç¾¤é‡Œé«˜å¼ºåº¦æ°´ï¼Œç„¶åŽçŸ¥ä¹Žä¸Šçœ‹ç»éªŒè´´ä»€ä¹ˆçš„ï¼Œå¼€å§‹å¯¹ä¿®è€ƒå…·ä½“æ˜¯ä¸ªä»€ä¹ˆæ¦‚å¿µæœ‰äº†äº†è§£ã€‚é¡ºä¾¿ä¸Šæ—¥äºšä¹°äº†å¥½å¤šç»éªŒè´´é‡ŒæŽ¨èçš„ä¿®è€ƒç”¨ä¹¦ã€‚ 2020.08ï¼šåˆšç»“æŸåœ¨å­¦æ ¡åšçš„æš‘ç ”ï¼ˆå¼€å‘æ™ºèƒ½äº§å“ï¼‰ã€‚å¼€å§‹æŠŠä»Žä¸œå¤§æƒ…æŠ¥å­¦çŽ¯çš„è®¾è®¡åˆ°åº†åº”çš„KMDé¡¹ç›®ç­‰ç­‰å„ç§è·¯å­çš„æ‰€éœ€ææ–™ã€å…³é”®æ—¶é—´ç‚¹ã€è¦è€ƒè¯•çš„ç§‘ç›®æ€»ç»“èµ·æ¥ï¼Œæœ€åŽç»™è‡ªå·±è®¡åˆ’äº†æ¨ªè·¨å¤§å››åˆ°æ¯•ä¸šåŽä¸€å¹´çš„å…«ä¹æ¬¡å…¥è¯•çš„æ—¥ç¨‹ï¼ŒçŽ°åœ¨æƒ³æƒ³éƒ½æœ‰ç‚¹ç¦»è°±ã€‚è¶ç€æš‘å‡é¡ºä¾¿æŠŠMIT OCWçš„çº¿æ€§ä»£æ•°è‡ªå­¦å®Œäº†ã€‚ 2020.09ï¼šçœ‹å¥½äº†ä¸€ä¸ªä¸œå¤§çš„æ•™æŽˆï¼Œå¼€å§‹è‡ªå·±å†™ç ”ç©¶è®¡åˆ’ä¹¦ã€‚ç”±äºŽä¹‹å‰å‡ ä¹Žæ²¡æœ‰ç§‘ç ”ç»éªŒï¼Œæ‰€ä»¥èŠ±äº†æŒºé•¿ä¸€æ®µæ—¶é—´é˜…è¯»æ–‡çŒ®ï¼Œç„¶åŽæŠŠç ”ç©¶è®¡åˆ’ä¹¦å†™äº†æ´‹æ´‹æ´’æ´’ä¸‰é¡µï¼Œç„¶è€ŒRPå†™è¿™ä¹ˆé•¿æ ¹æœ¬æ²¡æœ‰å¿…è¦ã€‚ä¸è¿‡è¿™ä¸ªä¹Ÿç®—æ˜¯é˜…è¯»å¤§é‡æ–‡çŒ®ã€å­¦æœ¯å†™ä½œã€å†™RPã€ç”¨Overleafçš„ç»åŽ†ã€‚ 2020.10ï¼šå¤§å››å¼€å­¦ï¼Œä¸åŒäºŽå›½å†…çš„å¾ˆå¤šé«˜æ ¡ï¼Œç¬”è€…æ‰€åœ¨çš„ä¸“ä¸šå¤§å››ä¸Šéžå¸¸ä¹‹å¿™ï¼Œä»¥è‡³äºŽ11æœˆä¹‹åŽåˆ°æ¬¡å¹´1æœˆé™¤äº†æŠ½ç©ºç”³è¯·ä¸€ä¸‹ä¸œå¤§IMEä»¥å¤–æ ¹æœ¬æ²¡æœ‰åšå…¶ä»–ä¿®è€ƒå‡†å¤‡çš„æ—¶é—´ã€‚ 2020.12ï¼šä¸ºäº†ä¸œå¤§IMEè€ŒåŽ»è€ƒäº†ä¸ªGREï¼Œç”±äºŽå‡ ä¹Žæ²¡å¤ä¹ æ‰€ä»¥ç”šè‡³æ²¡æœ‰è¾¾åˆ°IMEæ‰€è¦æ±‚çš„Verbal 150ï¼Œæ‰“ç®—å¯’å‡é‡æ–°è€ƒã€‚é¡ºä¾¿è£¸è€ƒäº†ä¸ªN1ï¼ŒåŽæ¥çŸ¥é“æ‹¿äº†161åˆ†ã€‚ 2021.01ï¼šæ˜å¤©æš—åœ°å¤ä¹ GREï¼Œ2æœˆ1å·è€ƒäº†ä¸ªå¼€å¤´è¯´çš„é‚£ä¸ªæˆç»©ã€‚IMEçš„åŽç»­æ˜¯æ•™æŽˆçœ‹å®Œæˆ‘å†™äº†ä¸€ä¸ªæœˆçš„ç ”ç©¶è®¡åˆ’ä¹¦ä¹‹åŽè½»ææ·¡å†™åœ°è¯´ä¸å¥½æ„æ€æˆ‘ä»¬ä¸åšè¿™ä¸ªæ–¹å‘äº†ã€‚ç„¶è€Œä»–ç ”ç©¶å®¤å®˜ç½‘éƒ½è¿˜æŒ‚ç€é‚£ä¸ªæ–¹å‘çš„ä»‹ç»ï¼Œæˆ‘ä¼¤å¿ƒäº†ã€‚ 2021.02ï¼šç”±äºŽå¤ªå¤šæ¬¡å¥—å·¥å­¦çš„æ•™æŽˆçš„ç£æ²¡æœ‰å›žåº”ï¼Œæ‰“ç®—åŽ»å¥—ç£ä¹å¤§çš„å·¥ä¸šè®¾è®¡å¾—äº†ã€‚æƒ³èµ·æ¥@é£Žè§çœŸå¤ å°±åœ¨ä¹å¤§ï¼ŒäºŽæ˜¯å¾®åšä¸Šæ‰¾ä»–é—®äº†ä¸€ä¸‹æƒ…å†µï¼Œç»“æžœæˆ‘ä»¬åœ¨2æœˆ14å·é‚£å¤©è¯­éŸ³äººç”Ÿç›¸è°ˆäº†ä¸€ä¸ªå¤šå°æ—¶ï¼ŒèŠå®Œæˆ‘å°±ä¸‹å®šäº†è½¬ç çš„å†³å¿ƒã€‚è°¢è°¢ä½ ï¼Œé£Žè§çœŸå¤ï¼Œä½ æ˜¯è®©æˆ‘åœ¨äººç”Ÿçš„è½¬æŠ˜æœŸåšäº†é‡è¦å†³å®šçš„äººã€‚åŽæ¥æˆ‘æŠ¥äº†æ€é½å¡¾ï¼Œè´¹ç”¨åœ¨å¡¾é‡Œæ˜¯åé«˜çš„ã€‚æˆ‘å¯¹äºŽå¡¾çš„æ€è€ƒåœ¨ä¸‹é¢ç»†è¯´ã€‚ 3.2 å‰æœŸï¼ˆ2æœˆä¸­-5æœˆæœ«ï¼‰ è¿™ä¸ªé˜¶æ®µå…ˆæ˜¯è·Ÿå¡¾ç¡®å®šäº†ä¸€ä¸‹ç›®æ ‡æ ¡ï¼Œæœ€å¼€å§‹å®šçš„æ˜¯ä¸œå¤§çš„ç”µæƒ…ã€ä¸œå·¥çš„æƒ…å·¥ã€è¿˜æœ‰æ—©å¤§å…ˆè¿›ç†å·¥çš„ç”µæ°”æƒ…æŠ¥ï¼ˆåŽæ¥å…¨æ¢äº†ï¼‰ã€‚æŽ¥ç€å°±å¼€å§‹åœ¨å¡¾é‡Œä¸Šè¯¾äº†ï¼Œå¹³å‡ä¸€å‘¨5èŠ‚2å°æ—¶çš„è¯¾ï¼Œå¶å°”ä¹Ÿæœ‰ä¸€å‘¨8èŠ‚çš„æ—¶å€™ï¼Œå°±è¿™æ ·å­¦äº†çº¿ä»£ã€å¾®ç§¯åˆ†ã€æ•°å­—ç”µè·¯ã€è‡ªåŠ¨æœºä¸Žå½¢å¼è¯­è¨€ã€è®¡ç®—æœºç»„æˆåŽŸç†å‡ é—¨è¯¾ï¼Œç„¶åŽå¤å˜å‡½æ•°ã€ç®—æ³•ä¸Žæ•°æ®ç»“æž„å¼€äº†å¤´ã€‚ ç”±äºŽä¸œå¤§ç”µæƒ…å¯¹æˆ‘æ¥è¯´éš¾åº¦å¤ªé«˜ã€æ—©å¤§å…ˆè¿›ç†å·¥çš„ç”µæ°”æƒ…æŠ¥å¤ªæ—©è€ƒè¯•è€Œä¸”è€ƒè¯•èŒƒå›´ä¸Žå…¶ä»–å‡ ä¸ªé‡å¤å¤ªå°‘æ‰€ä»¥éƒ½æ¢æŽ‰äº†ï¼Œç›®æ ‡æ ¡å˜æˆäº†ä¸œå¤§ç³»åˆ›ã€ä¸œå·¥æƒ…å·¥ã€åå¤§çŸ¥èƒ½ç³»ç»Ÿã€‚ åŒæ—¶ï¼Œç¬”è€…è¿˜åœ¨å¡¾çš„å¸®åŠ©ä¸‹å¼€å§‹å¥—ç£CSçš„æ•™æŽˆã€‚ç”±äºŽä¸“ä¸šè·¨åº¦æ¯”è¾ƒå¤§ï¼Œæ‰€ä»¥è¢«å›žå¤çš„æƒ…å†µä¹Ÿä¸æ˜¯å¾ˆä¹è§‚ã€‚å¹¸è¿çš„æ˜¯ä¸Žåå¤§çš„æ•™æŽˆçº¦ä¸Šäº†é¢è¯•ï¼Œæ˜¯æ¯”è¾ƒéšæ„çš„ç§äººé¢ï¼Œä½†å› ä¸ºæˆ‘æ˜¯ç¬¬ä¸€æ¬¡è·Ÿæ—¥æœ¬çš„æ•™æŽˆé¢è¯•æ‰€ä»¥èŠ±äº†æ¯”è¾ƒå¤šæ—¶é—´è®¤çœŸå‡†å¤‡ï¼Œç”¨è‹±è¯­å‘è¡¨äº†ä¸€ä¸‹ä¹‹å‰æš‘ç ”åšçš„é¡¹ç›®ï¼Œç€é‡ä»‹ç»äº†å…¶ä¸­æ¯”è¾ƒCSçš„éƒ¨åˆ†ï¼Œè¿˜è¯´äº†åœ¨ä¿®å£«é˜¶æ®µæ‰“ç®—åšä»€ä¹ˆæ–¹å‘ã€‚ç„¶åŽæ•™æŽˆåœ¨è¯•æŽ¢äº†ä¸€ä¸‹æˆ‘ä¼šä¸ä¼šæ—¥è¯­ï¼ˆæˆ‘ä¼šï¼‰ä¹‹åŽçœ‹èµ·æ¥æ¯”è¾ƒå¼€å¿ƒï¼Œç›´æŽ¥ç»™äº†ä¸ªâ€œå¦‚æžœä½ è€ƒä¸Šäº†å°±è¦ä½ â€çš„å†…è¯ºã€‚è¿™ä»¶äº‹æƒ…å½“æ—¶è®©æˆ‘æŒºå¼€å¿ƒçš„ã€‚ ç”±äºŽæˆ‘å¤§å››ä¸‹å­¦æœŸåªæœ‰ä¸€ä¸ªæ¯•è®¾ï¼Œè€Œä¸”å› ä¸ºæˆ‘ä¹‹å‰å‡åˆ†é«˜å¯¼è‡´æ¯•è®¾ç¨å¾®æ‘†çƒ‚ä¹Ÿæ²¡å…³ç³»ï¼Œæ‰€ä»¥ç›´æŽ¥å †æ—¶é—´å‡†å¤‡ä¿®è€ƒäº†ï¼Œå½“æ—¶ä¸€èˆ¬æ¯å¤©éƒ½ä¼šèŠ±5å°æ—¶å·¦å³åœ¨å‡†å¤‡ä¿®è€ƒä¸Šé¢ã€‚å¡¾é‡Œçš„æ¯èŠ‚è¯¾æˆ‘éƒ½ä¼šåœ¨ä¸Šå®Œä¹‹åŽé‡æ–°çœ‹ä¸€éå½•å±å¹¶åšå¥½ç¬”è®°ï¼Œä¸€èˆ¬æ¥è¯´ä¸€èŠ‚ä¸¤å°æ—¶çš„è¯¾æˆ‘ä¼šèŠ±å››å°æ—¶å·¦å³å¤ä¹ å’Œç»ƒä¹ ã€‚åœ¨æˆ‘è®¤ä¸ºçŸ¥è¯†ç‚¹æ¯”è¾ƒå¤šã€æˆ–æ˜¯æ¯”è¾ƒé‡è¦ã€æˆ–æˆ‘å­¦å¾—ä¸å¤ªè¡Œçš„è¯¾ç¨‹ç»“è¯¾ä¹‹åŽï¼ˆçº¿ä»£ã€å¾®ç§¯åˆ†ã€æ¦‚çŽ‡ï¼‰ï¼Œæˆ‘éƒ½ä¼šèŠ±è´¹å¤§é‡çš„æ—¶é—´å°†ä»¥å¾€çš„æ‰€æœ‰ç¬”è®°è¿‡ä¸€éï¼Œå†é‡æ–°å†™ä¸€ä¸ªæ€»é›†ç¯‡çš„ç¬”è®°ã€‚è¿™æ ·åšçš„å¥½å¤„ä¸€æ˜¯åŠ æ·±å¯¹çŸ¥è¯†ç‚¹çš„å°è±¡å’Œç†è§£ï¼ŒäºŒæ˜¯ä¹‹åŽå†å¤ä¹ çœ‹æ€»é›†ç¯‡å°±å¯ä»¥äº†ï¼ŒèŠ‚çœæ—¶é—´ç²¾åŠ›ã€‚ è¿™ä¸ªé˜¶æ®µç¬”è€…ä¹Ÿä¼šè¯•ç€ä¸è®¡æ—¶åˆ·ä¸€äº›è¿‡åŽ»é—®ï¼Œæ‰¾æ‰¾æ„Ÿè§‰ï¼Œå¹¶æ²¡æœ‰å¤§é‡åˆ·é¢˜ã€‚ 3.3 åŽæœŸï¼ˆ6æœˆ-8æœˆåˆï¼‰ ä¸´è¿‘å„ä¸ªå­¦æ ¡å‡ºæ„¿çš„æ—¥æœŸï¼Œæˆ‘åˆé‡æ–°è€ƒè™‘äº†è¦å‡ºæ„¿çš„å­¦æ ¡ã€‚å½“æ—¶è€ƒè™‘åˆ°ä¸œå·¥è€ƒçš„èŒƒå›´å¹¿ã€åˆè¦æ‰˜ç¦æˆç»©å•åŽŸä»¶ã€åˆä¸ä¸€å®šæœ‰çº¿ä¸Šè€ƒï¼ˆæˆ‘äººåœ¨å›½å†…å¹¶ä¸”å½“æ—¶ç”±äºŽæ—¥æœ¬çš„ç­¾è¯æ”¿ç­–ä¸å¯èƒ½æ¸¡æ—¥ï¼‰ï¼ŒäºŽæ˜¯æžœæ–­æ”¾å¼ƒè€ƒä¸œå·¥ï¼Œæœ€åŽå†³å®šè€ƒä¸‰ä¸ªä¸œå¤§çš„ä¸“ä¸šï¼ˆç³»åˆ›ã€æ–°é¢†åŸŸäººçŽ¯ã€ç»¼æ–‡å¹¿åŸŸç§‘å­¦ï¼‰åŠ ä¸Šåå¤§çš„çŸ¥èƒ½ç³»ç»Ÿã€‚ç„¶è€Œæœ€åŽè¿™æ³¢å†³å®šåšå¾—è¿˜æ˜¯æ¯”è¾ƒä»“ä¿ƒï¼šäººçŽ¯çš„å‰ä¸¤è½®è¯´æ˜Žä¼šå·²ç»ç»“æŸäº†ï¼Œèµ¶ä¸Šäº†ç¬¬ä¸‰è½®è¯´æ˜Žä¼šï¼ˆ6æœˆ5æ—¥ï¼‰ä½†æˆ‘æœ€å¿ƒä»ªçš„æ•™æŽˆå·²ç»æ”¶æ»¡äº†å¤–å›½äººç‰¹åˆ«å…¥è¯•ï¼Œè·Ÿæˆ‘è¯´å¦‚æžœæ—¥è¯­æ²¡é—®é¢˜çš„è¯èµ°ä¸€èˆ¬å…¥è¯•ä¹Ÿä¸€æ ·çš„ã€‚è‡³äºŽä¸œå¤§çš„ç»¼æ–‡å¹¿åŸŸç§‘å­¦ï¼Œç¬”è€…å½“æ—¶æ‰“ç®—æŠ¥å¤§å®¶éƒ½å¾ˆå–œæ¬¢çš„é‡‘å­çŸ¥é©ã€‚ åœ¨å‡ºæ„¿å­£ä¹‹å‰ï¼Œç¬”è€…è¿˜æŠŠå‡ ä¸ªå‡†å¤‡è€ƒçš„ä¸“æ”»çš„ä¿¡æ¯å’Œæ—¶é—´è½´ï¼ˆç”˜ç‰¹å›¾ï¼‰éƒ½ç”¨notionæ•´ç†å¥½äº†ï¼Œè¿™é‡Œè´´ä¸€ä¸‹æˆªå›¾ç»™å¤§å®¶å‚è€ƒã€‚åšå¥½è¿™ç§æ•´ç†å¯ä»¥å¾ˆæœ‰æ•ˆåœ°è¿½è¸ªå¤šä¸ªä¸“æ”»çš„è¿›åº¦ï¼Œæ¶ˆè§£ç„¦è™‘ï¼Œå› æ­¤éžå¸¸æŽ¨èï¼ˆnotionéœ€è¦ç§‘å­¦ä¸Šç½‘æ‰èƒ½è®¿é—®ï¼‰ã€‚ä¸‹æ–¹ç”˜ç‰¹å›¾ ä¸ƒæœˆä»½çš„æ—¶å€™ç”±äºŽæ²¡æœ‰æŽŒæ¡å¥½ä¸œå¤§ç»¼æ–‡å¹¿åŸŸç§‘å­¦å‡ºæ„¿çš„ç»“æŸæ—¶é—´ï¼Œè¿˜æ˜¯å‡ºæ„¿å¤±è´¥äº†ï¼ˆå…·ä½“æ¥è¯´ï¼Œæ˜¯æ˜¯æ‹–åˆ°å½“å¤©ä¸‹åˆä¸¤ç‚¹å¤šæ‰å‘çŽ°æˆªæ­¢æ—¶é—´ä¸æ˜¯æˆ‘æœ¬ç§‘ä¹ æƒ¯çš„23:59è€Œæ˜¯ä¸‰ç‚¹ï¼Œç„¶åŽæ‰å¼€å§‹å¡«è¡¨å•¥çš„ï¼Œç»“æžœæ¼äº†ä¸€ä¸ªé¢å¤–çš„è¡¨å•ï¼‰ã€‚è¿™æ¬¡å¤±è´¥ç»™æˆ‘å½“å¤´ä¸€æ£’ï¼Œå“å¾—æˆ‘å†ä¹Ÿæ²¡å¿ƒæƒ…æ‰“æ¸¸æˆäº†ï¼Œå¼€å§‹æŠŠå‡ ä¹Žæ‰€æœ‰ç²¾åŠ›æ”¾åœ¨å‡†å¤‡ä¿®è€ƒä¸Šã€‚ä¸è¿‡çŽ°åœ¨çœ‹æ¥æ²¡å‡ºä¸œå¤§ç»¼å¹¿å…¶å®žä¹ŸæŒºå¥½çš„é‡‘å­çŸ¥é©é‚£é‡Œéžå¸¸åœ°å·ï¼Œå¥½å¤šè€ƒCSçš„å¤§ä½¬æ‹¿ä»–å½“ä¿åº•ï¼Œè€Œä¸”ç»¼å¹¿çš„å…¥è¯•æœ¬èº«å°±ç›¸å½“æœ‰éš¾åº¦ã€‚ é™¤æ­¤ä¹‹å¤–ä¾¿æ˜¯åœ¨å¡¾é‡Œå­¦å‰©ä¸‹çš„è¯¾ã€‚è¿™ä¸ªé˜¶æ®µå­¦äº†å‰©ä¸‹çš„å¤å˜å‡½æ•°ã€ç®—æ³•ä¸Žæ•°æ®ç»“æž„ã€æ¦‚çŽ‡è®ºä¸Žæ•°ç†ç»Ÿè®¡ã€‚ç¬”è€…ç”±äºŽåœ¨æœ¬ç§‘é˜¶æ®µæ²¡å­¦è¿‡æ¦‚çŽ‡è®ºï¼Œæ‰€ä»¥è¿™æ–¹é¢ç›¸å½“åƒåŠ›ï¼Œå¡¾çš„ç›´æ’­è¯¾åŸºæœ¬è·Ÿä¸ä¸Šï¼Œæ‰€ä»¥æ¯æ¬¡ä¸¤å°æ—¶çš„æ¦‚çŽ‡è¯¾æˆ‘éƒ½è¦èŠ±å…«å°æ—¶ä»”ç»†çœ‹å½•å±å¹¶ä¸”åšå¥½ç¬”è®°ã€‚åŽæ¥å¡¾é‡Œè¯¾éƒ½ç»“æŸä¸¤å‘¨äº†æˆ‘æ‰æŠŠæ¦‚çŽ‡è¯¾çš„æ‰€æœ‰ç¬”è®°æžå®šã€ç»ƒä¹ åˆ·å®Œã€‚ è¿™æ®µæ—¶é—´è¿˜æœ‰å‡ å¤©åœ¨å†™ä¸œå¤§æ–°é¢†åŸŸäººé—´çŽ¯å¢ƒçš„å°è®ºæ–‡ã€‚ç”±äºŽè¢«å¤šæ¬¡ä¹¦é¢åŠå£å¤´è¦æ±‚ä¸ºå…¥è¯•å†…å®¹ä¿å¯†ï¼Œæ‰€ä»¥æ²¡æ³•åœ¨è¿™é‡Œå‘Šè¯‰å¤§å®¶ä»Šå¹´å°è®ºæ–‡çš„é¢˜ç›®ï¼Œåªèƒ½è¯´æ˜¯å¹¶ä¸éš¾ï¼Œå°±ç®—ä½ å®Œå…¨ä¸ä¼šä¹Ÿæœ‰è¶³å¤Ÿçš„æ—¶é—´å­¦å¥½å†å†™ã€‚æœ¬æ–‡æœ«å°¾ä¹Ÿä¼šç¨å¾®èŠä¸€ä¸‹äººé—´çŽ¯å¢ƒçš„ä¸€äº›æƒ…å†µã€‚ é™¤äº†ä¸Šè¯¾ä¹‹å¤–ï¼Œåœ¨è¿™ä¸ªé˜¶æ®µæˆ‘å¼€å§‹æœ‰è®¡åˆ’åœ°åˆ·é¢˜ã€‚åå¤§çŸ¥èƒ½ã‚·ã‚¹ãƒ†ãƒ ä»¥åŠä¸“ä¸šæ‹†åˆ†ä¹‹å‰åŠ èµ·æ¥æ€»å…±æœ‰13å¹´å…¬å¼€çš„è¿‡åŽ»é—®ï¼Œæˆ‘æŠŠå…¶ä¸­æ‰€æœ‰å¾®ç§¯åˆ†çº¿ä»£å¤æ•°è§£æžæ¦‚çŽ‡ç®—æ³•ï¼ˆä¹Ÿå°±æ˜¯ç›®å‰ä¼šè€ƒçš„èŒƒå›´ï¼‰å…¨éƒ½åšäº†ã€‚è¿™ä¸ªåˆ·é¢˜ç›´åˆ°è€ƒè¯•å‰ä¸¤å¤©ï¼ˆ8æœˆ3å·ï¼‰æ‰å…¨éƒ¨åˆ·å®Œæžæ‡‚ã€‚ ä¸è¿‡æ¯”èµ·è¿‡åŽ»é—®ï¼Œæˆ‘å¯¹äºŽå…¶ä»–ææ–™å¹¶æ²¡æœ‰èŠ±å¾ˆå¤šæ—¶é—´ã€‚å¡¾å»ºè®®æˆ‘åˆ·å¾®åˆ†ç§¯åˆ†æ¼”ä¹ ï¼Œæˆ‘ä¸ºäº†çœæ—¶é—´å°±åªçœ‹äº†ä¸€éæœ€åŽä¸€ç« çš„å¤šé‡ç§¯åˆ†ã€‚è¿˜æœ‰ä¸€æœ¬å¾ˆå¥½çš„ä¹¦å«ã€Šå¤§å­¦ç”Ÿçš„æ¦‚çŽ‡ç»Ÿè®¡ã€‹ï¼Œæˆ‘å°±çœ‹äº†ä¸€ä¸‹å…¶ä¸­å…³äºŽæ¸åŒ–å¼çš„éƒ¨åˆ†ã€‚ æˆ‘å½“æ—¶ç»å…¸çš„ä¸€å¤©çš„æ—¶é—´å®‰æŽ’ï¼š 3.4 è€ƒè¯• ä»Šå¹´åå¤§çš„ç¬”è¯•é¢˜ç›®æ¯”ä»¥å¾€æ›´åŠ çµæ´»ï¼Œè™½ç„¶ä¾æ—§æ˜¯å›´ç»•çº¿ä»£å¾®ç§¯åˆ†å¤æ•°è§£æžç®—æ³•ï¼Œä½†ä¸å°‘é¢˜ç›®éƒ½è¦æ±‚è€ƒç”Ÿå¯¹çŸ¥è¯†ç‚¹æœ‰è‡ªå·±çš„ç†è§£è€Œéžæ­»è®°ç¡¬èƒŒã€‚è€ƒåŽé‡æ–°çœ‹äº†ä¸€éï¼Œæˆ‘çš„æ­£ç¡®çŽ‡åœ¨75%å·¦å³ã€‚ 3.4.1 è§£æžãƒ»ç·šå½¢ä»£æ•° ä»Šå¹´çš„å¤æ•°è§£æžè€ƒäº†ä¸€é“äºŒå…ƒä¸€æ¬¡æ–¹ç¨‹ï¼Œä¸ç®—éš¾ã€‚ä½†ç”±äºŽæ¶‰åŠåˆ°ç»™å¤æ•°å¼€æ ¹å·ï¼Œä½¿ç”¨æ¬§æ‹‰å…¬å¼å°±ä¼šå‘çŽ°å¼€ä¸€ä¸ªæ ¹å·ä¼šå¼€å‡ºæ¥ä¸¤ä¸ªç»“æžœï¼Œæ‰€ä»¥æ€»å…±ä¼šæœ‰å››ä¸ªè§£ã€‚ å¾®ç§¯åˆ†è€ƒäº†ä¸€é“ç»å…¸çš„æžå€¼é—®é¢˜ï¼Œæ— å‘ã€‚ çº¿ä»£è€ƒäº†åå¤§æœ€å–œæ¬¢çš„äºŒæ¬¡åž‹ã€‚ä½†æ˜¯æ˜¯å¸¦å‚æ•°çš„ï¼Œæœ€åŽä¸€é—®é—®äºŒæ¬¡åž‹çš„ç¬¦å·ç¡®å®šï¼Œæ±‚å‚æ•°èŒƒå›´ï¼Œç”¨æ­£å®š/è´Ÿå®šçš„æ‰€æœ‰ç‰¹å¾å€¼å¤§äºŽé›¶/å°äºŽé›¶å³å¯ã€‚ ä»Šå¹´è¿˜è€ƒäº†å¾®åˆ†æ–¹ç¨‹ï¼Œè¿™æ–¹é¢ç”±äºŽåå¤§ä¸“ä¸šæ‹†åˆ†ä¹‹åŽåˆ°çŽ°åœ¨éƒ½æ²¡è€ƒè¿‡ï¼Œæˆ‘ä»¥ä¸ºä¸ä¼šè€ƒäº†å°±åŸºæœ¬æ²¡å¤ä¹ ã€‚æœ€åŽè¿˜æ˜¯é ç€ä¾ç¨€çš„è®°å¿†å‹‰å¼ºåšå‡ºæ¥äº†ï¼Œä¸éš¾ã€‚ 3.4.2 ç¢ºçŽ‡ãƒ»çµ±è¨ˆ ä»Šå¹´ç¬¬ä¸€é“æ¦‚çŽ‡è€ƒçš„æ˜¯æŠŠä¸€æ®µé•¿åº¦ä¸º1çš„çº¿éšæœºåˆ‡æˆä¸‰æ®µåŽï¼Œå­˜åœ¨é•¿åº¦å¤§äºŽ0.5çš„çº¿æ®µçš„æ¦‚çŽ‡ã€‚æˆ‘åˆ†äº†ä¸‰ç§æƒ…å†µè®¨è®ºï¼Œå®žé™…ä¸Šæœ€ç®€å•çš„åšæ³•åº”è¯¥æ˜¯æŠŠè¿™ä¸ªä¸€ç»´ä¸Šçš„é—®é¢˜æ”¾åœ¨äºŒç»´å¹³é¢ä¸Šè€ƒè™‘ã€‚ ç¬¬äºŒé¢˜è€ƒçš„æ˜¯éšæœºå˜é‡å‡½æ•°çš„åˆ†å¸ƒï¼Œä¸éš¾ã€‚ ç¬¬ä¸‰é¢˜æ˜¯æ¯”è¾ƒç»¼åˆçš„é¢˜åž‹ï¼Œä¸€å…±ä¸‰ä¸ªå°é¢˜ä¸­ï¼Œå‰ä¸¤å°é¢˜è€ƒäº†äºŒé¡¹åˆ†å¸ƒï¼ŒåŽä¸¤å°é¢˜è€ƒäº†å¯¹æ•°çš„è®¡ç®—ã€‚å°¤å…¶æ˜¯æœ€åŽä¸€å°é¢˜è€ƒäº†åˆ©ç”¨å¯¹æ•°æ¯”è¾ƒä¸¤ä¸ªæžå¤§æ•°çš„å¤§å°ï¼Œè¿™ä¸ªé—®é¢˜æ˜¯é«˜ä¸­çŸ¥è¯†ï¼Œä½†æˆ‘ä¼°è®¡å¾ˆå¤šäººå¿˜è®°æ€Žä¹ˆåšäº†ã€‚ 3.4.3 ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° ä»Šå¹´è¿™é“ç®—æ³•é¢˜åå‘äºŽè€ƒå¯ŸCè¯­è¨€çš„åº”ç”¨ï¼Œå‡ ä¹Žæ²¡æœ‰è€ƒå¯Ÿç®—æ³•çŸ¥è¯†ï¼Œä¸è¿‡æ¯”èµ·åŽ»å¹´çš„é‚£ä¸ªå“ˆå¸Œè¡¨æ¥è¯´ç®€å•ä¸å°‘ã€‚è¿™ç§é¢˜ç›®åŸºæœ¬åªéœ€è¦è®¤çœŸè¯»é¢˜ï¼Œèƒ½å¿«é€Ÿç†è§£ä»£ç åœ¨å¹²å˜›ï¼Œå¤–åŠ ä¸Šç»éªŒå’Œç›´è§‰å°±èƒ½å¾ˆå¿«åšå‡ºæ¥ã€‚ ä½†ä¸å¹¸çš„æ˜¯æœ€åŽä¸€å°é¢˜è¶…è¿‡äº†æˆ‘çš„ç»éªŒèŒƒç•´ï¼Œé—®äº†ä¸€ä¸ªbugå‡ºçŽ°çš„ç†ç”±ï¼Œé‚£ä¸ªéœ€è¦è€ƒè™‘å¾ªçŽ¯æ‰§è¡Œçš„å…ˆåŽé¡ºåºã€‚æˆ‘åœ¨è€ƒåœºä¸Šå°±æ²¡åšå‡ºæ¥ã€‚ 3.4.4 é¢è¯• åå¤§é¢è¯•çš„å½¢å¼æ˜¯ä¸‰åˆ†é’Ÿçš„è¯¾é¢˜å‘è¡¨ã€‚è¿™ä¸ªè¯¾é¢˜ä¼šåœ¨ç¬¬ä¸€å¤©ç¬”è¯•è€ƒå®Œä¹‹åŽä¸‹å‘ï¼Œè¦æ±‚ç¬¬äºŒå¤©ä¸­åˆå›´ç»•è¯¾é¢˜è®²ä¸‰åˆ†é’Ÿï¼Œå¹¶ä¸”å‘è¡¨ä½¿ç”¨çš„ææ–™åªèƒ½æ‰‹ç»˜åœ¨A4çº¸ä¸Šã€‚ç”±äºŽç¬¬äºŒå¤©æ—©ä¸Šæ‰çŸ¥é“è¿›æ²¡è¿›é¢è¯•ï¼Œæ‰€ä»¥å»ºè®®è€ƒå®Œä¼‘æ¯ä¸€ä¼šå„¿å°±å¼€å§‹å‡†å¤‡ï¼Œç­‰ç¡®è®¤è¿›é¢è¯•äº†å†å‡†å¤‡æ˜¯æ¥ä¸åŠçš„ã€‚ä»Šå¹´çš„é¢˜ç›®æ˜¯è¿™ä¸ªï¼š æ©Ÿæ¢°å­¦ç¿’ã«ãŠã‘ã‚‹åã‚Š(bias)ã¨åˆ†æ•£(variance)ã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•å•é¡Œã¨ã¯ä½•ã‹ã«ã¤ã„ã¦ã€ãŠã‚ˆ ã³ãã®å¯¾å‡¦æ³•ã«ã¤ã„ã¦èª¬æ˜Žã›ã‚ˆã€‚ ç„¶åŽåå¤§çªç„¶å®£å¸ƒåªæœ‰ç¬”è¯•æ— æ³•å†³å®šæ˜¯å¦åˆæ ¼çš„åŒå­¦æ‰ä¼šè¿›å…¥é¢è¯•ï¼Œä¹Ÿå°±æ˜¯è¯´è€ƒå¾—å¤ªå¥½æˆ–è€…å¤ªä¸å¥½éƒ½ä¸ç”¨é¢è¯•äº†ã€‚ æˆ‘æ˜¯å…ˆå†™çš„ç¨¿å­å†åšçš„å‘è¡¨ææ–™ï¼Œç”±äºŽéœ€è¦æ‰‹ç»˜ææ–™ï¼Œæ‰€ä»¥æˆ‘å…ˆç”¨Powerpointåšäº†ä¸ªç”µå­ç‰ˆè‰ç¨¿ï¼Œæ»¡æ„ä¹‹åŽå†ç”»åœ¨A4çº¸ä¸Šï¼Œæœ€ç»ˆæ•ˆæžœçœ‹èµ·æ¥æ„Ÿè§‰ä¸é”™ã€‚ææ–™æ˜¯åœ¨æˆ‘å¾—çŸ¥è¿›å…¥äº†é¢è¯•åŽæ‰åšçš„ã€‚ä»Šå¹´çŸ¥èƒ½ç³»ç»Ÿè¿›å…¥é¢è¯•çš„æœ‰27ä¸ªäººï¼Œå å…¨éƒ¨è€ƒç”Ÿçš„16.67%ã€‚ è™½ç„¶é¢è¯•çš„å‘è¡¨ä½¿ç”¨æ—¥è¯­è‹±è¯­çš†å¯ï¼Œä½†æˆ‘å‡†å¤‡äº†æ—¥è¯­çš„ç¨¿å­è€Œææ–™ä¸­å¤§é‡ä½¿ç”¨è‹±è¯­ï¼Œæ„Ÿè§‰è¿™æ ·ä¼šçœ‹èµ·æ¥æ¯”è¾ƒæœ‰è¯´æœåŠ›çš„åŒæ—¶è®©æ•™æŽˆå¬èµ·æ¥ä¸è´¹åŠ›ã€‚å†™å®Œç¨¿å­ä¹‹åŽè¿˜å’Œå¡¾é‡Œè€å¸ˆå¼€zoomç»ƒäº†ä¸€éã€‚ å¼€å§‹é¢è¯•ã€‚æ•™æŽˆå…ˆæ˜¯é—®äº†æˆ‘æŠ¥è€ƒè¿™ä¸ªä¸“æ”»çš„ç†ç”±ï¼Œç„¶åŽåˆé—®æˆ‘æƒ³åšä»€ä¹ˆç ”ç©¶ã€‚è¿™ä¸¤ä¸ªé—®é¢˜æˆ‘è¿˜çœŸæ²¡å‡†å¤‡ï¼Œåªèƒ½å‡­ç€ä»¥å‰å†™è‡ªå·±æ–‡ä¹¦çš„è®°å¿†éšä¾¿è¯´äº†å‡ å¥ï¼Œè¿˜æœ‰ç‚¹ç»“ç»“å·´å·´çš„ã€‚ æŽ¥ä¸‹æ¥è¯¾é¢˜å‘è¡¨çš„çŽ¯èŠ‚å°±æ¯”è¾ƒé¡ºåˆ©äº†ã€‚å‘è¡¨å®Œä¹‹åŽæ•™æŽˆæ²¡æœ‰å¯¹ä¸“ä¸šçŸ¥è¯†è¿›è¡Œæé—®ï¼Œè€Œæ˜¯ç›´æŽ¥å°±å¼€å§‹é—®æˆ‘æ˜¯å¦æ„¿æ„è°ƒå‰‚åˆ°åˆ«çš„ç ”ï¼ˆæˆ‘è¯´æ„¿æ„ï¼‰ï¼›åˆé—®æˆ‘æœ‰æ²¡æœ‰æŠ¥åˆ«çš„å­¦æ ¡ï¼Œæˆ‘è€¿ç›´åœ°è¯´äº†ä¸œäº¬å¤§å­¦ï¼Œä½†åˆè¡¨ç¤ºå¦‚æžœéƒ½åˆæ ¼äº†æˆ‘ä¼šæ¥åå¤§ï¼Œå› ä¸ºè¿™è¾¹æ›´CSä¸€ç‚¹ï¼ˆä¸å¥½æ„æ€ï¼Œæˆ‘åŽæ¥å†³å®šæžœç„¶è¿˜æ˜¯å’•äº†ï¼‰ï¼›æŽ¥ç€è€ƒå®˜è¿½é—®æˆ‘åˆ°åº•æŠ¥äº†ä¸œå¤§å“ªä¸ªä¸“ä¸šï¼Œæˆ‘æƒ³è¯´æ–°é ˜åŸŸã®äººé–“ç’°å¢ƒï¼Œä½†å½“æ—¶çªç„¶ä¸€ç´§å¼ è¯´æˆæ–°éœŠåŸŸã®äººé–“é–¢ä¿‚äº†ï¼Œç©ºæ°”å˜å¾—æœ‰ç‚¹å°´å°¬ï¼›æœ€åŽæ•™æŽˆç»§ç»­é—®äº†æˆ‘æœ‰æ²¡æœ‰å…´è¶£è¯»åšï¼Œæˆ‘è¯´ç›®å‰è¿˜ä¸è€ƒè™‘ã€‚ç„¶åŽé¢è¯•å°±ç»“æŸäº†ã€‚ å¬è¯´åˆ«çš„åŒå­¦é¢è¯•æœ‰è¢«å„ç§é—®ä¸“ä¸šçŸ¥è¯†ç›´åˆ°ç­”ä¸å‡ºæ¥çš„ï¼Œä¹Ÿè®¸æ˜¯æˆ‘çš„å‘è¡¨æŠŠæ•™æŽˆæ‰“åŠ¨äº†ï¼ˆææ–™ç”ŸåŠ¨ç›´è§‚ã€ä½¿ç”¨æ—¥è¯­ã€æ—¥è¯­å£è¯­ã‚¢ã‚¯ã‚»ãƒ³ãƒˆæ²¡é—®é¢˜ä¸”è¯­é€Ÿå¿«ï¼‰ï¼Œåˆæˆ–è®¸æ˜¯å› ä¸ºæˆ‘ä¹‹å‰å°±è·Ÿæ•™æŽˆç§äººé¢è¿‡ï¼Œæ‰€ä»¥ä»–å®Œå…¨æ²¡åˆéš¾æˆ‘ã€‚ 8æœˆ18å·çœ‹åˆ°åˆæ ¼åå•ä¹‹åŽï¼Œæ‰çŸ¥é“è¿™æ¬¡åå¤§çš„çŸ¥èƒ½ç³»ç»Ÿå·²ç»å·æˆäº†éº»èŠ±ï¼š162åè€ƒç”Ÿä¸­åªåˆæ ¼äº†40äººï¼ˆå€çŽ‡4.05ï¼‰ï¼Œå…¶ä¸­çº¿ä¸Šè€ƒè¯•çš„52åè€ƒç”Ÿä¸­ä»…æœ‰3äººåˆæ ¼ã€‚èƒ½å¤Ÿåœ¨æ¯”å¾€å¹´åé«˜çš„å€çŽ‡ä¸‹åˆæ ¼è®©æˆ‘æ„Ÿè§‰æœ‰ç‚¹è†¨èƒ€ã€‚åŽæ¥åå¤§çŸ¥èƒ½52è¿›3ï¼ˆå…¶ä¸­2ä¸ªåŽ»ä¸œå¤§æ–°é¢†åŸŸäº†ï¼‰éƒ½æˆæ¢—äº†å“ˆå“ˆå“ˆï¼ŒåŽè¯ä¸æã€‚ ç¬”è€…æ„Ÿè§‰åå¤§çš„ä¸€èˆ¬å…¥è¯•å¯¹ä¸ä¼šæ—¥è¯­çš„ç•™å­¦ç”Ÿå¹¶ä¸å¤ªå‹å¥½ï¼šä¸ä»…å„ç§æ–‡ä»¶åŸºæœ¬åªæœ‰æ—¥è¯­ï¼Œè€Œä¸”å¬è¯´çº¿ä¸Šé¢è¯•ç”¨è‹±è¯­åšå‘è¡¨çš„éƒ½æ²¡æœ‰åˆæ ¼ï¼ˆæœªç»æ ¸å®žï¼Œä»…ä¾›å‚è€ƒï¼‰ã€‚æ‰€ä»¥è¯´å¦‚æžœæ‰“ç®—èµ°åå¤§çš„ä¸€èˆ¬å…¥è¯•è€ƒä¿®å£«çš„è¯ï¼Œå¥½çš„æ—¥è¯­æ°´å¹³åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šå¯ä»¥å˜æˆè½¯å®žåŠ›ï¼Œå¤šå°‘å¼¥è¡¥ä¸€äº›ç¡¬å®žåŠ›ä¸Šçš„æ¬ ç¼ºã€‚ 4. ãŠã¾ã‘-æ±å¤§æ–°é ˜åŸŸäººé–“ç’°å¢ƒ ä»Šå¹´ä¸€èˆ¬å…¥è¯•ä»…æœ‰30äººæŠ¥åï¼Œè€Œäººé—´çŽ¯å¢ƒçš„åé¢æ˜¯38ï¼Œæˆ‘ä»¥ä¸ºè¿™ä»£è¡¨ç€å¾ˆå®¹æ˜“å°±èƒ½è€ƒä¸Šï¼Œä½†äº‹å®žä¸Šè¿™38çš„åé¢ä¸­è¿˜åŒ…å«èµ°ç‰¹åˆ«å£è¿°è¯•éªŒçš„è€ƒç”Ÿï¼Œä¸”ä»Žç»“æžœä¸Šæ¥è¯´ç‰¹åˆ«å£è¿°è¯•éªŒæ‰æ˜¯å¤§éƒ¨åˆ†åˆæ ¼è€ƒç”Ÿçš„æ¥æºï¼Œæ‰€ä»¥è¯´ä¸è¦æƒ³å½“ç„¶ï¼Œä¸€å®šè¦å¥½å¥½å‡†å¤‡ã€‚æœ€åŽåˆæ ¼çš„ä¸€èˆ¬å…¥è¯•è€ƒç”Ÿæœ‰9äººï¼Œå€çŽ‡3.33ã€‚ è™½ç„¶éœ€è¦ä¸ºå…·ä½“çš„è€ƒè¯•å†…å®¹ä¿å¯†ï¼Œä½†è€ƒå¯Ÿé¡¹ç›®æ˜¯å…¬å¼€çš„ä¿¡æ¯ï¼šå°è®ºæ–‡+å£è¿°è¯•éªŒï¼ˆäº”åˆ†é’Ÿè„±ç¨¿å‘è¡¨&amp;ç­”è¾©ï¼‰+é¢è¯•ï¼Œå‡ä½¿ç”¨æ—¥è¯­ï¼ˆå¤å­£çš„ä¸€èˆ¬å…¥è¯•ï¼‰ã€‚æ€»ä½“æ¥è¯´éš¾åº¦ä¸é«˜ï¼Œä¸»è¦è€ƒæŸ¥çš„æ˜¯åŸºç¡€çŸ¥è¯†æ˜¯å¦æŽŒæ¡ï¼Œä½†å¯¹æ—¥è¯­æ°´å¹³çš„è¦æ±‚æ˜¯å®¢è§‚å­˜åœ¨çš„ã€‚æŽ¨èæ—¥è¯­è¿˜å¯ä»¥çš„åŒå­¦è¯•è¯•çœ‹ï¼Œå…¥è¯•çš„æ—¶é—´çº¿éžå¸¸é•¿ï¼ˆä»Žç»™è¯¾é¢˜åˆ°é¢è¯•å¤§æ¦‚ä¸¤ä¸ªæœˆå·¦å³ï¼‰ï¼Œäº‹æƒ…ä¹Ÿä¸å¤šï¼Œå¯ä»¥åšå……åˆ†çš„å‡†å¤‡ã€‚å¦å¤–ï¼Œç›¸æ¯”äºŽå¤å­£ä¸»è¦è€ƒå¯ŸåŸºç¡€çŸ¥è¯†çš„æŽŒæ¡ç¨‹åº¦ï¼Œå†¬å­£å…¥è¯•çš„é‡ç‚¹æ”¾åœ¨è€ƒç”Ÿæƒ³åšçš„ç ”ç©¶ä¸Šã€‚ å¦‚æžœæ˜¯å†³å®šèµ°ä¸€èˆ¬å…¥è¯•å¹¶æƒ³å…ˆåšç‚¹ä»€ä¹ˆï¼Œä½ å¯ä»¥ï¼šå¤ä¹ é«˜æ•°çš„æ—¶å€™ä¸ä»…è¦çŸ¥å…¶ç„¶è¿˜è¦çŸ¥å…¶æ‰€ä»¥ç„¶ï¼Œå¤šå¯¹å„ç§æ¦‚å¿µè¿›è¡Œä¸€äº›è‡ªå·±çš„æ€è€ƒã€‚å¦å¤–æ—¥è¯­å¤šç»ƒç»ƒï¼Œç‰¹åˆ«æ˜¯å¬åŠ›å’Œå£è¯­ï¼ˆå†™ä½œåˆ°æ—¶å€™ä¸´æ—¶å¼„ä¹Ÿæ¥å¾—åŠï¼‰ã€‚ åŽæ¥ç¬”è€…è™½ç„¶è¢«æ–°é¢†åŸŸäººé—´çŽ¯å¢ƒå½•å–ï¼Œä½†è¢«è°ƒå‰‚åˆ°äº†ç¬¬ä¸ƒå¿—æ„¿ã€‚ä¸è¿‡ç¬”è€…ä»ç„¶é€‰æ‹©åŽ»ä¸œå¤§ï¼Œå› ä¸ºæˆ‘å…¶å®žæ ¹æœ¬ä¸åœ¨ä¹Žç ”ç©¶ä»€ä¹ˆï¼Œæ¯•ç«Ÿæˆ‘çš„åŠ¨æœºæ˜¯æ´—ä¸ªå­¦åŽ†æ‰¾ä»½å¥½å·¥ä½œèµšé’±ç„¶åŽèµ¶ç´§FIREäº«å—äººç”Ÿï¼Œè€Œä¸æ˜¯çœŸçš„æžç§‘ç ”ï¼ˆè¿˜æ˜¯éžå¸¸å°Šæ•¬è®¤çœŸæžç§‘ç ”çš„æœ‹å‹ï¼‰ã€‚ 5. é™„å½• 5.1 å…³äºŽæ—¥è¯­ ç¬”è€…ä»Ž18å¹´9æœˆ2æ—¥æ‰å¼€å§‹æ­£å¼å­¦æ—¥è¯­ï¼ˆåœ¨è¿™ä¹‹å‰æ˜¯äº”åéŸ³æˆ˜å£«ï¼‰ï¼Œè€Œè¿™æ¬¡ä¿®è€ƒèƒ½è¾¾åˆ°ä¸€ä¸ªè¿˜ä¸é”™çš„æˆç»©çœŸæ˜¯å¤šäºäº†è¿˜å‡‘åˆçš„æ—¥è¯­æ°´å¹³ã€‚å…³äºŽæ—¥è¯­çš„å­¦ä¹ æˆ‘ä¹Ÿå‘äº†ä¸€ç¯‡æ–‡ç« ï¼Œæ¬¢è¿ŽæŸ¥çœ‹ã€‚ 5.2 å…³äºŽç§å¡¾ ç¬”è€…å…¶å®žä¸€ç›´å¯¹ç§å¡¾ï¼ˆåŸ¹è®­ç­ï¼‰ä¸å±‘ä¸€é¡¾ï¼Œå› ä¸ºå°æ—¶å€™ä»Žæ¥æ²¡åŽ»è¿‡åŸ¹è®­ç­ï¼Œå…¨æ˜¯é å­¦æ ¡æˆ–è€…è‡ªå­¦ï¼Œæˆç»©ä¹Ÿè¿˜å¯ä»¥ã€‚ä½†è¿™æ¬¡ä¿®è€ƒçš„ç»åŽ†è®©æˆ‘å¯¹è¿™ä»¶äº‹æƒ…æœ‰äº†æ–°çš„è®¤è¯†ï¼šç§å¡¾æ˜¯ä¸€é¡¹ä»¥é‡‘é’±æ¢æ—¶é—´çš„æœåŠ¡ï¼Œå¯ä»¥ç»™ä½ æ›´å…·ä½“çš„æ–¹å‘ï¼Œå¯ä»¥ç»™ä½ å­¦ä¹ çš„ç»å¤§éƒ¨åˆ†èµ„æºï¼Œå¯ä»¥ç»™ä½ ä¸€å®šçš„å®‰å…¨æ„Ÿ...æ€»ä¹‹ï¼Œç¬”è€…å¤§æ¦‚æ€è€ƒäº†ä¸€ä¸‹ä»€ä¹ˆæ ·çš„æƒ…å†µé€‚åˆ/ä¸é€‚åˆæŠ¥ç§å¡¾ï¼Œä¸ªäººè§‚ç‚¹ä»…ä¾›å‚è€ƒã€‚ å¦‚æžœç¬¦åˆä»¥ä¸‹æƒ…å†µä¸­çš„ä¸€ç‚¹æˆ–å¤šç‚¹ï¼Œå»ºè®®ä½ è€ƒè™‘æŠ¥å¡¾ï¼š è¾ƒå¤§è½¬å‘è·¨è€ƒï¼Œæ¯”å¦‚æœºæ¢°è½¬CS çœ‹äº†ä¸‹è¿‡åŽ»é—®å‘çŽ°è¿žé¢˜ç›®éƒ½çœ‹ä¸æ‡‚ ä¸çŸ¥é“è‡ªå·±æƒ³ç ”ç©¶ä»€ä¹ˆï¼Œç”šè‡³æ²¡æœ‰æ„Ÿå…´è¶£çš„ç ”ç©¶æ–¹å‘ å¤‡è€ƒæ—¶é—´â‰¤åŠå¹´ è‡ªå·±è§‰å¾—è‡ªå·±å†è¿™æ ·ä¸‹åŽ»è¦ç™½ç»™äº† å¦‚æžœç¬¦åˆä»¥ä¸‹æƒ…å†µä¸­çš„ä¸€ç‚¹æˆ–å¤šç‚¹ï¼Œå»ºè®®æ…Žé‡è€ƒè™‘ï¼š å¸Œæœ›å¯¹è‡ªå·±çš„ä¿®è€ƒæœ‰æ›´å¤šçš„æŽŒæ¡ï¼Œè®¨åŽŒä»–åŠ›æœ¬é¡˜çš„æ„Ÿè§‰ è§‰å¾—åªè¦æŠ¥äº†å¡¾è·Ÿç€ä¸Šè¯¾ã€è¯´ä»€ä¹ˆéƒ½ç…§åšå°±ä¸€å®šèƒ½è€ƒä¸Š å¦‚æžœå†³å®šæŠ¥å¡¾çš„è¯ï¼Œè¯·åŠ¡å¿…è”ç³»å¤šå®¶å¡¾æˆ–è€…è¯•å¬åŽè¿›è¡Œæ¯”è¾ƒã€‚è¿™ä¹ˆå¤šå¡¾å„æœ‰é•¿çŸ­ï¼Œå¾ˆéš¾æ–­å®šå“ªä¸€å®¶å°±æ˜¯æœ€å¥½çš„ï¼Œä½†ä¹Ÿè®¸ä¼šæœ‰ä¸€å®¶æ˜¯æœ€é€‚åˆä½ çš„ã€‚å¯¹äº†è¿™é‡Œæ’ä¸€æ¡å¹¿å‘Šï¼Œå¦‚æžœæ¯”è¾ƒåŽæœ‰å…´è¶£æŠ¥æ€é½å¡¾ï¼Œé€šè¿‡æˆ‘ä»‹ç»èƒ½ä¾¿å®œä¸€åƒï¼Œæœ‰æ„è¯·è”ç³»æˆ‘ã€‚ 5.3 å…³äºŽå­¤ç‹¬æ„Ÿ æ—¥æœ¬ç•™å­¦æ¯”èµ·è‹±ç¾Žæ¾³ç•™å­¦æ¥è¯´å¾ˆéš¾ä¸ç®—æ˜¯ä¸ªå°ä¼—é€‰æ‹©ï¼Œè€Œè¿™ä¹Ÿæ„å‘³ç€åœ¨çŽ°å®žä¸­è®¤è¯†å¿—åŒé“åˆæœ‹å‹çš„æ¦‚çŽ‡ä½Žäº†ä¸å°‘ã€‚ç¬”è€…æ‰€åœ¨çš„æœ¬ç§‘é™¢æ ¡æ˜¯è‹±åˆ¶çš„ä¸­å¤–åˆä½œå¤§å­¦ï¼Œæ‰€ä»¥å‘¨å›´70%çš„åŒå­¦éƒ½è®¡åˆ’åŽ»è‹±è”é‚¦å›½å®¶ï¼Œå‰©ä¸‹10%åŽ»ç¾Žå›½ï¼Œè¿˜æœ‰20%å°±ä¸šï¼ˆéžå‡†ç¡®æ•°å­—ï¼‰ï¼Œæ€»ä¹‹å°±æ˜¯å¾ˆå°‘è§åˆ°æœ‰åŽ»æ—¥æœ¬çš„ã€‚åˆ°äº†å¤§å››ç¬”è€…è¿˜æ¢äº†å•äººå¯å®¤ï¼Œåˆ°å¤§å››ä¸‹ç”±äºŽè¯¾å°‘ï¼ˆåªæœ‰ä¸€ä¸ªæ¯•è®¾ï¼‰ä¸”æˆ‘å¤ä¹ å¿™ï¼Œæ‰€ä»¥å’Œå¤§å­¦åŒå­¦çš„æ¥å¾€å˜å¾—è¶Šæ¥è¶Šå°‘ã€‚ç”šè‡³æ¯•ä¸šå…¸ç¤¼çš„æ—¶å€™ï¼Œåˆ«äººå‡ºæ¥éƒ½åœ¨åˆå½±ï¼Œæˆ‘å‡ºæ¥æŠŠå­¦ä½æœä¸€è¿˜ç›´æŽ¥å°±å›žå®¿èˆå‡†å¤‡ç¬¬äºŒå¤©æŸç ”ç©¶å®¤çš„è¯´æ˜Žä¼šåŽ»äº†ã€‚æ²¡æœ‰ä¸Žä¸€äº›æ›¾ç»å…³ç³»å¾ˆå¥½çš„å¤§å­¦åŒå­¦ç•™ä¸‹åˆå½±ï¼Œè¯´çœŸçš„æœ‰ç‚¹å¯æƒœã€‚è¿™ç§å­¤ç‹¬ä¸Žå¼‚ç±»æ„Ÿæˆ–å¤šæˆ–å°‘æ˜¯åœ¨å‡†å¤‡è€ƒè¯•çš„è·¯ä¸Šä¸å¯é¿å…çš„ï¼Œå¥½åœ¨æˆ‘ä¸€ç›´éƒ½å¾ˆè‡ªé—­ï¼Œæ—©å°±ä¹ æƒ¯äº†ã€‚è™½ç„¶äººäººçš„æƒ…å†µéƒ½æœ‰æ‰€ä¸åŒï¼Œä½†è¦è¾¾æˆç›®æ ‡å°±æ˜¯ä¸€ä»¶è¦ä»˜å‡ºä»£ä»·çš„äº‹æƒ…ã€‚ è™½ç„¶ä¸Žå¤§å­¦åŒå­¦æ¸è¡Œæ¸è¿œï¼Œä½†å¥½åœ¨çŽ°åœ¨æ˜¯ä¸ªç½‘ç»œå‘è¾¾çš„æ—¶ä»£ï¼Œæœ‰å‡ ä¸ªç½‘ä¸Šçš„æœ‹å‹å¬æˆ‘å€’åžƒåœ¾ï¼Œè¿˜æ˜¯å°±èƒ½åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šæ¶ˆè§£å­¤ç‹¬æ„Ÿã€‚è¿™é‡Œæˆ‘ä¹Ÿè¦ç‰¹åˆ«æ„Ÿè°¢@FMKz7 ç­‰åˆé«˜ä¸­åŒå­¦ã€å¤§å­¦å­¦é•¿@é…±æ²¹ ä»¥åŠgentlemen hubå’ŒAå²›ä¸§å°¸èˆ°é˜Ÿï¼ˆä¸‡æ¶ä¹‹æºï¼Œå°±æ˜¯åœ¨è¿™è®¤è¯†çš„å°–é”‹ï¼‰çš„ç¾¤å‹ï¼Œshitpostingå±žå®žè§£åŽ‹ã€‚å¦å¤–è¿˜æœ‰ä¿®è€ƒç›¸å…³çš„ç¾¤ä¹Ÿç»™è¿‡æˆ‘å¾ˆå¤šçš„å¸®åŠ©ï¼Œä½†è¯·æ³¨æ„ä¸è¦éšæ„æŠŠè‡ªå·±ä¸Žä»–äººæ¯”è¾ƒæˆ–è€…æ²‰è¿·æ°´ç¾¤ã€‚ 5.4 å…³äºŽè€ƒå“ªäº›ä¸“ä¸šçš„é€‰æ‹© å‡†å¤‡ä¿®è€ƒæ˜¯ä¸€ä»¶åŠå…¶è€—è´¹ç²¾åŠ›å’Œæ—¶é—´çš„äº‹æƒ…ï¼Œåœ¨å®šä¸‹ç›®æ ‡çš„æ—¶å€™ï¼Œèƒ½å¦æœ‰å­¦ä¸Šä»¥åŠèƒ½å¦ä¸Šæ¢¦æ ¡å°±å·²ç»åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šç¡®å®šäº†ã€‚ä»¥ä¸‹æ˜¯å‡ ç‚¹ä»Žå…¥è¯•è§’åº¦çœ‹é€‰æ‹©è€ƒå“ªäº›ä¸“æ”»çš„å»ºè®®ï¼Œä»…ä¾›å‚è€ƒï¼š ä¸è¦å› ä¸ºå¾ˆä¸å®‰å°±æŠ¥è€ƒè¿‡å¤šï¼ˆå¤§æ¦‚5ä¸ªæˆ–ä»¥ä¸Šï¼‰ä¸“æ”» é€‰æ‹©ä¸“ä¸šçš„æ—¶å€™ä¸ä»…è¦çœ‹æ˜¯å¦æœ‰ä¸­æ„çš„ç ”ç©¶å®¤ï¼Œæ›´è¦çœ‹ä¸“æ”»çš„è€ƒè¯•æ—¶é—´ã€å½¢å¼ä¸ŽèŒƒå›´ã€ä»¥åŠåˆæ ¼å€çŽ‡ã€‚æœ‰äº›ç ”ç©¶å®¤å¯ä»¥ä»Žå¤šä¸ªä¸åŒçš„ä¸“æ”»è€ƒå…¥ï¼Œè¿™æ—¶å¦‚ä½•é€‰æ‹©å°±æ˜¯ä¸€ä»¶å€¼å¾—è°ƒæŸ¥ä¸Žè€ƒè™‘çš„äº‹æƒ… å»ºè®®æœ‰ç¬”è¯•çš„ä¸“æ”»æœ€å¤šæŠ¥ä¸¤ä¸ªï¼Œè€Œä¸”è¿™ä¸¤ä¸ªçš„è€ƒè¯•èŒƒå›´æœ€å¥½é‡åˆåº¦è¾ƒé«˜è€Œå­¦æ ¡çš„æ¡£æ¬¡å·®è·è¾ƒå¤§ å…¶ä»–å…¥è¯•æ–¹æ³•ï¼ˆå£è¿°è¯•éªŒã€å°è®ºæ–‡ã€é¢è¯•ç­‰ç­‰å…¥è¯•å½¢å¼ä¸­çš„ä¸€ä¸ªæˆ–å¤šä¸ªçš„ç»„åˆï¼‰å¯ä»¥é€‚å½“å¤šæŠ¥ï¼Œå°±å½“æ‘¸å¥–äº†ã€‚ä½†ä¸æŽ¨èè¶…è¿‡3ä¸ª å»ºè®®æ”¶é›†æ‰€æœ‰ç›®æ ‡ä¸“æ”»å¾€å¹´çš„å…¥è¯•æ—¶é—´èŠ‚ç‚¹ï¼Œæžä¸€ä¸ªå‰æ–‡ä¸€æ ·çš„ç”˜ç‰¹å›¾ï¼Œç„¶åŽçœ‹çœ‹æœ‰æ²¡æœ‰å®‰æŽ’ç‰¹åˆ«çˆ†ç‚¸æˆ–è€…è€ƒè¯•æ—¶é—´å†²çªçš„æ—¶å€™ï¼Œå†æ®æ­¤è€ƒè™‘æ”¾å¼ƒä¸€äº›ä¸“æ”» 5.5 å…³äºŽå¤‡è€ƒå¿ƒæ€ å‡†å¤‡ä¿®è€ƒæ˜¯ä¸€ä»¶å¾ˆè®©äººå¿ƒæ€ç‚¸è£‚çš„äº‹æƒ…ï¼Œå› ä¸ºä½ ä¼šå‘çŽ°è‡ªå·±æ€»æ˜¯è¿˜æœ‰æ²¡æœ‰å‡†å¤‡åˆ°ä½çš„åœ°æ–¹ï¼Œè€Œä¸”è®¡åˆ’æ°¸è¿œèµ¶ä¸ä¸Šå˜åŒ–ã€‚ä»¥ä¸‹æ˜¯æˆ‘æ¯”è¾ƒè®¤åŒçš„å‡ ä¸ªå¿ƒæ€ä¸Šçš„æ³¨æ„äº‹é¡¹ï¼Œä»…ä¾›å‚è€ƒï¼š åšå¥½ä¿¡æ¯æœé›†å·¥ä½œã€‚ åƒé‡Œä¹‹è¡Œå§‹äºŽè¶³ä¸‹ã€‚ä¸è¦è¢«çœ‹ä¼¼æ— æ³•å®Œæˆçš„å¤ä¹ ä»»åŠ¡å“åˆ°ï¼Œé€¼è¯å°‘è¯´ï¼Œå¼€æžã€‚ å‘çŽ°è‡ªå·±æœ‰çŸ¥è¯†ç‚¹ä¸ä¼šæ˜¯å¥½äº‹ï¼Œæ¯•ç«Ÿè€ƒè¯•çš„æ—¶å€™å†å‘çŽ°å°±æ¥ä¸åŠäº†ã€‚ä½†ä¹Ÿè¦å¤šæŠŠç›®å…‰æ”¾åœ¨è‡ªå·±å·²ç»ä¼šäº†çš„çŸ¥è¯†ä¸Šï¼Œæ„è¯†åˆ°è‡ªå·±ä¸€ç›´åœ¨å‰è¿›ã€‚ å‘Šè¯‰è‡ªå·±å¡žç¿å¤±é©¬ç„‰çŸ¥éžç¦ï¼ŒåŒæ—¶ä¸ä»¥ç‰©å–œä¸ä»¥å·±æ‚²ã€‚ ä¸è¦æå‰å®£åˆ¤è‡ªå·±å¤±è´¥ï¼Œè¯·åšæŒåˆ°æœ€åŽä¸€åˆ»ã€‚ 5.6 å…¶ä»–èµ„æ–™æŽ¨è è®¤çœŸé˜…è¯»æƒ³è€ƒçš„ä¸“æ”»çš„å‹Ÿé›†è¦é¡¹æ˜¯æœ€ä¼˜å…ˆçš„ï¼Œç„¶åŽè¿™é‡Œæ˜¯å‡ ä¸ªä¹Ÿè®¸æœ‰ç”¨çš„æ–‡ç« /ç½‘ç«™åˆ†äº«ã€‚ é»‘ç™½ï¼šç®€å•æ˜“æ‡‚çš„çŽ°ä»£æ—¥æœ¬ç•™å­¦æ”»ç•¥(ç¡•å£«ç¯‡) é“¶ææ ‘ä¸‹ æ—¥æœ¬ç•™å­¦æƒ…æŠ¥å…±äº« 6. ç»“è¯­ ç»åŽ†äº†ä¿®è€ƒï¼Œæ›´åŠ æ„Ÿè§‰åˆ°å¾ˆå¤šäº‹æƒ…éƒ½è®²ç©¶ä¸€ä¸ªã€Œç©ã¿é‡ã­ã‚„ç¹°ã‚Šè¿”ã—ã€ï¼šé€‰æ‹©å¥½é€‚åˆè‡ªå·±çš„æ–¹å‘ä¸Žæ–¹æ³•ä¹‹åŽï¼Œè®¤çœŸå¯¹å¾…æ¯ä¸€ä»¶å°äº‹è€Œä»˜å‡ºçš„åŠªåŠ›å°±èƒ½æŠŠä½ å¸¦åˆ°æ¢¦æƒ³ä¹‹åœ°ã€‚ æŽ¥ä¸‹æ¥ç¬”è€…å°†ä¼šä»¥åœ¨ä¸œå¤§æ¯•ä¸šä»¥åŠåœ¨æ—¥æœ¬æ‰¾åˆ°ä¸€ä»½é’±å¤šäº‹å°‘çš„å·¥ä½œä¸ºç›®æ ‡åŠªåŠ›ï¼Œé¡ºåˆ©çš„è¯æˆ‘ä»¬ä¸‰å¹´åŽå°±æ´»ç»éªŒè´´å†è§ï¼ä¹Ÿç¥çœ‹åˆ°è¿™é‡Œçš„å¤§å®¶å­¦ä¸šé¡ºåˆ©äº‹ä¸šæˆåŠŸï¼ ","link":"https://311zzb.github.io/post/shuang-fei-zhuan-ma-6-ge-yue-kao-qu-ming-gu-wu-da-xue-qing-bao-xue-zhi-neng-sisutemudong-jing-da-xue-xin-ling-yu-ren-jian-huan-jing-jing-yan-fen-xiang/"},{"title":"æ—¥è¯­å­¦ä¹ å·¥å…·æŽ¨è","content":" äººä»¬æ€»ä¼šé«˜ä¼°è‡ªå·±å‡ å¤©èƒ½åšçš„äº‹æƒ…ï¼Œå´å¾€å¾€ä½Žä¼°è‡ªå·±å‡ å¹´èƒ½åšçš„äº‹æƒ…ã€‚ ä»Ž18å¹´9æœˆ2æ—¥ä¸‹å®šå†³å¿ƒå­¦æ—¥è¯­ç„¶åŽä¹°äº†ä¸ªç½‘è¯¾åˆ°2020å¹´12æœˆé€šè¿‡JLPT N1ï¼Œå¤§éƒ¨åˆ†æ—¶é—´æˆ‘éƒ½æ„Ÿè§‰å­¦ä¹ æ—¥è¯­æ˜¯ä¸€ä»¶ç›¸å½“å¿«ä¹ç®€å•åˆæœ‰æ”¶èŽ·çš„äº‹æƒ…ã€‚ ä»¥ä¸‹è®°å½•ä¸€äº›æˆ‘ç›®å‰è®¤ä¸ºå¯¹è‡ªå­¦æ—¥è¯­ç›¸å½“æœ‰ç”¨çš„ç½‘ç«™ï¼Œä¸­é«˜ç´šè€…å‘ã‘ã§ã™ã€‚ NHKçš„æ³¨éŸ³æ–°é—»ç½‘ç«™ï¼ˆä¸­ä½Žéš¾åº¦é˜…è¯»ç»ƒä¹ ï¼‰ NEWS WEB EASY OJADï¼ŒæŸ¥åŠ¨è¯å˜å½¢ã€ç¡®è®¤å¥å­çš„æ­£ç¡®è¯­è°ƒï¼ˆå·¥å…·ç±»ï¼Œå¼ºçƒˆæŽ¨èï¼‰ OJAD - ã‚ªãƒ³ãƒ©ã‚¤ãƒ³æ—¥æœ¬èªžã‚¢ã‚¯ã‚»ãƒ³ãƒˆè¾žæ›¸ åœ¨çº¿è¯å…¸é›†æˆç‰ˆ ã‚³ãƒˆãƒãƒ³ã‚¯ [ æ™‚äº‹å•é¡Œã€ãƒ‹ãƒ¥ãƒ¼ã‚¹ã‚‚ã‚ã‹ã‚‹ãƒãƒƒãƒˆç™¾ç§‘äº‹å…¸ ] æŸ¥æ±‰å­— æ¼¢å­—ãƒšãƒ‡ã‚£ã‚¢ æ¼¢å­—ã‚„è¨€è‘‰ã®æ„å‘³ã‚’èª¿ã¹ã¦ã¿ã‚ˆã†ï¼ è®¤è¯†æ¯è¯­è€…ä»¥åŠè®©ä»–ä»¬å¸®å¿™æ”¹æ–‡æ³• HiNative | ä¸€ä¸ªé’ˆå¯¹å¤–è¯­å­¦ä¹ è€…çš„é—®ç­”å¹³å°ã€‚ åˆæ˜¯å‡ ä¸ªè¯å…¸ è¾žå…¸ãƒ»ç™¾ç§‘äº‹å…¸ã®æ¤œç´¢ã‚µãƒ¼ãƒ“ã‚¹ - Weblioè¾žæ›¸ è‹¥è€…è¨€è‘‰è¾žå…¸ï½žã‚ãªãŸã¯ã‚ã‹ã‚Šã¾ã™ã‹ï¼Ÿï½žï½œè‹¥è€…ãŒä½¿ã†è¨€è‘‰ã‚’ã€æ„å‘³ã€‘ã€ç”±æ¥ã€‘ã€ä½¿ç”¨ä¾‹ã€‘ã‚’äº¤ãˆã€ã‚ã‹ã‚Šã‚„ã™ãè§£èª¬ã—ã¾ã™ã€‚ å®Ÿç”¨æ—¥æœ¬èªžè¡¨ç¾è¾žå…¸ Youtubeä¸Šçš„ä¸¤ä¸ªæ—¥è¯­æ–°é—»é¢‘é“ï¼ˆéžå¸¸å»ºè®®æ¯å¤©çœ‹ï¼Œå¾ˆæé«˜å¬åŠ›å’Œè¯­æ„Ÿï¼‰ï¼ˆä¸å°‘å…³äºŽä¸­å›½çš„è§†é¢‘å’Œç‰¹é›†ä¹Ÿå¾ˆæœ‰æ„æ€ï¼‰ï¼ˆå„ç§éš¾åº¦çš„å¬åŠ›ç»ƒä¹ ï¼‰ ANNnewsCH ãƒ†ãƒ¬æ±NEWS ä¸€ä¸ªé“é“äº¤é€šåŽ¨é¢‘é“ï¼ˆç›¸å½“åœ°ç‹±éš¾åº¦çš„å¬åŠ›ç»ƒä¹ ï¼‰ ã‚¹ãƒ¼ãƒ„ äº¤é€š / Suit Train ç•¥çŒŽå¥‡çš„äº”åˆ†é’Ÿå°æ•…äº‹é¢‘é“ï¼ˆä¸­ç­‰éš¾åº¦çš„å¬åŠ›ç»ƒä¹ ï¼‰ ãƒ’ãƒ¥ãƒ¼ãƒžãƒ³ãƒã‚°å¤§å­¦_é—‡ã®æ¼«ç”» é˜…è¯»ç»ƒä¹ ï¼ˆæŽ¨ä¸Šå…³æ³¨ç‚¹æ„Ÿå…´è¶£çš„åšä¸»ç„¶åŽæ¯å¤©èŠ±æ—¶é—´åˆ·ä¸€åˆ·ï¼‰ Twitter å£è¯­ç»ƒä¹ ï¼Œä¸Žnative speakerå¯¹è¯ï¼Œå¯ä»¥è®©å¯¹æ–¹æŒ‡å‡ºä½ è¡¨è¾¾ä¸­æœ‰è¿å’Œæ„Ÿçš„åœ°æ–¹ italki: Learn a language online æœ€åŽé¡ºä¾¿ä¸€ææˆ‘å­¦æ—¥è¯­ä¸»è¦ç”¨çš„æ˜¯æ²ªæ±Ÿçš„0-N2å’ŒN2-N1ï¼Œå°±æ˜¯æœ€æ™®é€šçš„ç½‘è¯¾ï¼Œå¤§æ¦‚åŠ èµ·æ¥4000å…ƒï¼ˆä¹°0-N1æ˜¯ä¸‰åƒå¤šä½†æˆ‘åˆšå¼€å§‹å­¦çš„æ—¶å€™æ˜¯æ‰“ç®—å­¦åˆ°N2å°±å·®ä¸å¤šäº†ï¼‰ã€‚ è™½ç„¶ç½‘ä¸Šä¹Ÿæœ‰ä¸Šé¢æ‰€é¢˜ç½‘è¯¾çš„å…è´¹èµ„æºï¼Œä½†èŠ±äº†é’±ä¼šæ›´æœ‰æ²‰æ²¡æˆæœ¬è€Œä¸”ä¿æŠ¤äº†çŸ¥è¯†äº§æƒï¼Œæ‰€ä»¥è¿˜æ˜¯æŽ¨èä¹°æ­£ç‰ˆã€‚ ä¸Šé¢çš„è¿™äº›ç½‘ç«™å’Œé¢‘é“æ˜¯åœ¨å­¦ä¹ è¿‡ç¨‹ä¸­æ…¢æ…¢å¼€å§‹ç”¨çš„ï¼Œå„ç§æ—¥è¯­YouTubeé¢‘é“å¯ä»¥å¸®åŠ©ä½ ä¿æŒå­¦ä¹ çš„ä¸»è§‚èƒ½åŠ¨æ€§ä»¥åŠè¾¾åˆ°ç»ƒä¹ å¬åŠ›ã€è¯­æ„Ÿçš„æ•ˆæžœï¼Œæ‰€ä»¥æˆ‘éžå¸¸æŽ¨èã€‚æˆ‘å­¦æ—¥è¯­çš„æœ€è¿‘ä¸€å¹´è¯´æ˜¯ä¸»è¦æ˜¯åœ¨çœ‹è¿™äº›ä¸œè¥¿å­¦ä¹ ä¹Ÿä¸ä¸ºè¿‡ã€‚ å¦å¤–è¡¥å……ä¸€ä¸ªå°æŠ€å·§ï¼Œä¸Šè¯¾å­¦åˆ°çš„ä¾‹å¥å¯ä»¥èŠ±æ—¶é—´èƒŒä¸‹æ¥ä¸€äº›ï¼ŒèƒŒä¸ä¸‹æ¥è¯»å¾ˆå¤šéä¹Ÿè¡Œï¼Œè¿™æ ·å¯ä»¥åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šæé«˜è¯­æ„Ÿ æœ€åŽè¦æŽ¨èçš„æ˜¯ã‚·ãƒ£ãƒ‰ãƒ¼ã‚¤ãƒ³ã‚° æ—¥æœ¬èªžã‚’è©±ãã†ï¼Œè¿™æœ¬ä¹¦ä¸­çš„å£è¯­è¡¨è¾¾ååˆ†åœ°é“ã€‚åªè¦æ¯å¤©ååˆ†é’Ÿè·Ÿè¯»å°±èƒ½ä¸€ç‚¹ç‚¹æé«˜å£è¯­æ°´å¹³ã€‚åœ¨ç½‘ä¸Šæœ‰pdfå’Œå¬åŠ›èµ„æºã€‚ ","link":"https://311zzb.github.io/post/ri-yu-xue-xi-gong-ju-tui-jian/"},{"title":"æœ¬ç§‘æ¯•è®¾ Undergraduate Final Project","content":"æ€»ä¹‹æŠŠæ¯•è®¾çš„posterå’Œè®ºæ–‡éƒ½æ”¾åœ¨è¿™é‡Œäº†ã€‚ è¯´èµ·æ¥æƒ­æ„§ï¼Œæˆ‘æ›¾ç»ä¹Ÿæ˜¯å­¦è®¾è®¡çš„ã€‚ Poster downloadï¼ˆOneDriveï¼‰ Thesis downloadï¼ˆOneDriveï¼‰ æ³¨ï¼šå‡ºäºŽä¿æŠ¤ä¸ªäººæƒ…æŠ¥çš„è€ƒè™‘ï¼Œåˆ åŽ»äº†åŒ…å«æˆ‘å§“åçš„Declaration of Originality ","link":"https://311zzb.github.io/post/ben-ke-bi-she-undergraduate-final-project/"}]}