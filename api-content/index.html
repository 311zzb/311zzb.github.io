{"posts":[{"title":"Gitlet Design Document","content":"This is the design document of my implementation of Gitlet, a version-control system that mimics some of the basic features of the popular system Git. It passed all tests on the gradescope autograder provided by University of California Berkeley, CS 61B. Source code is available upon request. Classes and Data Structures Main Driver class for Gitlet, a subset of the Git version-control system. Account for validating the number of arguments and invoking package-private methods according to received commands. The cache write back method Cache.writeBack() which enabling the persistence of Gitlet is also invoked in this class. Fields This class contains only static methods since Main should not be instantiated. static final File localCWD = new File(System.getProperty(&quot;user.dir&quot;)) The current working directory File object. static String currCommand A static variable that holds the current command. Used during pull command. public static void main(String[] args) The main method of Gitlet. private static void assertArgsNum(String[] args, int n) Throw a GitletException if args don't have exactly n elements. private static void assertNotArgsNum(String[] args, int n) Throw a GitletException if args have exactly n elements. private static String[] getOperands(String[] args) Strip the first element of the input array and return the rest. private static void assertString(String expected, String actual) Assert two String are equal. Cache This class is used to house static methods that facilitate lazy loading and caching of persistence. This file will set up data structures for caching, load necessary objects, and write back the cache at the very end of execution. This class will never be instantiated. This class defers all HashObject and its subclasses' logic to them. For example, instead of deserialize and serialize objects directly, Cache class will invoke methods from the corresponding class to do that. On the other hand, the Cache class will do all the getxxx() methods which retrieving desired objects lazily from the cache. Fields Caching HashObject static final Map&lt;String, HashObject&gt; cachedHashObjects A Map that stores cached ID and HashObject pairs. static Map&lt;String, HashObject&gt; cachedRemoteHashObjects The cache for the remote repository. private static HashObject getHashObject(String id) Lazy loading and caching of HashObjects. Being private because a HashObject will never be requested as HashObject (as Commit or Tree or Blob instead). Special case: return null if requesting a commit with null or &quot;&quot;. static Commit getCommit(String id) A method that lazy-load a Commit with id utilizing getHashObject(String id). static Tree getTree(String id) A method that lazy-load a Tree with id utilizing getHashObject(String id). static Blob getBlob(String id) A method that lazy-load a Blob with id utilizing getHashObject(String id). static Commit getLatestCommit() Get the Commit object of the latest commit utilizing getCommit(String id). static final Set&lt;String&gt; queuedForWriteHashObjects New HashObjects' IDs that are queued for writing to filesystem. static String cacheAndQueueForWriteHashObject(HashObject object) Manually cache a HashObject by put a HashObject into the cache, and queue it for writing to filesystem. Return its ID. static void writeBackAllQueuedHashObject() Write back all queued-for-writing HashObjects to filesystem. Invoked upon exit. static final Set&lt;String&gt; queuedForDeleteHashObject Deprecated HashObjects' IDs that are queued for deletion from filesystem. static void queueForDeleteHashObject(String id) Given Qa HashObject's ID, queue it for deletion. static void deleteAllQueuedHashObject() Delete all queued-for-deletion HashObjects. Invoked upon exit. Caching Branches static final Map&lt;String, String&gt; cachedBranches A Map that stores cached branch name and commit ID pairs. static Map&lt;String, String&gt; cachedRemoteBranches The cache for the remote repository. static String getBranch(String branchName) Lazy loading and caching of branches. static String getLatestCommitID() A method that lazy-load the ID of the latest commit by getBranch(getHEAD()). static void cacheBranch(String branchName, String commitID) Manually cache a Branch by putting a branchName - commitID pair into the cache. static void wipeBranch(String branchName) Manually wipe the pointer of a designated branch. static void writeBackAllBranches() Write back (update) all branches to filesystem. Invoked upon exit. If a branch's pointer is wiped out, delete the branch file in the filesystem. Special case: ignore branch with empty name. Caching HEAD static String cachedHEAD A String that stores cached HEAD, the current branch's name. static String cachedRemoteHEAD The cache for the remote repository. static String getHEAD() Lazy loading and caching of HEAD. static void cacheHEAD(String branchName) Manually cache the HEAD by assigning the cachedHEAD to a given branchName. static void writeBackHEAD() Write back (update) the HEAD file. Invoked upon exit. Caching STAGE (Stage ID) static String cachedStageID A String that stores cached STAGE, the ID of the current staging area. static String cachedRemoteStageID The cache for the remote repository. static String getStageID() Lazy loading and caching of STAGE (the ID of the saved staging area). Notice: this DOES NOT point to the current staging area after the staging area is modified and before write back. static void cacheStageID(String newStageID) Manually cache the STAGE by assigning the cachedStageID to a given stageID. static void writeBackStageID() Write back STAGE file. Invoked upon exit. Caching the Stage Area static Tree cachedStage A Tree that stores cached staging area. static Tree cachedRemoteStage The cache for the remote repository. static Tree getStage() Get the Tree object representing the staging area utilizing getTree(getStageID()). static void cacheStage(Tree stage) Queue the previous staging area for deletion and manually cache the passed-in Stage. Special case: queue the previous staging area for deletion only if there is a commit, and the previous staging area is different from the Tree of the latest commit, and the previous staging area is not empty. MISC static void writeBack() Write back all caches. Invoked upon exit. static void cleanCache() Reset all caches. Used for testing proposes. private static boolean inRemoteRepo() Return true if currently operating on the remote repository. Repository A class houses static methods related to the whole repository. This class will handle all actual Gitlet commands by invoking methods in other classes correctly. It also sets up persistence and do additional error checking. Fields Static Variables static File CWD The Current Working Directory. A package-private static variable. static File GITLET_DIR The .gitlet directory, where all the state of the repository will be stored. Package-private. static File HEAD The .gitlet/HEAD file. This file stores the name of the active branch. static File STAGE The .gitlet/STAGE file, where the ID of the current staging area is stored. static File ALL_COMMITS_ID The .gitlet/allCommitsID file, which is a serialized Tree that holds all the IDs of existing commits. static File OBJECTS_DIR The .gilet/objects directory. This is the object database where all HashObject live. static File BRANCHES_DIR The .gitlet/branches directory. Each branch is stored as a file under this directory. static void assignStaticVariables(File cwd) Assign the above static variables according to the given CWD. This is useful dealing with local and remote repositories. The current working directory is passed in as CWD for default, but the remote repository directory will be passed in when manipulating it. init command public static void init() The method which handles the init command. Implementation details in the Algorithms section. static void setUpPersistence() A helper method of init command, set up the persistence directories. Implementation details in the Algorithms section. This method also checks if there is an existing .gitlet directory and abort the execution if so. add command public static void add(String fileName) Execute the add command by adding a copy of the file as it currently exists to the staging area. commit command public static void commit(String message) Execute the commit command. rm command public static void rm(String fileName) Execute the rm command. Implementation details in the Algorithms section. log command public static void log() Execute the log command. Implementation details in the Algorithms section. private static void log(String CommitID) Print log information recursively. Starting from the commit with the given commit ID, to the initial commit. global-log command public static void globalLog() Print log information about all commits ever made. Implementation details in the Algorithms section. find command private static final List&lt;String&gt; foundCommitID A list of commit IDs that have the designated commit message. public static void find(String commitMessage) Execute the find command. Implementation details in the Algorithms section. private static void findCheck(String CommitID, String commitMessage) Check if the designated commit has the designated commit message. status command public static void status() Execute the status command. Implementation details in the Algorithms section. &quot;Modifications Not Staged For Commit&quot; private static void modificationStatus() Print the &quot;Modifications Not Staged For Commit&quot; status. private static List&lt;String&gt; modifiedNotStagedFiles() A private helper method that construct a list of &quot;modified but not staged&quot; files. Implementation details in the Algorithms section. private static Set&lt;String&gt; modifiedStatusFocusFiles() Return a string Set that contains all file names that should be checked (file names in the CWD or the Stage or tracked by the head Commit). private static boolean modifiedNotStagedFiles1(String fileName) Return true if a file is tracked in the current commit, changed in the working directory, but not staged (modified). private static boolean modifiedNotStagedFiles2(String fileName) Return true if a file is staged for addition, but with different contents than in the working directory (modified). private static boolean modifiedNotStagedFiles3(String fileName) Return true if a file is staged for addition, but deleted in the working directory (deleted). private static boolean modifiedNotStagedFiles4(String fileName) Return true if a file is not staged for removal, but tracked in the current commit and deleted from the working directory (deleted). static boolean trackedInHeadCommit(String fileName) Return true if a file is tracked in the head commit. static boolean changedInCWD(String fileName) Return true if a file is changed in the CWD (different from its version in the head commit). static boolean addDiffContent(String fileName) Return true if a file's version in the stage is different from the working one. static boolean notInCWD(String fileName) Return true if a file is not in the CWD. &quot;Untracked Files&quot; private static void untrackedStatus() Print the &quot;Untracked Files&quot; status. private static List&lt;String&gt; untrackedFiles() Return a list of files that is untracked (neither staged for addition nor tracked by the head commit). checkout command public static void checkout1(String fileName) Execute checkout command usage 1 (checkout a file to the latest commit). Implementation details in the Algorithms section. public static void checkout2(String commitID, String fileName) Execute checkout command usage 2 (checkout a file to the given commit). Implementation details in the Algorithms section. public static void checkout3(String branchName) Execute checkout command usage 3 (checkout all files to the designated branch). Implementation details in the Algorithms section. static void checkoutToCommit(String commitID) A helper method that checkout to a Commit (with designated ID). private static void checkoutAllCommitFile(String commitID) A private helper method that checkout all files that a Commit (with designated ID) tracked. private static void checkoutCommitFile(Commit commit, String fileName) A private helper method that checkout a file with fileName from a given Commit. branch command public static void branch(String branchName) Execute the branch command. Implementation details in the Algorithms section. rm-branch command public static void rmBranch(String branchName) Execute the rm-branch command. Implementation details in the Algorithms section. reset command public static void reset(String commitID) Execute the reset command. Implementation details in the Algorithms section. Abbreviated commit ID will be handled, and branches will always point to full IDs. merge command public static void merge(String branchName) Execute the merge command (merge files from the given branch into the current branch). Implementation details in the Algorithms section. private static void mergeModifyCWD(Commit curr, Commit other, Map&lt;String, Set&lt;String&gt;&gt; mergeModifications) Modify files in the CWD (either use the version in the other branch, or make a conflict file) accordingly. private static void makeConflict(Set&lt;String&gt; files, Commit curr, Commit other) Modify all conflict files and add them to the stage. private static String makeConflictContent(String fileName, Commit curr, Commit other) Return the right content for a conflict file after merging. private static void useOther(Set&lt;String&gt; files, Commit other) Modify files in CWD to their versions in the other commit, and stage the change (add or rm). private static Map&lt;String, Set&lt;String&gt;&gt; mergeWillModify(Commit split, Commit curr, Commit other) Perform the checks for the merge command and return a Map of necessary modifications. private static Map&lt;String, Set&lt;String&gt;&gt; mergeLogic(Set&lt;String&gt; focusFiles, Commit split, Commit curr, Commit other) A private helper method that captures the logic of the merge command. private static void mergeChecks1(Commit curr, Commit other) Perform checks for the merge command. private static void fastForward(Commit other) Fast-forward the current branch to the designated commit and print information. Only called when the split commit is the same as the current commit. Special case: do not print fast-forward info when pulling. private static void mergeChecks2(Set&lt;String&gt; changingFiles) Perform checks for the merge command. misc private static void assertGITLET() Assert the CWD contains a .gitlet directory. private static void overwriteCWDFile(String fileName, Blob overwriteSrc) Overwrite the file in CWD of designated file name with the content in the given Blob object. static void sortLexico(List&lt;String&gt; list) Sort a string List in lexicographical order in place. static void deleteCWDFiles() Delete all files in the CWD. private static Set&lt;String&gt; CWDFilesSet() Return a Set of all files' names in the CWD. private static&lt;T&gt; Set&lt;T&gt; combineSets(Set&lt;T&gt;... sets) Generic method to merge (union) multiple sets in Java. static void printAndExit(String msg) Print a message and exit the execution with status 0. Branch This class houses static methods that related to branch and HEAD. It contains methods for loading and writing branch files and the HEAD file. This class will never be instantiated since there are only static methods. Fields static String loadBranch(String branchName) Load a branch file from filesystem with designated name. Return null if the branch name is &quot;&quot; (nothing) or there is no branch. Invoked by the Cache class. static boolean existBranch(String branchName) Return true if a branch exists. static List&lt;String&gt; loadAllBranches() Load all branch files from the filesystem. Return a List contains all commit IDs that are pointed by a branch. static void branchStatus() Print the &quot;Branches&quot; status. Implementation details in the Algorithms section. static void writeBranch(String branchName) Get a branch's information from cache and write it back to filesystem. Invoked by the Cache class. static void deleteBranch(String branchName) Delete the designated branch in the filesystem. Invoked by the Cache class. static void mkNewBranch(String branchName, String commitID) Make a new branch with designated name at the latest commit by caching it manually. static void moveCurrBranch(String commitID) Make the current branch pointing to a designated commit. static void moveBranch(String branchName, String commitID) Move the designated branch to point to a commit with designated ID. static String loadHEAD() Load the HEAD file and return the current branch's name. Invoked by the Cache class. static void writeHEAD() Get the HEAD from cache and write it back to filesystem. Invoked by the Cache class. static void moveHEAD(String branchName) Make the HEAD pointing to a designated branch. private static File branchFile(String branchName) Get the File object of a branch with designated name. private static List&lt;String&gt; allBranches() Return a List of all branches' names. Support fetched remote branches. Stage This class houses static methods that related to Stage (the staging area). It contains methods for loading and writing the STAGE file, as well as making a new staging area. This class will never be instantiated since there are only static methods. Fields static String loadStageID() Return the ID of the current staging area (a Tree object). Invoked by the Cache class. static void putInStage(String fileName, String BlobID) Copy the staging area and add a fileName - BlobID pair. Mark the previous staging area Tree for deletion. This function should only be invoked once per run. static void removeFromStage(String fileName) Copy the staging area and remove the entry with a specific fileName (if exists) from it. Mark the previous staging area Tree for deletion. This function should only be invoked once per run. static void writeStageID() Write the stage ID in cache back to filesystem. Invoked by the Cache class. static void mkNewStage() Make a new stage (a Tree object) and cache its ID. static void addToStage(String fileName) Add a file to the current staging area. Implementation details in the Algorithms section. static void stageStatus() Print the status information related with the staging area. private static List&lt;String&gt; stagedFiles() Return a sorted List of file names in the current staging area. private static void stagedFilesStatus() Print the &quot;Staged Files&quot; status. Implementation details in the Algorithms section. private static void removedFilesStatus() Print the &quot;Removed Files&quot; status. Implementation details in the Algorithms section. static boolean isStagedForAdd(String fileName) Return true if a designated file is staged for addition. static boolean isStagedForRemoval(String fileName) Return true if a designated file is staged for removal. HashObject This class represents a HashObject that will be serialized within .gitlet/objects, named after its SHA-1. HashObject is an implementation of Serializable and Dumpable. This file has helper methods that will return the SHA-1 (ID) of a HashObject. As well as static methods that returning the HashObject object corresponding to its ID (SHA-1), and write to or delete from the object database a HashObject. Fields private static final Boolean OPTIMIZATION Allow you to switch between flat objects directory (easy to debug) and HashTable objects directory (better performance). Notice: this should be consistence for a single Gitlet repository. String id() Get the SHA-1 of THIS. public void dump() Print the type of this object on System.out. static HashObject loadHashObject(String id) Load a type object with its ID. Special case: return null if told to load an object that does not exist. static void writeCachedHashObject(String id) Write a cached HashObject with ID in cachedObjects to filesystem. static void deleteHashObject(String id) Delete a HashObject from filesystem. static private File optimizedObjectIDFolder(String id) Helper method that returns the housing directory of a HashObject with the given ID. Used in the optimized object database. static private File optimizedObjectIDFile(String id) Helper method that returns the file of a HashObject with the given ID. Used in the optimized object database. static private File optimizedObjectAbbrevIDFile(String id) Helper method that return the file of a HashObject with the given abbreviated ID. Used in the optimized object database. Despite HashObject should be instantiated very often, it has no constructor method(s). Any HashObject is designed to be instantiated as a more specific subclass, namely Commit, Tree, or Blob. Commit This class represents a Commit in Gitlet, it extends the HashObject class. Each instance of Commit have several instance variables such as commit message and time stamp. This file also has helper methods that unlocks instance variable as well as static method that carry out the procedure to make a new commit. Fields private final String _message The commit message. private final String _parentCommitID The ID of the parent commit. private final String _parentMergeCommitID The ID of the second parent (if any). private final Date _timeStamp A time stamp of the commit been made. private final String _treeID The ID of the associated Tree object. private Commit(String parentCommitID, String message, String treeRef) The constructor of Commit class. This method is private because no &quot;naked&quot; instantiation of Commit is allowed outside the Commit class. Additionally, the time stamp is set to 1970.01.01 00:00:00 for initial commit. private Commit(String firstCommitID, String secondCommitID, String message, String treeRef) Constructor for merge commits. public String toString() Content-addressable overriding toString() method. String logString() Return the log information of this Commit. public void dump() Print information of this Commit on System.out. String getMessage() Get the message of this Commit. String getParentCommitID() Get the ID of the parent commit. String getParentMergeCommitID() Get the ID of the second parent commit. Commit getParentCommit() Get the Commit object of the parent commit. Commit getParentMergeCommit() Get the Commit object ot the second parent commit. String getCommitTreeID() Get the ID of the associating Tree of this commit. Tree getCommitTree() Get the associating Tree of this commit. String getBlobID(String fileName) Get the ID of the Blob of a designated file name in this commit. String getFileContent(String fileName) Return the content of a designated file name in this commit. Special case: return an empty String if there is no corresponding Blob. Boolean trackedFile(String fileName) Return whether this Commit contains a file with fileName. Set&lt;String&gt; trackedFiles() Return a string Set of tracked files of this commit. static void mkCommit(String message) Factory method. Make a new Commit. Implementation details in the Algorithm section. static void mkMergeCommit(String givenBranchName, Boolean conflicted) Factory method. Make a new merge Commit. static Commit lca(Commit commit1, Commit commit2) Return the latest common ancestor (LCA) of two Commits. static Set&lt;String&gt; ancestors(Commit commit) Recursively collect and return a Set of all ancestors' ID of the given Commit object, including merge parents. Special case: return an empty Set if the given Commit is null. static void recordCommitID(String commitID) Record a new commit's ID to the .gitlet/allCommitsID file. static Tree getAllCommitsID() Return a Tree object that captures all IDs of commits ever made. Tree Represent a Gitlet Tree, corresponding to UNIX directory entries. Implements Iterable&lt;String&gt;, extends HashObject. An instance of Tree object contains a TreeMap as instance variable, which has zero or more entries. Each of these entries is a fileName - BlobID pair. This class also contains Tree related static methods. Fields private final Map&lt;String, String&gt; _structure The TreeMap that stores fileName - blobID pairs. Tree() The constructor of Tree class. Tree(Tree another) A constructor that deep-copy the passed-in Tree. public String toString() Content-addressable overriding toString() method. public void dump() Print information of this Tree on System.out. boolean isEmpty() Return whether this Tree is empty. boolean containsFile(String fileName) Return true if a Tree contains a file with fileName. List&lt;String&gt; trackedFiles() Return the sorted list of file names in this Tree following a Java string-comparison order. void putBlobID(String fileName, String blobRef) Record a fileName - blobID pairs. void removeBlobID(String fileName) Remove an entry with fileName as the key from this Tree. String getBlobID(String fileName) Return the ID of a Blob according to a given fileName (if exists). Blob getBlob(String fileName) Return a Blob according to a given fileName (if exist). public Iterator&lt;String&gt; iterator() Returns an Iterator of this Tree, namely the keySet() of its TreeMap. void updateWith(Tree updater) Update this Tree with the entries in the given Tree. Special case: remove the corresponding pair from this if the value to a key in the updater is null. static String mkNewEmptyTree() Factory method. Creates an empty Tree, cache it and return its ID. static Tree getLatestCommitTree() Factory method. Return the copy of the Tree of the latest commit if exists. Special case: return null if there is no latest commit. static String mkCommitTree() Factory method. Return a Tree that capture the Tree from the latest commit as well as current addition and removal status. Implementation details in the Algorithm section. Special cases: make a new empty tree if there is no Tree in the latest commit. private static Tree copyLatestCommitTree() Factory method. Return a deep-copy of the Tree in the latest commit. static Teww CWDFiles() Return a temporary Tree that capture information of files in CWD. Blob Represent a Gitlet Blob, corresponding to UNIX files. Extends HashObject. Blob has one instance variable _content, which holding the content of a file. This variable enables a Blob to represent a version of such file. This class also has Blob related static methods. Fields private final String _content The instance variable that hold the content of a version of a file. Blob(String content) The private constructor of Blob. No &quot;naked&quot; instantiation of Blob is allowed. String getContent() Unlocks the content of a Blob. public String toString() Content-addressable overriding toString() method. public void dump() Print information of this Tree on System.out. static String mkBlob(String fileName) Factory method. Make a new Blob with a designated file. Cache it and queue it for writing to filesystem. Special case: adding a file that not exists in the CWD means adding it for removal. static String currFileID(String fileName) Return the ID of a designated file's Blob without cache or saving a Blob. Remote Represent a remote Gitlet repository and accommodating remote commands related methods. Fields Non-static methods File _remoteWD Stores the working directory of this remote repository as a File object. private Remote(File remoteGitlet) Construct a remote repository representation. private void remoteRunner() Change the CWD in the Gitlet running environment to the remote repository's working directory. Must call before commanding the remote repository. private void localRunner() Change the CWD in Gitlet running environment to the local repository's working directory. Methods that simply calling remoteRunner() and localRunner() before and after calling the method with the same signature from other classes. private String getHEAD() private Commit getLatestCommit() private String getBranch(String branchName) private Commit getCommit(String id) private String cacheAndQueueForWriteHashObject(HashObject object) private void writeBack() private Set&lt;String&gt; commitAncestors(Commit commit) private void moveHEAD(String branchName) private void moveCurrBranch(String commitID) private void checkoutToCommit(String commitID) private boolean existBranch(String branchName) private void mkNewBranch(String branchName) private void mkNewStage() private Tree getCommitTree(Commit commit) private Blob getBlob(String blobID) private void recordCommitID(String commitID) Static methods add-remote command public static void addRemote(String remoteName, String path) Execute the add-remote command by creating a reference to the remote repository. private static void writeRemote(File remoteFile, String path) Write a remote repository reference. static File readRemote(String remoteName) Get the File referencing the remote (in the local repository). rm-remote command static File getRemoteGitlet(String remoteName) Get the File of the remote .gitlet directory. push command public static void push(String remoteName, String remoteBranchName) Executing the push command. private static void pushReset(Remote remote, String commitID, String remoteBranchName) Fast-forward the remote repository. private static Set&lt;String&gt; commitsToPush(Commit localC, Commit remoteC, Remote remote) Return a Set of String containing the IDs of commits that should be pushed to the remote repo. private static void pushCommits(Set&lt;String&gt; commitIDs, Remote remote) Push all Commit with the designated ID in the Set, and its associating Tree and Blob to the remote repository. private static void pushCommit(Commit commit, Remote remote) Push a single Commit and its associating Tree and Blob to the remote repository. fetch command public static void fetch(String remoteName, String remoteBranchName) Execute the fetch command. Implementation details in the Algorithms section. private static Set&lt;String&gt; commitsToFetch(Commit localC, Commit remoteC, Remote remote) Return a Set of String containing the IDs of commits that should be fetched from the remote repo. private static void fetchCommits(Remote remote, Set&lt;String&gt; commitIDs) Fetch commits that their IDs in the Set to the local repo. private static void fetchCommit(Remote remote, String commitID) Fetch a commit to the local repo. pull command public static void pull(String remoteName, String remoteBranchName) Execute the pull command. Implementation details in the Algorithms section. GitletTest This class contains JUnit tests and some helper methods for Gitlet. Fields init command public void initCommandSanityTest() Sanity test for init command. add command public void addCommandSanityTest() Sanity test for add command. public void addCommandTwiceTest() Test using add command twice. commit command public void commitSanityTest() Sanity test for commit command. public void dummyCommitTest() Dummy commit test (commit without adding anything). public void commitAndAddTest() Add a file, make a commit, and add another file. public void addAndRestoreTest() Make a commit, change the file and add, then change back and add. The staging area should be empty. rm command public void rmUnstageTest() The rm command should unstage the added file. public void rmCommitTest() Add a file, commit, and rm it, commit again. The latest commit should have an empty commit tree. The file in the CWD should be deleted. log command public void logSanityTest() Sanity test for log command. Init and log. public void simpleLogTest() Simple test for log command. Init, commit, and log. public void normalLogTest() Normal test for log command. Init, commit, commit, and log. global-log command public void globalLogSanityTest() Sanity test for global-log command. public void globalLogBranchTest() Test for global-log command with branching. Need implementation. find command public void findSanityTest() Sanity test for find command. public void findBranchTest() Test for find command with branching. Need implementation. status command public void statusBasicTest() Basic test for status command. public void statusModification3Test() Test extra functions (&quot;Modification Not Staged For Commit&quot;) condition 3 of status command. public void statusModification4Test() Test extra functions (&quot;Modification Not Staged For Commit&quot;) condition 4 of status command. public void statusUntrackedTest() Test extra functions (&quot;Untracked Files&quot;) of status command. checkout command public void checkoutHeadFileSanityTest() Sanity test for checkout usage 1 (checkout a file to the latest commit). public void checkoutCommitFileSanityTest() Sanity test for checkout usage 2 (checkout a file to the given commit). public void checkoutBranchSanityTest() Sanity test for checkout usage 3 (checkout to a branch). branch command public void branchSanityTest() Sanity test for branch command. rm-branch command public void rmBranchSanityTest() Sanity test for rm-branch command. reset command public void resetSanityTest() Sanity test for reset command. merge command public void lcaTest() Test the lca method. public void mergeSanityTest() A sanity test for the merge command. public void mergeConflictTest() Test merging two branches with conflict. public void mergeTest() A hard (and comprehensive) test for the merge command. add-remote command public void addRemoteTest()A sanity test for add-remote. push command public void pushTest() A sanity test for add-remote command. fetch command public void fetchTest() A sanity test for fetch command. pull command public void pullTest() A sanity test for pull command. Auto grader debug tests public void test20_status_after_commit() public void test24_global_log_prev() public void test29_bad_checkouts_err() public void test35_merge_rm_conflicts() public void test36a_merge_parent2() misc static final File CWD The local repository's working directory. private static void GitletExecute(String... command) Execute commands with Gitlet and clean the cache after execution. Special case: make sure there is no .gitlet directory before the init command. Implemented for testing purposes. private static void writeTestFile(String fileName, String content) Write content into a designated file name. Overwriting or creating file as needed. private static void deleteTestFile(String fileName) Delete the file with the designated name. private static String readTestFile(String fileName) Read the designated file as String and return it. private static void deleteDirectory(File directoryToBeDeleted) Delete a directory recursively. private static void writeAndAdd(String fileName, String content) Write a test file with the designated file name and content, then add it to the stage. private static void assertFile(String fileName, String content) Assert a designated file has the designated content. Algorithms Lazy Loading and Caching Lazy Loading: Only retrieve information from your file system when you need it, not all at once in the beginning. Caching: Once you load something from your file system, save it in your Java program, so you don’t need to load it again. (E.g. as an attribute or an entry in a Map.) Writing back: If you cached something and then modified it, make sure at the end of your Java program, you write the changes to your file system. Reference: Gitlet Persistence In this implementation of Gitlet, I used a standalone java Class Cache.java to accommodate code for lazy-loading and caching. During lazy loading, the load****() method for specific Class is invoked to retrieve an instance of that Class by specifying the object's ID. Additionally, Commit, Tree, and Blob don't have standalone load****() methods because they are subclasses of HashObject. After loading, the cached object is saved into the corresponding static variable. Namely, a TreeMap cachedHashObjects will store ID to HashObject pairs, another TreeMap cachedBranches will store branchName to commitID pairs, a String cachedHEAD will store the content of .gitlet/HEAD (the current branch's name), and a String cachedStageID will store the content of .gitlet/STAGE (the ID of the staging area Tree). Additionally, there is List queuedForWriteHashObjects and queuedForDeleteHashObject that hold IDs that should be (re)write to or delete from the filesystem. These Lists are updated along the course of execution by cacheAndQueueForWriteHashObject(HashObject object) and queueForDeleteHashObject(String id). Note that a HashObject will never be modified after its creation. Therefore, no modification of existing HashObjects will be carried out thus there is no such queuedForModifyHashObjects data structure. At the very end of execution, caches will be written back to filesystem. Entries in cachedHashObjects, will be written to or delete from filesystem based on the IDs contained in queuedForWriteHashObjects and queuedForDeleteHashObject. Additionally, cachedBranches, cachedHEAD, cachedStageID will be rewritten anyway since the size of related persistence are trivial for the most time. Get the ID of a HashObject Every HashObject need to be serialized and saved in filesystem, thus a unique file name (ID) is indispensable. We use SHA-1 (Secure Hashcode Algorithm 1) hashcode as a content-addressable ID of every HashOject. In order to achieve content-addressability, the following two characteristics is necessary: Different HashObjects with identical contents should have the same ID. A HashObject's ID should change after it is modified in terms of its contents. To accomplish such requirements, ID of a HashObject is generated from applying SHA-1 on its string representation. And subclasses of the HashObject class overrides the default toString() method to make it content-addressable. Saving, loading, or deleting a HashObject If the static variable OPTIMIZATION in HashObject class is set to true, Gitlet will construct a HashTable-liked structure in the .gitlet/objects directory. That is, all HashObject (with a 40-character ID) will be stored under the .gitlet/objects/xx directory and named after xxx, where xx is the leading two characters of its ID and xxx is the left 38 characters. The point of this optimization is speeding up retrieving Commit when the user abbreviate commit ID with a unique prefix. The real Git is also utilizing this technique. When the user provide an abbreviated commit ID, Gitlet will go to the corresponding .gitlet/objects/xx directory and iterate through a list of file names in that directory in order to figure out the comprehensive commit ID. On the other hand, if OPTIMIZATION is set to false, all HashObject will be stored flatly under the .gitlet/objects directory and named after the corresponding ID. This set up is might be more convenient when digging into the object database for debugging purposes. Due to performance concerns, referring commits with abbreviated IDs is not allowed when OPTIMIZATION is set to false. Initialize the repository Set up the repository Create an initial commit Set up the repository Set up persistence directories Make the default branch &quot;master&quot; which is pointing null for now (no pun intended) Make the HEAD pointing to the master branch Make a new staging area Initialize and serialize a Tree to .gitlet/allCommitsID Make a Commit Get the ID of the latest commit Make a commit Tree by copying from the latest commit, and update it with the staging area Construct a new Commit object with the private constructor Cache the new Commit and queue it for write back Move the current branch pointing the new commit Make a new staging area Record the new commit's ID Make a commit Tree A commit Tree is a Tree that every commit uses to record the associated file names and file versions (Blob). Get a copy of the Tree of the latest commit Get the staging area Tree Update that copy with the staging area (Special case: remove the corresponding pair from that copy if the value to a key in the staging area is null, i.e., staged for removal) Cache it and queue it for writing Stage a file for addition Get the file as its current version, cache it as a Blob (don't queue for write back yet) Get the version of the designated file from the latest commit Special case: If the current version of the file is identical to the version in the latest commit (by comparing IDs), do not stage it, and remove it from the staging area if it is already there. End the execution. Modify cached staging area Stage a file for removal Abort if the file is neither staged nor tracked by the head commit. If the file is currently staged for addition, unstage it. If the file is tracked in the current commit, stage it for removal and remove it from the CWD. When it comes to the design decision of representing &quot;staged for removal&quot;, the chosen solution is to treat pairs in the staging tree with &quot;&quot; (an empty String) value as staged for removal. That is, when a file is staged for removal: It is deleted from the CWD if the user haven't done that. It is &quot;added&quot; to the staging area. Given the fact that there is no such file in the CWD, a {fileName - &quot;&quot;} pair will be written into the staging area. When making a commit Tree, staged for removal file will be handled and the new commit Tree will not include the staged-for-removal files. In this manner, problems with naive approaches (such as introduce a &quot;staging area for removal&quot; Tree) is avoided, and the amount of codes to implement the rm command is trivial. Print log Get the ID of the latest commit Print log information starting from that commit to the initial commit recursively Get the Commit object with the given CommitID Print its log information Recursively print its ascendants' log information Print global log Get the allCommitsID Tree which holds all commits' IDs. Print log information for each of the IDs. The find command This command has similar algorithm with the global-log command. Both of these commands cover all commits ever made by the same manner. Get the allCommitsID Tree which holds all commits' IDs. Check each commit whether it has the designated commit message. Print repository status The status information is consist of the following five parts. &quot;Branches&quot; Get a list of all branches by reading the filenames in the .gitlet/branches directory. Sort the list in lexicographical order. Print the header and all branches, print an asterisk before printing the current branch. &quot;Staged Files&quot; and &quot;Removed Files&quot; Get the current staging area, and get a lexicographical sorted list of filenames it currently holds. If a filename has an empty corresponding BlobID in the staging area, print it under &quot;Removed Files&quot;; if a filename has a valid corresponding BlobID in the staging area, print it under &quot;Staged Files&quot;. &quot;Modifications Not Staged For Commit&quot; Get a Set of all file names that should be checked (file names in the CWD, the staging area, and the head commit). Check each file name and fill a List for &quot;modified but not staged files&quot;. Conditions are described below. Record the file name concatenates (modified) if it satisfies condition 1 or 2. Record the file name concatenates (deleted) if it satisfies condition 3 or 4. A file name is either marked as modified or marked as deleted or not marked. Print the List. &quot;Untracked Files&quot; Get a list of all untracked files. A file is untracked if it is neither staged for addition nor tracked by the head commit. Print the file names. Conditions for &quot;Modifications Not Staged For Commit&quot;: Tracked in the current commit, changed in the working directory, but not staged. Staged for addition, but with different contents than in the working directory. Staged for addition, but deleted in the working directory. Not staged for removal, but tracked in the current commit and deleted from the working directory. Get a list of untracked files Get the information of files in the CWD as a Tree object. Get the head Commit object. Iterate through the file names in the CWD, add it to a list of untracked files if it: is not staged for addition (not contained in the staging area or its corresponding Blob ID is empty) is not tracked by the head commit Sort the untracked files list in lexicographical order The checkout command Checkout a file to HEAD commit Get the ID of the latest commit Invoke checkout2(String commitID, String fileName) method with the ID of the latest commit. Checkout a file to the commit with the designated ID Get the Commit object with the designated commit ID Get the designated file's Blob object form that commit Overwrite the file with that name in the CWD Checkout to a designated branch Perform checks: Gitlet will abort if no branch with the given name exists, or that branch is the current branch, or a working file is untracked. Move the HEAD to that branch. Checkout to the commit that the branch is pointing to. Checkout to a designated commit Delete all files in the CWD. Checkout all files tracked by that commit. Clean the staging area. Create a new branch Creating new branches is carried out when branch or init command is given. When creating new branches, the operation under the hood is no more than writing a branchName - CommitID pair into the cachedBranches which is then written back to the filesystem upon exit. The CommitID assigned to the new branch is always the latest commit (head commit) if there is one. For the default &quot;master&quot; branch which is created right before the initial commit, its corresponding is null at the very first (but pointed to the initial commit after the initial commit is created). Remove a branch This command delete the branch with the given name. It does not delete any commits under that branch. Abort if the designated branch does not exist Abort if the designated branch is the current branch Wipe the branch's pointer in the cache and delete the branch file upon exit Reset to a designated commit Perform the checks: the commit with the designated ID exists, and there is no working untracked file. Checkout to the designated commit. Move the current branch to that commit (The biggest difference between reset and checkout [branch name] command). Merge files from the given branch into the current branch The merge command is one of the most complicated commands in Gitlet. Therefore, the execution of this command is divided to multiple helper methods. Generally, the following procedure is followed to execute this command. Get the latest Commit object of the current branch, the given branch, and the common ancestors (split commit). Perform checks. Calculate which files will be changed in what manners, and perform checks. Modify the CWD following the result from step 2, staging for addition or removal as we go. Make a merge commit. Get the latest common ancestor (split commit) of two commits Get a Set of all ancestors' ID of a commit. This is accomplished by recursively collect all parent commit(s)' ID(s) and their parent(s)' ID(s), like breadth-first-search. Note that a merge commit has two parents, both will be collected as its ancestor. Starting from the other commit, breadth-first-search the first commit that its ID is in the Set. Determine which files will be changed in what manners Get a Set of file names that should be checked by combining sets of file names tracked by the split, current, and the other branch's head commits. Construct a Map of String to Set of String Map&lt;String, Set&lt;String&gt;&gt;, where &quot;other&quot; is mapped to a Set of files' file names that should use the version in the other (given) branch's head commit, and &quot;conflict&quot; is mapped to a Set of files' file names that conflict after merging. For file names in the Set need to be checked, Add to &quot;other&quot;'s value Set if the version of such file in the split commit is the same of it in the current commit (has the same content or both not exists). Add to &quot;conflictt&quot;'s value Set if the version in the split commit, the current commit, and the other branch's head commit is all different from each other. Perform checks for the merge command Abort merging if a branch with the given name does not exist. Abort merging if there are staged additions or removals present. Abort merging if attempting to merge a branch with itself. Exit if the split point is the same commit as the given branch's head commit. The merge is complete. Fast-forward and exit if the split point is the same commit as the current branch. Abort merging if an untracked file in the current commit would be overwritten or deleted by the merge. This is checked after which files will be changed is determined. Abort merging if there are unstaged changes to file that would be changed by the merge. This is checked after which files will be changed is determined. Modify the CWD for merging, make merge Commit The Map recoding necessary modification is disassembled into two Sets (one holding file names that should be changed to their version in the given branch's head commit, and one holding file names that resulting in conflicts). Two helper methods are utilized to carry out the modifications. The changes will be staged immediately. Making a merge Commit is not so different from making a normal commit, despite the new commit will have two parent commit IDs, the first is the current commit ID and the second is the ID of the given branch's head commit. Lastly, Gitlet will print a message to the console if any conflict is made. Remote commands Commands related with remote repository requires reuse of existing code for the local repository. To fulfill this demand, static variables (such as CWD, or GITLET_DIR) in the Repository class are no longer final and will be assigned each time. That is, when executing commands on the local repository, static variables will be assigned normally; while executing commands on the remote repository, these static variables will be assigned according to the remote working directory, thus reuse the existing code to manipulating the remote repository. add and remove a remote This command only involved manipulation to the local repository (creating path reference to the remote repository). push command Get the Commit object of the local repository's head commit and the front commit of the remote repository's given branch. Create a new branch at the remote repository if such branch does not exist. Calculate the commits need to be pushed by contracting the ancestors of the two commits. Push the Commits (and their associating Tree and Blob) to the remote repository. Specifically, using the caching and writing back mechanisms developed for the local repository. Commit's IDs are added to the remote allCommitsID file upon pushing. Reset the remote repository (change it to the given branch and fast-forward that branch). fetch command Get the Commit object of the local repository's fetched branch's head commit and the head commit of the remote repository's designated branch. Calculate the commits need to be fetched by contracting the ancestors of the two commits. Fetch the Commits (and their associating Tree and Blob) to the local repository. Specifically, using the caching and writing back mechanisms of the local repository. Commit's IDs are added to the local allCommitsID file upon fetching. pull command This command is executed simply fetch the designated remote branch using the fetch command, and then merge the fetched branch into the current branch using the merge command. Persistence The directory structure looks like this: CWD &lt;==== Whatever the current working directory is └── .gitlet &lt;==== All persistant data is stored within here ├── HEAD &lt;==== The name of the current branch ├── STAGE &lt;==== A hash pointer to the serialized staging area Tree ├── allCommitsID &lt;==== A serialized Tree that contains all commits' IDs ├── objects &lt;==== The object database (all HashObject lives here) │ ├── d9 &lt;==== Saves all HashObject with ID stating with &quot;d9&quot; │ │ ├── 91f6cad12cc1bfb64791e893fa01ac5bf8358e &lt;==== A saved HashObject, named after its ID without the first two letters │ │ └── ... │ └── ... ├── branches &lt;==== Store all the branch references │ ├── R1 &lt;==== Directory of branches fetched from a remote repository │ │ ├── master &lt;==== A branch fetched from a remote, will be displayed as &quot;R1/master&quot; │ │ └── ... │ ├── master &lt;==== The default branch. Contains a hash pointer to a commit │ └── ... └── remotes &lt;==== Store all the remote references ├── R1 &lt;==== A remote references in String, e.g. [remote directory]/.gitlet └── ... Commands init command The Repository.setUpPersistence() method will set up all persistence. It will: Abort if there is already a Gitlet version-control system in the current directory Create .gitlet/branches and .gitlet/objects folders Create .gitlet/HEAD, .gitlet/STAGE, and .gitlet/allCommitsID After setting up all persistence, the init command will do its jobs. Finally, all changes that should be persistent (including branching, HEAD, new commit, and Tree for that commit) will be written to filesystem automatically by the Cache.writeBack method invoked in Main.main(String[] args). add command This command will modify persistence in the following two cases: If the current version of the added file is identical to the version in the latest commit, that file will be removed from the staging area if it is already there. (as can happen when a file is changed, added, and then changed back to its original version) If case 1 isn't happening and the added file is different from the version that is already in the staging area (if it exists), a new staging area containing the added file is saved to filesystem. commit command The commit command will modify persistence following the following rules (no pun intended): Save a serialized Commit object in the object database Overwrite the current branch's file, make it contains the new commit's ID Make a new staging area and overwrite the STAGE file Record the new commits' ID to .gitlet/allCommitsID Delete the previous staging area if it is not empty, and there is a commit already (subtle bug may exist) rm command The rm command will change the current staging area Tree if the designated file is added (removing from the staging area) or exists in the head commit (staging for removal). checkout command This command will write the current working directory, but only read persistence. An exception is that when checking out to a branch, the staging area will be cleared. branch command When a branch is created, a branchName - CommitID pair will be written into the cachedBranches data structure. Upon exit, the cachedBranches will be written back to the filesystem, i.e. the persistence will be modified according to cached information. rm-branch command When a branch is removed, the corresponding file under the .gitlet/branches directory will be deleted. reset command This command will write the current working directory and clear the staging area. merge command If the merging is carried out successfully, this command will change the persistence just like the commit command. add-remote and rm-remote command These two commands will create/delete files in .gitlet/remotes/ directory. push, fetch, and pull command These two commands will add serialized HashObject to the object database, as well as the branch files, the .gitlet/HEAD file, and the .gitlet/allCommitsID file. ","link":"https://311zzb.github.io/post/gitlet-design-document/"},{"title":"Subtype polymorphism in Java: Overriding vs. Overloading","content":"Subtype polymorphism (providing a single interface to entities of different types) and dynamic type selection (DMS) might be one of the most obscure part for Java beginners like me. Here I am trying to write an article on this topic gathering my solutions and approaches to problems in such topic. Disclaimer: Most materials and examples are collected from University of California Berkeley CS61b Spring 2021. Copyright belongs to the original author. What are overriding and overloading Overriding: if a “subclass” has a method with the exact same signatures as in the “superclass”, we say the subclass overrides the method. Overloading: methods with the same name but different signatures are overloaded. The signature of a method is composed of a name and the number, type, and order of its parameters. However, return types, thrown exceptions, and names of parameters are not included in signature. A subtle point is that there is no “one method overloads another method”. Methods in an overloading situation are like siblings instead of parent and children for an overriding scenario. /* abs is overloaded */ public class Math { public int abs(int a) { } public double abs(double a) { } public interface Animal { public void makeNoise(); } /* makeNoise is overloaded */ public class Dog implements Animal { public void makeNoise(Dog x) { System.out.print(&quot;Woof&quot;); } } /* Pig overrides makeNoise() */ public class Pig implements Animal { @Override public void makeNoise() { System.out.print(“oink”); } } Static and dynamic type An variable’s static type is specified when the variable is declared, and is determined at compile time. On the other hand, dynamic type is specified when the variable is instantiated, and is determined at runtime. The static type of an variable can never change along the course of running the program, but its dynamic type could be modified by assigning. Thing a; a = new Fox(); Animal b = (Animal) a; Fox c = (Fox) b; a = new Squid(); The static and dynamic types of variables after running the above code would be: Static type Dynamic type a Thing Squid b Animal Fox c Fox Fox As a reminder, what equal assignment does in Java is just “copying bits”. And any reference type objects is stored in the variable as a pointer to its actual address. This is to say, when assigning primitive type objects, such as Integer, Java copy the actual “thing”. On the other hand, Java only copy the address of the referential object to what is on the left side of the equal sign. Therefore, variable b is holding the address of a after we assign a to b on line 3. This is originally invalid consider (static type of) a is a Thing but b is an Animal, but the casting (Animal) is making the compiler considering a as an Animal type, thus avoiding a compile error. At runtime, the casting is smoothly carried out given the fact that Fox is an Animal, and the variable b is now holding the address of the same Fox object as a. Dynamic method selection The rule of DMS is straight forward: if we have a static type X, and a dynamic type Y, then if Y overrides the method from X, then on runtime, we use the method in Y instead. We can also think about DMS as a 2 step process, where step 1 happens at compile time, and step 2 happens at runtime. At compile time: We determine the signature S of the method to be called. S is decided using ONLY static types. At runtime: The dynamic type of the invoking object uses its method with this exact signature S. By “invoking object”, we mean the object whose method is invoked. Let’s try it out. public interface Animal { default void greet(Animal a) { print(&quot;hello animal&quot;); } default void sniff(Animal a) { print(&quot;sniff animal&quot;); } default void praise(Animal a) { print(&quot;u r cool animal&quot;); } } public class Dog implements Animal { @Override void sniff(Animal a) { print(&quot;dog sniff animal&quot;); } void praise(Dog a) { print(&quot;u r cool dog&quot;); } public static void main(String[] args) { Animal a = new Dog(); Dog d = new Dog(); a.greet(d); a.sniff(d); d.praise(d); a.praise(d); } } The first step to figure out what is going to be displayed is to write down the types. Static type Dynamic type a Animal Dog d Dog Dog After that, let's write down the signature of each call at compile time based on the invoking objects’ static types. a.greet(d); // greet(Animal a) a.sniff(d); // sniff(Animal a) d.praise(d); // praise(Dog a) a.praise(d); // praise(Animal a) Lasty, we call the invoking objects’ dynamic type’s method with the same signature we write down previously. a.greet(d); // greet(Animal a) -&gt; “hello animal” a.sniff(d); // sniff(Animal a) -&gt; “dog sniff animal” d.praise(d); // praise(Dog a) -&gt; “u r cool dog” a.praise(d); // praise(Animal a) -&gt; “u r cool animal” The tricky part here is that praise(Animal a) in Animal interface and praise(Dog a) in Dog class are overloading, instead of the latter one overrides the other one. In such case, no DMS is happening. Note that in this example, the type of parameter is trivial, as d has the same static type and dynamic type Dog, and Dog is a “Subclass” of Animal so it can be feed into a Animal type variable. Just for fun Bird and Falcon What gets printed after running the following code? public class Bird { public void gulgate(Bird b) { System.out.println(&quot;BiGulBi&quot;); } } public class Falcon extends Bird { public void gulgate(Falcon f) { System.out.println(&quot;FaGulFa&quot;); } } Bird bird = new Falcon(); Falcon falcon = (Falcon) bird; bird.gulgate(falcon); falcon.gulgate(falcon); Static type Dynamic type bird Bird Falcon falcon Falcon Falcon Note that casting won’t change an object’s type, all it do is making the compiler believe the type of whatever after the casting is as stated inside the brackets. Bird bird = new Falcon(); Falcon falcon = (Falcon) bird; bird.gulgate(falcon); // gulgate(Bird b) -&gt; &quot;BiGulBi&quot; falcon.gulgate(falcon); // gulgate(Falcon f) -&gt; &quot;FaGulFa&quot; No DMS happens in this example. Dog and ShowDog For each assignment, decide if it causes a compile error. For each call to bark, decide what is printed or Java throw a syntax error. public class Dog { public String name; public int height; public Dog(String name, int height) { name = name; height = height; } public static void bark() { System.out.println(&quot;Woof!&quot;); } } public class ShowDog extends Dog { @Override public static void bark() { System.out.println(&quot;Yo! What's up!&quot;); } } Static type Dynamic type o2 Object ShowDog sdx ShowDog ShowDog dx Dog ShowDog ((Dog) o2) Dog ShowDog o3 Object ShowDog Object o2 = new ShowDog(&quot;Mortimer&quot;, 25); ShowDog sdx = ((ShowDog) o2); sdx.bark(); // bark() -&gt; &quot;Yo! What's up!&quot; Dog dx = ((Dog) o2); dx.bark(); // bark() -&gt; &quot;Yo! What's up!&quot; ((Dog) o2).bark(); // bark() -&gt; &quot;Yo! What's up!&quot; Object o3 = (Dog) o2; o3.bark(); // compile error In fact, every time when bark() is invoked, the overriding method in the ShowDog class is used. By the way, o3.bark() won’t compile because the compiler think there is no bark() method for an Object (o3’s static type), despite both you and I know o3 is actually a ShowDog with a bark() method. That is how the compiler works. One way to debug this is to cast o3 to types that have bark() method. For example, we can write ((ShowDog) o3).bark(). Even more fun Raining cats and dogs Below, four classes are defined. What would Java do after executing the main method in the TestAnimal class? Next to each blank, if something is printed write it down. If there is an error, write whether it is a runtime error or compile time error, and then proceed through the rest of the code as if the erroneous line were not there. public class Animal { public String name, noise; public int age; public Animal(String name, int age) { this.name = name; this.age = age; this.noise = &quot;Huh?&quot;; } public void greet() {System.out.println(&quot;Animal &quot; + name + &quot; says: &quot; + this.noise);} public void play() {System.out.println(&quot;Woo it is so much fun being an animal!&quot;)} } public class Cat extends Animal { public Cat(String name, int age) { super(name, age); this.noise = &quot;Meow!&quot;; } @Override public void greet() {System.out.println(&quot;Cat &quot; + name + &quot; says: &quot; + this.noise);} public void play(String expr) {System.out.println(&quot;Woo it is so much fun being a cat!&quot; + expr)} } public class Dog extends Animal { public Dog(String name, int age) { super(name, age); noise = &quot;Woof!&quot;; } @Override public void greet() {System.out.println(&quot;Dog &quot; + name + &quot; says: &quot; + this.noise);} public void play(int happiness) { if (happiness &gt; 10) { System.out.println(&quot;Woo it is so much fun being a dog!&quot;) } } } public class TestAnimal { public static void main(String[] args) { Animal a = new Animal(&quot;Pluto&quot;, 10); Cat c = new Cat(&quot;Garfield&quot;, 6); Dog d = new Dog(&quot;Fido&quot;, 4); a.greet(); // ______________________ c.greet(); // ______________________ d.greet(); // ______________________ c.play(); // ______________________ c.play(&quot;:)&quot;) // ______________________ a = c; ((Cat) a).greet(); // ______________________ ((Cat) a).play(&quot;:D&quot;); // ______________________ a.play(14); // ______________________ ((Dog) a).play(12); // ______________________ a.greet(); // ______________________ c = a; // ______________________ } } After executing the first 3 lines in TestAnimal.main, variables has static types and dynamic types as below: Static type Dynamic type a Animal Animal c Cat Cat d Dog Dog After all execution, their types are (assuming the last line is fixed): Static type Dynamic type a Animal Cat c Cat Cat d Dog Dog a.greet(); // greet() -&gt; &quot;Animal Pluto says: Huh?&quot; c.greet(); // greet() -&gt; &quot;Cat Garfield says: Meow!&quot; d.greet(); // greet() -&gt; &quot;Dog Fido says: Woof!&quot; c.play(); // play() -&gt; &quot;Woo it is so much fun being an animal!&quot; c.play(&quot;:)&quot;) // play(String expr) -&gt; &quot;Woo it is so much fun being a cat!:)&quot; a = c; ((Cat) a).greet(); // greet() -&gt; &quot;Cat Garfield says: Meow!&quot; ((Cat) a).play(&quot;:D&quot;); // play(String expr) -&gt; &quot;Woo it is so much fun being a cat!:D&quot; a.play(14); // Compile Error ((Dog) a).play(12); // play(int happiness) -&gt; Runtime Error a.greet(); // greet() -&gt; &quot;Cat Garfield says: Meow!&quot; c = a; // Compile Error One possible fix for the last line c = a; is to perform a cast c = (Cat) a. This line triggers a compile error due to the fact that Animal is a “Superclass” of Cat, and assigning an object from the “Superclass” to its “Subclass” won’t compile, even if we all know that a is actually a Cat, rather than other Animal that can’t fit in a Cat variable. By casting, we tell the compiler just trust that a is a Cat, and everything goes fine. An exercise in inheritance misery Cross out any lines that result in compiler errors, as well as subsequent lines that would fail because of the compiler error. Put an X through runtime errors (if any). Don’t just limit your search to main, there could be errors in classes A,B,C. What does D.main output after removing these lines? public class A { public int x = 5; public void m1() { System.out.println(&quot;Am1-&gt; &quot; + x); } public void m2() { System.out.println(&quot;Am2-&gt; &quot; + this.x); } public void update() { x = 99; } } public class B extends A { public void m2() { System.out.println(&quot;Bm2-&gt; &quot; + x); } public void m2(int y) { System.out.println(&quot;Bm2y-&gt; &quot; + y); } public void m3() { System.out.println(&quot;Bm3-&gt; &quot; + &quot;called&quot;); } } public class C extends B { public int y = x + 1; public void m2() { System.out.println(&quot;Cm2-&gt; &quot; + super.x); } public void m4() { System.out.println(&quot;Cm4-&gt; &quot; + super.super.x); } // super.super is not allowed in java public void m5() { System.out.println(&quot;Cm5-&gt; &quot; + y); } } public class D { public static void main (String[] args) { B a0 = new A(); a0.m1(); a0.m2(16); A b0 = new B(); System.out.println(b0.x); b0.m1(); b0.m2(); b0.m2(61); B b1 = new B(); b1.m2(61); b1.m3(); A c0 = new C(); c0.m2(); C c1 = (A) new C(); A a1 = (A) c0; C c2 = (C) a1; c2.m3(); c2.m4(); c2.m5(); ((C) c0).m3(); (C) c0.m2(); b0.update(); b0.m1(); } } Static type Dynamic type b0 A B b1 B B c0 A C a1 A C c2 C C ((C) c0) C C // B a0 = new A(); Compile Error, can't assign an A object to a B variable // a0.m1(); // a0.m2(16); A b0 = new B(); System.out.println(b0.x); // 5 b0.m1(); // m1() -&gt; &quot;Am1-&gt; 5&quot; b0.m2(); // m2() -&gt; &quot;Bm2-&gt; 5&quot; // b0.m2(61); Compile Error, m2(int y) is not defined in class A B b1 = new B(); b1.m2(61); // m2(int y) -&gt; &quot;Bm2y-&gt; 61&quot; b1.m3(); // m3() -&gt; &quot;Bm3-&gt; called&quot; A c0 = new C(); c0.m2(); // m2() -&gt; &quot;Cm2-&gt; 5&quot; // C c1 = (A) new C(); Compile Error, can't assign an A object to a C variable A a1 = (A) c0; C c2 = (C) a1; c2.m3(); // m3() -&gt; &quot;Bm3-&gt; called&quot; // c2.m4(); C.m4() is invalid c2.m5(); // m5() -&gt; &quot;Cm5-&gt; 6&quot; ((C) c0).m3(); // m3() -&gt; &quot;Bm3-&gt; called&quot; // (C) c0.m2(); Compile Error, can't cast a void to C class b0.update(); // update() -&gt; b0.m1(); // m1() -&gt; &quot;Am1-&gt; 99&quot; Ecstasy Athletes Suppose we have the Person, Athlete, and SoccerPlayer classes defined below. class Person { void speakTo(Person other) { System.out.println(&quot;kudos&quot;); } void watch(SoccerPlayer other) { System.out.println(&quot;wow&quot;); } } class Athlete extends Person { void speakTo(Athlete other) { System.out.println(&quot;take notes&quot;); } void watch(Athlete other) { System.out.println(&quot;game on&quot;); } } class SoccerPlayer extends Athlete { void speakTo(Athlete other) { System.out.println(&quot;respect&quot;); } void speakTo(Person other) { System.out.println(&quot;hmph&quot;); } } For each line below, write what, if anything, is printed after its execution. Write CE if there is a compiler error and RE if there is a runtime error. If a line errors, continue executing the rest of the lines. Person itai = new Person(); // SoccerPlayer shivani = new Person(); // Athlete sohum = new SoccerPlayer(); // Person jack = new Athlete(); // Athlete anjali = new Athlete(); // SoccerPlayer chirasree = new SoccerPlayer(); // itai.watch(chirasree); // jack.watch(sohum); // itai.speakTo(sohum); // jack.speakTo(anjali); // anjali.speakTo(chirasree); // sohum.speakTo(itai); // chirasree.speakTo((SoccerPlayer) sohum); // sohum.watch(itai); // sohum.watch((Athlete) itai); // ((Athlete) jack).speakTo(anjali); // ((SoccerPlayer) jack).speakTo(chirasree); // ((Person) chirasree).speakTo(itai); // Static type Dynamic type itai Person Person sohum Athlete SoccerPlayer jack Person Athlete anjali Athlete Athlete chirasree SoccerPlayer SoccerPlayer Person itai = new Person(); // SoccerPlayer shivani = new Person(); // CE Athlete sohum = new SoccerPlayer(); // Person jack = new Athlete(); // Athlete anjali = new Athlete(); // SoccerPlayer chirasree = new SoccerPlayer(); // itai.watch(chirasree); // watch(SoccerPlayer other) -&gt; &quot;wow&quot; jack.watch(sohum); // CE itai.speakTo(sohum); // speakTo(Person other) -&gt; &quot;kudos&quot; jack.speakTo(anjali); // speakTo(Person other) -&gt; &quot;kudos&quot; anjali.speakTo(chirasree); // speakTo(Athlete other) -&gt; &quot;take notes&quot; sohum.speakTo(itai); // speakTo(Person other) -&gt; &quot;hmph&quot; chirasree.speakTo((SoccerPlayer) sohum); // speakTo(Athlete other) -&gt; &quot;respect&quot; sohum.watch(itai); // CE sohum.watch((Athlete) itai); // RE ((Athlete) jack).speakTo(anjali); // speakTo(Athlete other) -&gt; &quot;take notes&quot; ((SoccerPlayer) jack).speakTo(chirasree); // RE ((Person) chirasree).speakTo(itai); // speakTo(Person other) -&gt; &quot;hmph&quot; Note that, when a method is invoked, the number of actual arguments and the compile-time types of the arguments are used, at compile time, to determine the signature of the method that will be invoked. Challenge: a puzzle Consider the partially filled classes for A and B as defined below: public class A { public static void main(String[] args) { ___ y = new ___(); ___ z = new ___(); } int fish(A other) { return 1; } int fish(B other) { return 2; } } class B extends A { @Override int fish(B other) { return 3; } } Note that the only missing pieces of the classes above are static/dynamic types! Fill in the four blanks with the appropriate static/dynamic type — A or B — such that the following are true: y.fish(z) equals z.fish(z) z.fish(y) equals y.fish(y) z.fish(z) does not equal y.fish(y) To approach this puzzle, we can firstly enumerate all possible combinations of types y and z, in terms of the value returned when calling the fish method. Static A Static B Static A Dynamic B 1 3 Static A Dynamic B 1 2 Static B Dynamic B 1 3 Where the head column referring to the invoking object types, and the head row referring to the parameter static type. Because static type B dynamic type A will cause a compile error, so there are only three rows. Further, as signature of method to be invoked considers parameter’s static type rather than both static and dynamic type, there are only two columns. Given the three statements, z and y should have types shown as follow: Static Dynamic y A B z B B Therefore, the answer for this puzzle should be: public static void main(String[] args) { A y = new B(); B z = new B(); } ","link":"https://311zzb.github.io/post/subtype-polymorphism/"},{"title":"Personal Finance","content":"概述 在这篇文章中我阐述了自己的财务管理（包括记账和财务分析）系统。我不是会计专业的，也没什么经济知识，只是被想要财富自由的欲望驱动着随便搞着试试的。不过我感觉确实得在这方面多学习，尤其是写不出来和看不懂别人文章的时候。 版本记录： 2022.01.13 第一个版本发布：初步写完了记账部分 什么是个人会计 会计学（Accounting）是以研究人类的财务活动和成本资料的收集、分类、综合、分析和解释的基础上形成协助决策的资讯系统，以有效地管理经济的一门应用学科，可以说它是社会学科的组成部分，也是一门重要的管理学科。 很明显，个人会计指代在个人的层面上进行会计活动。这个词有时会指代以个人名义进行活动的会计师，但在本文中，我们把“个人会计”定义为对自己的财务活动的研究，以及对成本资料的收集、分类、综合、分析和解释，并形成协助决策的资讯系统，以有效地管理个人财务。 什么是财务 财务（Finance）是指国民经济各部门、各单位在物质资料再生产过程中客观存在的资金运动及资金运动过程中所体现的经济关系。 在个人层面，财务则指代与其相关的经济活动中的资金运动与状况。在企业中，可能会计、财务分析、财务管理是多个团队分别负责，但绝大多数个人的财务只有其本人负责。通过财务分析，可以更有效地进行财务管理。 为什么需要个人会计和财务分析 作为个人，我们应该利用会计和财务的方法论来进行自我管理，这不需要雇佣专门的会计与财务分析、管理人员，而且也是我们在财富自由的路上必需的技能。绝大部分公司都有专门的会计与财务管理，是因为公司需要对它们的利益相关者负责；但说到个人，就连认真记账的人也只占少数（尤其在年轻群体中），这是因为大家并不想面对更多压力——如果生活质量没有被明显影响，你会研究自己这个月是不是又多花钱了吗？ 但也有不少人在感到经济压力的时候开始记账了，但很可惜，一是他们中的不少人早已进入了支出约等于收入的“老鼠赛跑”循环，二是很多人永远停留在“流量记账”（也就是流水账），这让他们的记账变成了仅仅是安慰自己的劳动，其数据难以进行分析和解释，更不用说在记账的基础上形成资讯系统从而改善财务状况了。 财务自由 财务自由是指你工作并不为了钱，而钱完全够用的状态。只要你的资产产生的被动收入等于或超过你的日常开支。如果进入这种状态，我们就可以称之为退休或其他各种名称。只要不发生什么重大的灾难，你就可以生活下去，当然如果你喜欢你的工作也可以继续干下去，或者你可以选择你自己真正喜欢做的事，而不是为生活所迫地做那些你不乐意却又无可奈何要做的事。 下面各项是实现财务自由的标准原则： 创造资产 减少负债 管理日常开支 财务自由跟你是否年轻或有多少钱无关。如果你能从本职工作以外的途径赚到足够你日常开销的钱，你就已经财务自由了。年龄可能跟财务自由无关，假设你现年25岁，每月开支1000块钱，你的资产每月产生1001块钱的被动收入，你就财务自由了，你可以选择你想做的事情，而不必担心下一顿吃什么或者住哪里。假设你现年50岁，月入百万，但每月开销超过百万，那你仍然没能达到财务自由，你仍然不得不继续月入百万地这么维持下去。 企业的目的是为企业的控制人牟取利润，但每个人活在世界上的目的都不同。但明显的是，不少目的都是需要钱、需要时间才有可能实现的，如果为了获得足够的金钱而去投入一生的时间，是否与你的终极目的相悖呢？我觉得财务自由应该是每个人都可以追求的，个人终极目标中的第一项——将自己从金钱与时间的悲惨交易中解放出来，把金钱和时间一起投入更重要的事情中去。 举一个理想的例子。想象一个点击游戏：玩家每点击一次屏幕就可以获得1金币，金币又可以用来制造和升级制造金币的机器。在一开始，你一分钟就可以点出机器一个月才能制造的数量，但随着升级机器的次数越来越多，你自己点屏幕赚的那点儿金币在机器面前不足一提的那天一定会到来。 话说回来。个人会计可以帮我们了解日常开支、资产和负债的情况，财务分析可以帮助我们寻找和理解如何更好地科学管理日常开支、创造资产、减少负债。退一步说，我们至少得在被动收入超过开支的时候知道已经财富自由了。我想这就是进行个人会计和财务分析的理由。 个人会计与分析流程 在实际操作中，我们利用移动端app（本文使用My Budget Book）进行会计数据的收集与初步分类整理，在单位时间周期（比如一季度或是一年）的末尾用Excel制作财报、进行分析、形成资讯，优化下一个周期的财务行为和会计系统。 指标 为了避免花费时间记录无法为决策提供参考的“流水账”，我们需要在会计周期开始前确定需要从下一个周期获取哪些指标，从而指导财报的项目设置，进而指导日常记账的账户、分组等等具体设置。想获取哪些指标依据的是想知道哪些信息。举个例子，我现在比较想知道我的： 总收入和支出、净收入 总资产和负债、净资产 赚钱速度、赚钱加速度 花钱速度、花钱加速度 净资产收益率 躺着赚钱程度 现在停止一切工作的话能维持现有生活多久 预计多久之后可以财富自由 总体风险 短期资金压力 收入的流向 (energy flow chart) 各个方面支出的比率 必需、可选、非必需支出的比率 ... 它们分别对应了： 总收入和支出、总收入 - 支出 总资产和负债、总资产 - 负债 净收入 / 净资产、净收入环比变化率 支出 / 净资产、支出环比变化率 被动收入 / 净资产 被动收入 / 主动收入 净资产 / max (支出 - 被动收入, 0) log (支出 / 净资产*净资产收益率) / log ((1+ 赚钱速度) / (1 + 花钱加速度)) 负债 / 总资产 支出 / 高流动性资产 支出 / 收入、储蓄 / 收入、投资 / 收入 支出一级分类 / 支出 支出二级分类 / 支出 ... 会计 在这一小节中，我们讨论在生活中如何具体地对自己的财务活动进行会计。由于人与人之间的情况大相径庭，所以收入、支出模式的现金流分类见仁见智。在介绍我的分类之前，我们有必要理解资产与负债的主要类别。 资产 资产是钱或是能不断把钱放进你口袋里的东西。虽然这与严谨的定义不尽相同，但既然是以财富自由为目标的记账，那么购买更多的资产从而累积被动收入就变得极其重要，所以这里我们把资产仅定义为能有效地变现或是能盈利的东西。 货币资产 货币资产指随时可以用于支出或等待支出的现金及其等价物，是流动性最强的资产。货币、活期储蓄、货币基金都属于这种资产。货币资产可以随时调用，代表了短期的支付能力，日常的支出也是从货币资产中流出的，所以适合作为记账的主账户。 值得注意的是，储值卡、饭卡、公交卡和游戏点卡等账户，由于难以变现，所以不应该算作任何资产。应该在充值时一次性记为支出。另外，使用支付日常开销的信用卡进行支付的时候也应该记在货币资产的账户中（拖到最后一天全款还信用卡，赚还款的时间成本），此时你的账本会比银行app或是支付宝显示的余额更加可信：它表示你的净货币资产。还信用卡时无需再次记录。 我们将不同平台上的同质资产记在一起，这在简化记账的复杂度（不需要每笔交易都标记是从什么卡划走的了）的同时，保证了后期的财务分析不受影响。 金融资产 金融资产指用于或准备用于获取被动收入的资产，是达到财务自由的关键。虽然有些金融资产的流动性甚至比货币资产还好（甚至就是货币，如加密货币），但只要目的是获取被动收入，就应当划分为金融资产。反过来说，有的资产可能与金融没什么关系，但只要可以帮你获取被动收入，就应该视为金融资产（比如用于出租或是等待升值的房地产）。金融资产的总和代表了你有多少资产在帮你赚钱。 权益资产 权益资产在个人层面可以指别人欠的钱、养老金账户里的钱、保险里的钱、你妈帮你存着的压岁钱等等。这些资产无法用于支出、收回的可能性不一，也不一定产生现金被动收入，很多时候不算做资产。 固定资产 在你破产时可以被拍卖的资产，包括车、房、贵重物品等等。这类物品一般难以准确估值而且不会主动卖出，所以其实并不适合算作资产。 负债 负债指的是能不断地从你口袋里拿走钱的东西。 生活开销如果使用信用卡或是电子信用卡，出于简化记账的考虑，若免息或是能在计息日开始之前还清便不算作是负债（消费时直接从货币资产中扣除）。反之，如果负债会产生利息，则需要记录为负债，此时应当尽快还清，减少利息的产生（如果可以减少的话）。如果是诸如房贷或车贷之类的长期负债，也应该记录。但说到底，在负债开始前就应该郑重考虑，并且合理安排借款量和还款的周期，防止负债侵蚀资产，拖慢财富自由的进度。 记账 记账方式之间的区别 使用不同的方式去记账可以在很大程度上影响是否能进行财务分析以及财务分析帮助决策的能力。最朴素的记账方法是流水账，或者说流量记账（收付实现制）。这种方法是在钱到手和出手的时候记录金额与方向，细致一点的会根据目的/来源进行分类，但至于流入和流出金额的性质并不做区分。这种方法的优点是易于理解和执行，同时可以用于监控最主要的财务数据：现金流。 然而，有一种更好的记账方法则叫权益记账（权责发生制），相比于流量记账，更注重于资金的消亡和转移中的逻辑，以及权力责任周期匹配。这是什么意思呢？举个例子，在使用信用卡进行多次日常消费之后，在还款日之前一次性还款。这一系列行为使用收付实现制记录的话，只需要在还款的时候记录一次即可，因为还款之后款项才实际地进行了转移；而权责发生制则需要每一次实际消费时都进行记录，因为在消费时（付款的）责任就已经产生，实际的款项成为了应付账款，实际的还款行为没有增加新的权益或者责任所以不进行记录。 由于我们的消费不是一次而是多次进行，每次分开记录有助于反应真实的消费模式，明显收付实现制不能完全做到这一点，因此权责发生制是现代会计准则的要求。个人记账通常不能完全理解两种方式的异同，导致不经意间的混用，而混用不同逻辑的记账方法很容易进一步导致逻辑矛盾，帐就记不清楚了。我们使只用权责发生制的权益记账。 收入的分类 收入可以分为主动收入、被动收入、以及意外收入。由于收入产生的频率可能并不像支出那么频繁，所以我们不在移动端的记账app内记录收入，而是每次产生收入时用Excel记录。我们在记账app内只设立一个日常开销账户及短期应急账户，分别在每个周期开始时或是得到收入时分别补充/削减至一个周期的平均开销和三至六个周期的平均开销，在周期结束时把剩日常开销账户中剩余的资金划转到短期应急账户。这两种资产都是不用于投资的货币资产。 需要购买昂贵物品时只从短期应急账户扣款，并在下个周期补充短期应急账户。如果金额大于短期应急账户的资产，则分多期将短期应急账户充值到目标金额再进行消费。在被动收入变得可观之前，不允许将金融资产转回货币资产账户。 支出的分类 为了让支出的一级和二级分类不过于具体又不过于抽象并且能够有效提供决策依据，我们把一级分为这几个涵盖生活方方面面的大类： 居家：租金、房贷、家用电器、家庭维修、装修、水电费、燃气费、物业费 交通：汽油、车贷、车票、月卡、车辆维修保养 食物：食材、外卖、餐饮 健康：挂号、药物、牙刷牙膏 生活：洗发水、衣物、鞋、洗衣粉、毛巾、话费、眼镜、水杯、手机、理发 成长：书、网课、付费问答、学费、电脑 娱乐：书、演唱会门票、聚餐、假期、电影、Netflix订阅、游戏、零食饮料 关系：爱人（我没有）、父母、朋友 每个一级分类下，都有这三个二级分类： 必需 · 基础 优化 · 改良 非需 · 奢侈 应该根据逻辑对支出进行分类。举个例子来说，和朋友一起出去看电影所造成的支出，根据逻辑可以分类为娱乐也可以分类为关系：如果很享受就分为娱乐-非需，反之如果是被邀请或碍于面子就分为关系-优化。又或者，食物分类下的必需、优化、非需分别对应了基础食物、为了健康或犒劳自己的食物、零食饮料；健康下的三个子类对应治疗、预防保健、医美。通过根据逻辑将不同大类下的支出性质划分为必需、优化、非需三个子类，可以进行跨大类的分析。 流量的监控 短期支付能力 日常开销账户的余额监控当前周期还有多少预算，与短期应急账户的余额的总和即为短期的支付能力。顺便一提，政府的财政预算在财政年没有花完的话，不仅要上缴剩余的钱，次年的预算还会被削减，可以说政府是被鼓励扩大支出的。但个人把握了自己的预算制定权，减少的支出又可以用于加快财富自由的进度。所以记账会让你对个人资产状况有更清楚的认知，从而对现金流进行合理调整。 整体（周期）的流量 通过对一个周期内总支出、收入的汇总，可以监控整体的流量。考虑使用类似能量流动图的图表进行可视化。 权益变动的记录 有些收入（包括主动、被动收入）有时并不直接表现为货币资金的流入（比如养老金、保险、资本增值等），但权益记账法要求我们需要在权益发生时就进行记录。因此，我们每个周期在Excel内记录一次所有权益和对应的金额（单位为法币）。这样做不影响收入支出的统计，同时也可以保证财务分析时可以掌握权益收入。 分析 未完待续 参考资料 如何利用excel制作个人财务报表？ - 叶秋的回答 - 知乎 有简单好用的记账 app 吗？ - 叶秋的回答 - 知乎 财务分析入门之资产的分类 - 佰亮同学的文章 - 知乎 财务和会计的区别？什么是财务？什么是会计？ - 夜浣瞳的回答 - 知乎 MBA智库 ","link":"https://311zzb.github.io/post/personal-finance/"},{"title":"最好的CS入门课：CS61a学后感","content":"之前看到别人的CS61a学后感时，只觉得学个网课都要写篇文章是不是有点表演型人格了，但我学了几节之后就觉得CS61a简直是文明的福音转码的圣经，为什么没有早点知道有这门课存在？并且陷入了对伯克利的学生的羡慕中（他们大一就学CS61a）。现在我学完了CS61a的（几乎）所有内容，特此写一篇文章记录一下，顺便安利给有缘人。 为什么学CS61a 本来我是看了一亩三分地上的转码帖子，学了斯坦佛的Databases课之后打算学CS61b的，但发现CS61a是CS61b的prerequisite。为了满足心理洁癖（也因为我时间比较充裕），我决定从CS61a学起。 由于当时最新的fa21还没更新完，次新的su21的最后一些录屏看不了，次次新的sp21没一个录屏看得到，于是我就学了fa20。非常感谢UCB把CS61a fa20材料中能公开的都公开了。 CS61a教了什么 这门课是SICP的变种，使用Python 3来展示抽象方法、编程范式和管理大型程序的技术。由于2012年之后的新版CS61a使用Python教学，所以较旧版（使用Scheme教学）更容易入门，也更贴近实际。分章节来说，CS61a主要教了以下这些内容： 用函数构建抽象关系 函数与函数设计 控制 高级函数 递归函数 用数据构建抽象关系 数据抽象 可变数据 面向对象编程 解释(interpreting)计算机程序 函数式编程 异常 解释器的开发 数据处理 声明式编程 我学到了什么 其实在学CS61a之前我也学过算法与数据结构，做过C语言的算法题、用python和java刷过一点leetcode。但一直苦于没有系统性地入门CS，知识点较为零散，没有构建&quot;Computational Thinking&quot;。通过学习CS61a，我感觉多少缓解了这种焦虑。在课程的主要知识点内外，我印象最深刻的内容是这些： 代码如何被解释器执行 调用一个函数时operator和operands的计算顺序、程序执行的frame和environment、可变与不可变数据、多重赋值、nonlocal赋值、异常处理等 Recursive Leap of Faith (递归的信仰之跃) 递归与数学归纳法很像。编写递归程序时，一个base case规定边界条件、一个recursive case规定递归操作。在recursive case中，我们信任这个函数会给出正确的n返回值，再利用返回值去构建n+1的返回值。这种信任被称为&quot;Recursive Leap of Faith&quot;。同样当我们理解、修改递归程序时，不应该试图推演递归调用，而是直接信任它，并在其基础上修改从n到n+1的操作，leave the hard work to the computer。 当然，一定要推演的话可以推演一个递归深度浅的例子。 什么是abstraction (抽象) 赋值、函数、对象等等都是抽象，没有抽象的语言是低级语言。通过抽象，我们可以把问题变为计算、变为对象。这也是面对对象编程的一大优势：问题的场景会自动解决一部分问题，it is what it is. 为什么说LISP是神的编程语言 CS61a教了LISP的一门方言：Scheme。这是一门函数式编程语言（所有函数都没有副作用，纯粹依靠返回值），只有call expression和special form两种语句。但它神奇在于几乎无限的可拓展性：定义函数就不说了；Scheme还可以通过定义宏来定义special form（原理是宏的参数不会在调用之前被evaluate，进而可以控制evaluation的步骤）；而且，Scheme中的数据与程序都是链表，这让编写编写程序的程序变得非常简单，事实上，计算机推导公式与符号计算正是如今lisp的主要应用之一。 解决问题的一般思路 (来自How To Design Programs) 从分析问题到定义数据 阅读问题，寻找必须要被抽象化（表示）的信息，并思考用何种数据结构表示。寻找实际例子。 函数签名、目的描述、以及docstring 思考解决问题的函数的输入与输出，准确描述这个函数在计算什么并撰写docstring。 例子推演 通过例子推演计算的步骤，编写核心的步骤，设计函数的骨架。 函数定义 编写剩下的函数使其能够支撑核心步骤，通过例子意识变量与表达式的实际意义。 测试 使用例子推演函数、并使用doctest测试、修改错误、把程序修改得更为易读。 CS61a好在哪里 能学到知识当然好，但它是否值得我花时间去学呢？我想不少人可能有这样的疑惑。我的回答是YES，这门课在很大程度上增加了我对编写程序的热情，如果没有lab、homework、discussion、project以及其他课程工具的精巧设计，这是不可能的：（几乎）所有题目都有完善的说明、例子、半自动的测试和批改，python tutor可以帮你把python程序的frame可视化，在线interpreter让你可以随时随地互动测试。 最重要的是，CS61a的四个项目里面有三个都是做游戏，这真的很让人兴奋。我还记得我才学完控制和高等函数的时候，就遇到了第一个项目。没想到光是用这么基础的知识就可以编写一个掷骰子游戏hog的核心逻辑、策略。其他几个游戏在这里就不剧透了，它们都很有意思。另外，CS61a中有好几处谐音梗和对pop culture的致敬，其实这些才是我记得最牢的哈哈哈。除此之外，还有一些节目效果拉满的lecture，比如John表演手搓某游戏音乐、讲解对象的多重继承时的抽象一家人伦理小剧场...总之真的很欢乐。 数据 CS61a总共4个project，10个homework，14个discussion，14个lab，38个lecture，261个视频。 我从10月31日到1月11日，总共用了72天学完（几乎）所有可以得到的材料（刚开始的一个月只学了65小时）。学了最长时间的那天是2021年12月31号...在CS61a上用了6小时四十五分钟。有记录的学习时间共计229.08小时，详细数据(Google Spreadsheet)供考虑学CS61a的同学参考。 最后 千言万语难以表达我对这门课的喜爱和对UCB, Dr. John Denero, Dr. Hany Faird的感谢。就以他们的人生建议结束吧。 When I was getting married, I was a PhD student at the time. My mom pulled me aside on my wedding day and said &quot;John I want to give you some advice&quot;. I was like oh she's going to like tell me to listen to my wife or whatever. But she didn't. She said only two words that have stuck with me for a long time. She said &quot;don't compare&quot;. That's all. And then she was like okay you can go back to do whatever you're doing. At the time this was very hard for me to process because I was in a university which is all about comparing people based on like what their exam score was. It turns out that out there in the world, there are no exams that everybody takes that are standardized anymore. All that matter is what you go and get done on your own particular path. So, comparing yourselves to other people becomes meaningless rapidly as what really matter is what you could do yourself, like what you're capable of and what you bother to do and how you choose to spend your time. It took years of this two-word phrase &quot;don't compare&quot; to marinate inside of me and for me to realize that my self-worth really has noting to do with what other people can do or whether I can do it better than them or worse than them. It has everything to do with what i've done and what i'm gonna do next and how I spend my time and better myself. I should just focus on improving myself and forget about what everybody else is doing. (John Denero) It is something that took me a long time in life to understand not to compare. And there's a trap too that we do. We compare for example how big our house is to that one friend and how much money we make to another friend, and the kind of clothes we have to this friend and how smart we are to that friend. We pick and choose these things and that's first of all, even doing that individually is meaningless right? But it's also a trap and this is the problem with social media, you see these sore of curated worlds of other people and it's a trap. One of the great things of getting older is you will get there, I promise, you will realize it's a trap and comparing means absolutely noting. It really is a very internal thing of what are you doing, who do you want to be, how do you want to go through this world, how do you want to treat other people. At the end of the day, that, and almost noting else, is going to matter. And you got to just trust that it's going to be there. (Hany Faird) 如果这篇文章对你有帮助，考虑给我的CS61a fall 2020 repository点个star，谢谢。 ","link":"https://311zzb.github.io/post/zui-hao-de-cs-ru-men-ke-cs61a-xue-hou-gan/"},{"title":"双非转码6个月考取名古屋大学情报学知能システム+東京大学新領域人間環境经验分享","content":"本文共7122字，预计阅读耗时14-24分钟 更新记录： 2021.08.29 更新 5.4 关于考哪些专业的选择 1. 写在前面 笔者虽然小时候就很想留学了，但由于个人见识的限制，也为家里的经济状况和思想观念担心，没有直接要求父母把我送出去。初高中看了挺多二次元，还在某游戏群有幸认识了 @尖锋CF ，不展开说了。高三时跟家里一商量，直接让我上国内的某中外合作大学（笔者高考分数约等于中流211水平），准备硕士再留学（所以其实标题的“双非”还是有点标题党的，不好意思）。由于上的大学是英制，所以我大一时也打算毕业了去英国恰个一年硕，但后来 @尖锋CF 唐突考上东大，成了群友楷模，直接就在我心中种下了一颗去日本留学的种子。大二暑假的时候，笔者出于种种考虑，下定决心要考日本的修士，故事就这么开始了。 时光荏苒，白驹过隙。2021年8月，在经历了一连串预料到与没预料到的酸甜苦辣之后，这一以前根本不敢奢望的目标终于实现。谨以此文感谢前人的帮助，并希望能多少帮上目前正在为了自己的目标而努力的朋友。 笔者今年共出愿了东京大学新领域人间环境、东京大学工学系系创（由于没怎么复习&amp;新领域已经合了所以弃考）、名古屋大学知能系统、东京大学综文广域科学（出愿失败）。考了的两个专攻都合格了，最后决定去东京大学新领域。 2. 个人背景 本科院校：中外合作大学（合作方的QS排名在一百左右） 本科专业：机械学院的Product Design and Manufacture（工业设计） 绩点：4.0/4.0（英制满绩不难） 英语水平：托福89、GRE 150|167|3.5（并没有用上）、本科全英语授课 日语水平：N1 161点 3. 经历 3.1 摸索阶段 2018.04：大一的时候我从学校的数学系转到工业设计了，这个决定虽然挺蠢的，但为了转专业而努力的经历让我有了一个认真学习的惯性。当时要不是为了转专业，本来是打算大学四年随便学学得了。 2018.09：大二开始的时候因为兴趣想学ZBrush，买了本日语书发现完全看不懂，于是在沪江上下血本买了0-N2的课，开始学日语。 2019.08：大二暑假的时候，笔者去上海找了个小公司做工业设计的实习。两个月下来，意识到上海生活有多么贵。闵行的老破小房子竟然一平米五万，不懂为什么有人买。另外我对设计的兴趣开始下降，这个事情的智力活动密度太低，而且做出来的成果很难说有什么意义。实习的时候顺便考了个N2，后来很顺利通过了，感觉学日语还是挺有意思的，所以又在沪江买了个N2-N1的课学着。 2019.09：大三开始做了很多修考相关的情报收集，但其实还是针对设计方向的。也是这段时间在修考群里高强度水，然后知乎上看经验贴什么的，开始对修考具体是个什么概念有了了解。顺便上日亚买了好多经验贴里推荐的修考用书。 2020.08：刚结束在学校做的暑研（开发智能产品）。开始把从东大情报学环的设计到庆应的KMD项目等等各种路子的所需材料、关键时间点、要考试的科目总结起来，最后给自己计划了横跨大四到毕业后一年的八九次入试的日程，现在想想都有点离谱。趁着暑假顺便把MIT OCW的线性代数自学完了。 2020.09：看好了一个东大的教授，开始自己写研究计划书。由于之前几乎没有科研经验，所以花了挺长一段时间阅读文献，然后把研究计划书写了洋洋洒洒三页，然而RP写这么长根本没有必要。不过这个也算是阅读大量文献、学术写作、写RP、用Overleaf的经历。 2020.10：大四开学，不同于国内的很多高校，笔者所在的专业大四上非常之忙，以至于11月之后到次年1月除了抽空申请一下东大IME以外根本没有做其他修考准备的时间。 2020.12：为了东大IME而去考了个GRE，由于几乎没复习所以甚至没有达到IME所要求的Verbal 150，打算寒假重新考。顺便裸考了个N1，后来知道拿了161分。 2021.01：昏天暗地复习GRE，2月1号考了个开头说的那个成绩。IME的后续是教授看完我写了一个月的研究计划书之后轻描淡写地说不好意思我们不做这个方向了。然而他研究室官网都还挂着那个方向的介绍，我伤心了。 2021.02：由于太多次套工学的教授的磁没有回应，打算去套磁九大的工业设计得了。想起来@风见真夏 就在九大，于是微博上找他问了一下情况，结果我们在2月14号那天语音人生相谈了一个多小时，聊完我就下定了转码的决心。谢谢你，风见真夏，你是让我在人生的转折期做了重要决定的人。后来我报了思齐塾，费用在塾里是偏高的。我对于塾的思考在下面细说。 3.2 前期（2月中-5月末） 这个阶段先是跟塾确定了一下目标校，最开始定的是东大的电情、东工的情工、还有早大先进理工的电气情报（后来全换了）。接着就开始在塾里上课了，平均一周5节2小时的课，偶尔也有一周8节的时候，就这样学了线代、微积分、数字电路、自动机与形式语言、计算机组成原理几门课，然后复变函数、算法与数据结构开了头。 由于东大电情对我来说难度太高、早大先进理工的电气情报太早考试而且考试范围与其他几个重复太少所以都换掉了，目标校变成了东大系创、东工情工、名大知能系统。 同时，笔者还在塾的帮助下开始套磁CS的教授。由于专业跨度比较大，所以被回复的情况也不是很乐观。幸运的是与名大的教授约上了面试，是比较随意的私人面，但因为我是第一次跟日本的教授面试所以花了比较多时间认真准备，用英语发表了一下之前暑研做的项目，着重介绍了其中比较CS的部分，还说了在修士阶段打算做什么方向。然后教授在试探了一下我会不会日语（我会）之后看起来比较开心，直接给了个“如果你考上了就要你”的内诺。这件事情当时让我挺开心的。 由于我大四下学期只有一个毕设，而且因为我之前均分高导致毕设稍微摆烂也没关系，所以直接堆时间准备修考了，当时一般每天都会花5小时左右在准备修考上面。塾里的每节课我都会在上完之后重新看一遍录屏并做好笔记，一般来说一节两小时的课我会花四小时左右复习和练习。在我认为知识点比较多、或是比较重要、或我学得不太行的课程结课之后（线代、微积分、概率），我都会花费大量的时间将以往的所有笔记过一遍，再重新写一个总集篇的笔记。这样做的好处一是加深对知识点的印象和理解，二是之后再复习看总集篇就可以了，节省时间精力。 这个阶段笔者也会试着不计时刷一些过去问，找找感觉，并没有大量刷题。 3.3 后期（6月-8月初） 临近各个学校出愿的日期，我又重新考虑了要出愿的学校。当时考虑到东工考的范围广、又要托福成绩单原件、又不一定有线上考（我人在国内并且当时由于日本的签证政策不可能渡日），于是果断放弃考东工，最后决定考三个东大的专业（系创、新领域人环、综文广域科学）加上名大的知能系统。然而最后这波决定做得还是比较仓促：人环的前两轮说明会已经结束了，赶上了第三轮说明会（6月5日）但我最心仪的教授已经收满了外国人特别入试，跟我说如果日语没问题的话走一般入试也一样的。至于东大的综文广域科学，笔者当时打算报大家都很喜欢的金子知適。 在出愿季之前，笔者还把几个准备考的专攻的信息和时间轴（甘特图）都用notion整理好了，这里贴一下截图给大家参考。做好这种整理可以很有效地追踪多个专攻的进度，消解焦虑，因此非常推荐（notion需要科学上网才能访问）。下方甘特图 七月份的时候由于没有掌握好东大综文广域科学出愿的结束时间，还是出愿失败了（具体来说，是是拖到当天下午两点多才发现截止时间不是我本科习惯的23:59而是三点，然后才开始填表啥的，结果漏了一个额外的表单）。这次失败给我当头一棒，吓得我再也没心情打游戏了，开始把几乎所有精力放在准备修考上。不过现在看来没出东大综广其实也挺好的金子知適那里非常地卷，好多考CS的大佬拿他当保底，而且综广的入试本身就相当有难度。 除此之外便是在塾里学剩下的课。这个阶段学了剩下的复变函数、算法与数据结构、概率论与数理统计。笔者由于在本科阶段没学过概率论，所以这方面相当吃力，塾的直播课基本跟不上，所以每次两小时的概率课我都要花八小时仔细看录屏并且做好笔记。后来塾里课都结束两周了我才把概率课的所有笔记搞定、练习刷完。 这段时间还有几天在写东大新领域人间环境的小论文。由于被多次书面及口头要求为入试内容保密，所以没法在这里告诉大家今年小论文的题目，只能说是并不难，就算你完全不会也有足够的时间学好再写。本文末尾也会稍微聊一下人间环境的一些情况。 除了上课之外，在这个阶段我开始有计划地刷题。名大知能システム以及专业拆分之前加起来总共有13年公开的过去问，我把其中所有微积分线代复数解析概率算法（也就是目前会考的范围）全都做了。这个刷题直到考试前两天（8月3号）才全部刷完搞懂。 不过比起过去问，我对于其他材料并没有花很多时间。塾建议我刷微分积分演习，我为了省时间就只看了一遍最后一章的多重积分。还有一本很好的书叫《大学生的概率统计》，我就看了一下其中关于渐化式的部分。 我当时经典的一天的时间安排： 3.4 考试 今年名大的笔试题目比以往更加灵活，虽然依旧是围绕线代微积分复数解析算法，但不少题目都要求考生对知识点有自己的理解而非死记硬背。考后重新看了一遍，我的正确率在75%左右。 3.4.1 解析・線形代数 今年的复数解析考了一道二元一次方程，不算难。但由于涉及到给复数开根号，使用欧拉公式就会发现开一个根号会开出来两个结果，所以总共会有四个解。 微积分考了一道经典的极值问题，无坑。 线代考了名大最喜欢的二次型。但是是带参数的，最后一问问二次型的符号确定，求参数范围，用正定/负定的所有特征值大于零/小于零即可。 今年还考了微分方程，这方面由于名大专业拆分之后到现在都没考过，我以为不会考了就基本没复习。最后还是靠着依稀的记忆勉强做出来了，不难。 3.4.2 確率・統計 今年第一道概率考的是把一段长度为1的线随机切成三段后，存在长度大于0.5的线段的概率。我分了三种情况讨论，实际上最简单的做法应该是把这个一维上的问题放在二维平面上考虑。 第二题考的是随机变量函数的分布，不难。 第三题是比较综合的题型，一共三个小题中，前两小题考了二项分布，后两小题考了对数的计算。尤其是最后一小题考了利用对数比较两个极大数的大小，这个问题是高中知识，但我估计很多人忘记怎么做了。 3.4.3 プログラミング 今年这道算法题偏向于考察C语言的应用，几乎没有考察算法知识，不过比起去年的那个哈希表来说简单不少。这种题目基本只需要认真读题，能快速理解代码在干嘛，外加上经验和直觉就能很快做出来。 但不幸的是最后一小题超过了我的经验范畴，问了一个bug出现的理由，那个需要考虑循环执行的先后顺序。我在考场上就没做出来。 3.4.4 面试 名大面试的形式是三分钟的课题发表。这个课题会在第一天笔试考完之后下发，要求第二天中午围绕课题讲三分钟，并且发表使用的材料只能手绘在A4纸上。由于第二天早上才知道进没进面试，所以建议考完休息一会儿就开始准备，等确认进面试了再准备是来不及的。今年的题目是这个： 機械学習における偏り(bias)と分散(variance)のトレードオフ問題とは何かについて、およ びその対処法について説明せよ。 然后名大突然宣布只有笔试无法决定是否合格的同学才会进入面试，也就是说考得太好或者太不好都不用面试了。 我是先写的稿子再做的发表材料，由于需要手绘材料，所以我先用Powerpoint做了个电子版草稿，满意之后再画在A4纸上，最终效果看起来感觉不错。材料是在我得知进入了面试后才做的。今年知能系统进入面试的有27个人，占全部考生的16.67%。 虽然面试的发表使用日语英语皆可，但我准备了日语的稿子而材料中大量使用英语，感觉这样会看起来比较有说服力的同时让教授听起来不费力。写完稿子之后还和塾里老师开zoom练了一遍。 开始面试。教授先是问了我报考这个专攻的理由，然后又问我想做什么研究。这两个问题我还真没准备，只能凭着以前写自己文书的记忆随便说了几句，还有点结结巴巴的。 接下来课题发表的环节就比较顺利了。发表完之后教授没有对专业知识进行提问，而是直接就开始问我是否愿意调剂到别的研（我说愿意）；又问我有没有报别的学校，我耿直地说了东京大学，但又表示如果都合格了我会来名大，因为这边更CS一点（不好意思，我后来决定果然还是咕了）；接着考官追问我到底报了东大哪个专业，我想说新領域の人間環境，但当时突然一紧张说成新霊域の人間関係了，空气变得有点尴尬；最后教授继续问了我有没有兴趣读博，我说目前还不考虑。然后面试就结束了。 听说别的同学面试有被各种问专业知识直到答不出来的，也许是我的发表把教授打动了（材料生动直观、使用日语、日语口语アクセント没问题且语速快），又或许是因为我之前就跟教授私人面过，所以他完全没刁难我。 8月18号看到合格名单之后，才知道这次名大的知能系统已经卷成了麻花：162名考生中只合格了40人（倍率4.05），其中线上考试的52名考生中仅有3人合格。能够在比往年偏高的倍率下合格让我感觉有点膨胀。后来名大知能52进3（其中2个去东大新领域了）都成梗了哈哈哈，后话不提。 笔者感觉名大的一般入试对不会日语的留学生并不太友好：不仅各种文件基本只有日语，而且听说线上面试用英语做发表的都没有合格（未经核实，仅供参考）。所以说如果打算走名大的一般入试考修士的话，好的日语水平在很大程度上可以变成软实力，多少弥补一些硬实力上的欠缺。 4. おまけ-東大新領域人間環境 今年一般入试仅有30人报名，而人间环境的名额是38，我以为这代表着很容易就能考上，但事实上这38的名额中还包含走特别口述试验的考生，且从结果上来说特别口述试验才是大部分合格考生的来源，所以说不要想当然，一定要好好准备。最后合格的一般入试考生有9人，倍率3.33。 虽然需要为具体的考试内容保密，但考察项目是公开的信息：小论文+口述试验（五分钟脱稿发表&amp;答辩）+面试，均使用日语（夏季的一般入试）。总体来说难度不高，主要考查的是基础知识是否掌握，但对日语水平的要求是客观存在的。推荐日语还可以的同学试试看，入试的时间线非常长（从给课题到面试大概两个月左右），事情也不多，可以做充分的准备。另外，相比于夏季主要考察基础知识的掌握程度，冬季入试的重点放在考生想做的研究上。 如果是决定走一般入试并想先做点什么，你可以：复习高数的时候不仅要知其然还要知其所以然，多对各种概念进行一些自己的思考。另外日语多练练，特别是听力和口语（写作到时候临时弄也来得及）。 后来笔者虽然被新领域人间环境录取，但被调剂到了第七志愿。不过笔者仍然选择去东大，因为我其实根本不在乎研究什么，毕竟我的动机是洗个学历找份好工作赚钱然后赶紧FIRE享受人生，而不是真的搞科研（还是非常尊敬认真搞科研的朋友）。 5. 附录 5.1 关于日语 笔者从18年9月2日才开始正式学日语（在这之前是五十音战士），而这次修考能达到一个还不错的成绩真是多亏了还凑合的日语水平。关于日语的学习我也发了一篇文章，欢迎查看。 5.2 关于私塾 笔者其实一直对私塾（培训班）不屑一顾，因为小时候从来没去过培训班，全是靠学校或者自学，成绩也还可以。但这次修考的经历让我对这件事情有了新的认识：私塾是一项以金钱换时间的服务，可以给你更具体的方向，可以给你学习的绝大部分资源，可以给你一定的安全感...总之，笔者大概思考了一下什么样的情况适合/不适合报私塾，个人观点仅供参考。 如果符合以下情况中的一点或多点，建议你考虑报塾： 较大转向跨考，比如机械转CS 看了下过去问发现连题目都看不懂 不知道自己想研究什么，甚至没有感兴趣的研究方向 备考时间≤半年 自己觉得自己再这样下去要白给了 如果符合以下情况中的一点或多点，建议慎重考虑： 希望对自己的修考有更多的掌握，讨厌他力本願的感觉 觉得只要报了塾跟着上课、说什么都照做就一定能考上 如果决定报塾的话，请务必联系多家塾或者试听后进行比较。这么多塾各有长短，很难断定哪一家就是最好的，但也许会有一家是最适合你的。对了这里插一条广告，如果比较后有兴趣报思齐塾，通过我介绍能便宜一千，有意请联系我。 5.3 关于孤独感 日本留学比起英美澳留学来说很难不算是个小众选择，而这也意味着在现实中认识志同道合朋友的概率低了不少。笔者所在的本科院校是英制的中外合作大学，所以周围70%的同学都计划去英联邦国家，剩下10%去美国，还有20%就业（非准确数字），总之就是很少见到有去日本的。到了大四笔者还换了单人寝室，到大四下由于课少（只有一个毕设）且我复习忙，所以和大学同学的来往变得越来越少。甚至毕业典礼的时候，别人出来都在合影，我出来把学位服一还直接就回宿舍准备第二天某研究室的说明会去了。没有与一些曾经关系很好的大学同学留下合影，说真的有点可惜。这种孤独与异类感或多或少是在准备考试的路上不可避免的，好在我一直都很自闭，早就习惯了。虽然人人的情况都有所不同，但要达成目标就是一件要付出代价的事情。 虽然与大学同学渐行渐远，但好在现在是个网络发达的时代，有几个网上的朋友听我倒垃圾，还是就能在很大程度上消解孤独感。这里我也要特别感谢@FMKz7 等初高中同学、大学学长@酱油 以及gentlemen hub和A岛丧尸舰队（万恶之源，就是在这认识的尖锋）的群友，shitposting属实解压。另外还有修考相关的群也给过我很多的帮助，但请注意不要随意把自己与他人比较或者沉迷水群。 5.4 关于考哪些专业的选择 准备修考是一件及其耗费精力和时间的事情，在定下目标的时候，能否有学上以及能否上梦校就已经在很大程度上确定了。以下是几点从入试角度看选择考哪些专攻的建议，仅供参考： 不要因为很不安就报考过多（大概5个或以上）专攻 选择专业的时候不仅要看是否有中意的研究室，更要看专攻的考试时间、形式与范围、以及合格倍率。有些研究室可以从多个不同的专攻考入，这时如何选择就是一件值得调查与考虑的事情 建议有笔试的专攻最多报两个，而且这两个的考试范围最好重合度较高而学校的档次差距较大 其他入试方法（口述试验、小论文、面试等等入试形式中的一个或多个的组合）可以适当多报，就当摸奖了。但不推荐超过3个 建议收集所有目标专攻往年的入试时间节点，搞一个前文一样的甘特图，然后看看有没有安排特别爆炸或者考试时间冲突的时候，再据此考虑放弃一些专攻 5.5 关于备考心态 准备修考是一件很让人心态炸裂的事情，因为你会发现自己总是还有没有准备到位的地方，而且计划永远赶不上变化。以下是我比较认同的几个心态上的注意事项，仅供参考： 做好信息搜集工作。 千里之行始于足下。不要被看似无法完成的复习任务吓到，逼话少说，开搞。 发现自己有知识点不会是好事，毕竟考试的时候再发现就来不及了。但也要多把目光放在自己已经会了的知识上，意识到自己一直在前进。 告诉自己塞翁失马焉知非福，同时不以物喜不以己悲。 不要提前宣判自己失败，请坚持到最后一刻。 5.6 其他资料推荐 认真阅读想考的专攻的募集要项是最优先的，然后这里是几个也许有用的文章/网站分享。 黑白：简单易懂的现代日本留学攻略(硕士篇) 银杏树下 日本留学情报共享 6. 结语 经历了修考，更加感觉到很多事情都讲究一个「積み重ねや繰り返し」：选择好适合自己的方向与方法之后，认真对待每一件小事而付出的努力就能把你带到梦想之地。 接下来笔者将会以在东大毕业以及在日本找到一份钱多事少的工作为目标努力，顺利的话我们三年后就活经验贴再见！也祝看到这里的大家学业顺利事业成功！ ","link":"https://311zzb.github.io/post/shuang-fei-zhuan-ma-6-ge-yue-kao-qu-ming-gu-wu-da-xue-qing-bao-xue-zhi-neng-sisutemudong-jing-da-xue-xin-ling-yu-ren-jian-huan-jing-jing-yan-fen-xiang/"},{"title":"日语学习工具推荐","content":" 人们总会高估自己几天能做的事情，却往往低估自己几年能做的事情。 从18年9月2日下定决心学日语然后买了个网课到2020年12月通过JLPT N1，大部分时间我都感觉学习日语是一件相当快乐简单又有收获的事情。 以下记录一些我目前认为对自学日语相当有用的网站，中高級者向けです。 NHK的注音新闻网站（中低难度阅读练习） NEWS WEB EASY OJAD，查动词变形、确认句子的正确语调（工具类，强烈推荐） OJAD - オンライン日本語アクセント辞書 在线词典集成版 コトバンク [ 時事問題、ニュースもわかるネット百科事典 ] 查汉字 漢字ペディア 漢字や言葉の意味を調べてみよう！ 认识母语者以及让他们帮忙改文法 HiNative | 一个针对外语学习者的问答平台。 又是几个词典 辞典・百科事典の検索サービス - Weblio辞書 若者言葉辞典～あなたはわかりますか？～｜若者が使う言葉を【意味】【由来】【使用例】を交え、わかりやすく解説します。 実用日本語表現辞典 Youtube上的两个日语新闻频道（非常建议每天看，很提高听力和语感）（不少关于中国的视频和特集也很有意思）（各种难度的听力练习） ANNnewsCH テレ東NEWS 一个铁道交通厨频道（相当地狱难度的听力练习） スーツ 交通 / Suit Train 略猎奇的五分钟小故事频道（中等难度的听力练习） ヒューマンバグ大学_闇の漫画 阅读练习（推上关注点感兴趣的博主然后每天花时间刷一刷） Twitter 口语练习，与native speaker对话，可以让对方指出你表达中有违和感的地方 italki: Learn a language online 最后顺便一提我学日语主要用的是沪江的0-N2和N2-N1，就是最普通的网课，大概加起来4000元（买0-N1是三千多但我刚开始学的时候是打算学到N2就差不多了）。 虽然网上也有上面所题网课的免费资源，但花了钱会更有沉没成本而且保护了知识产权，所以还是推荐买正版。 上面的这些网站和频道是在学习过程中慢慢开始用的，各种日语YouTube频道可以帮助你保持学习的主观能动性以及达到练习听力、语感的效果，所以我非常推荐。我学日语的最近一年说是主要是在看这些东西学习也不为过。 另外补充一个小技巧，上课学到的例句可以花时间背下来一些，背不下来读很多遍也行，这样可以在很大程度上提高语感 最后要推荐的是シャドーイング 日本語を話そう，这本书中的口语表达十分地道。只要每天十分钟跟读就能一点点提高口语水平。在网上有pdf和听力资源。 ","link":"https://311zzb.github.io/post/ri-yu-xue-xi-gong-ju-tui-jian/"},{"title":"本科毕设 Undergraduate Final Project","content":"总之把毕设的poster和论文都放在这里了。 说起来惭愧，我曾经也是学设计的。 Poster download（OneDrive） Thesis download（OneDrive） 注：出于保护个人情报的考虑，删去了包含我姓名的Declaration of Originality ","link":"https://311zzb.github.io/post/ben-ke-bi-she-undergraduate-final-project/"}]}